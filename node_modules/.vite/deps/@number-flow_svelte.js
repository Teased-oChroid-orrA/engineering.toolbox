import "./chunk-MZVN5SDE.js";
import "./chunk-PUOORLAV.js";
import {
  add_locations,
  attribute_effect,
  beforeUpdate,
  bind_this,
  bubble_event,
  check_target,
  derived,
  get as get2,
  hmr,
  html,
  init,
  legacy_api,
  legacy_rest_props,
  onDestroy,
  onMount,
  prop,
  readable,
  setup_stores,
  slot,
  store_get,
  store_set,
  validate_store,
  writable
} from "./chunk-5WFYUS7G.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html
} from "./chunk-PERA7TLK.js";
import {
  FILENAME,
  HMR,
  child,
  deep_read_state,
  event,
  first_child,
  get,
  getContext,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mutable_source,
  pop,
  push,
  reset,
  set,
  setContext,
  tick,
  track_reactivity_loss,
  untrack
} from "./chunk-UTYDR3E7.js";
import "./chunk-XWATFG4W.js";
import {
  true_default
} from "./chunk-HNWPC2PS.js";
import "./chunk-64OFGQB4.js";
import "./chunk-OHYQYV5R.js";

// node_modules/number-flow/dist/plugins.mjs
var f = (e, n) => e == null ? n : n == null ? e : Math.max(e, n);
var i = /* @__PURE__ */ new WeakMap();
var l = {
  onUpdate(e, n, o) {
    if (i.set(o, void 0), !o.computedTrend)
      return;
    const s = n.integer.concat(n.fraction).filter((t) => t.type === "integer" || t.type === "fraction"), r = e.integer.concat(e.fraction).filter((t) => t.type === "integer" || t.type === "fraction"), u2 = s.find((t) => !r.find((c) => c.pos === t.pos && c.value === t.value)), a = r.find((t) => !s.find((c) => t.pos === c.pos && t.value === c.value));
    i.set(o, f(u2 == null ? void 0 : u2.pos, a == null ? void 0 : a.pos));
  },
  getDelta(e, n, o) {
    const s = e - n, r = i.get(o.flow);
    if (!s && r != null && r >= o.pos)
      return o.length * o.flow.computedTrend;
  }
};

// node_modules/number-flow/dist/lite-BtgQ9jUv.mjs
var m = (n, t, e) => {
  const i2 = document.createElement(n), [s, a] = Array.isArray(t) ? [void 0, t] : [t, e];
  return s && Object.assign(i2, s), a == null || a.forEach((r) => i2.appendChild(r)), i2;
};
var B = (n, t) => {
  var e;
  return t === "left" ? n.offsetLeft : (((e = n.offsetParent instanceof HTMLElement ? n.offsetParent : null) == null ? void 0 : e.offsetWidth) ?? 0) - n.offsetWidth - n.offsetLeft;
};
var D = (n) => n.offsetWidth > 0 && n.offsetHeight > 0;
var it = (n, t) => {
  true_default && !customElements.get(n) && customElements.define(n, t);
};
function F(n, t, { reverse: e = false } = {}) {
  const i2 = n.length;
  for (let s = e ? i2 - 1 : 0; e ? s >= 0 : s < i2; e ? s-- : s++)
    t(n[s], s);
}
function st(n, t, e, i2) {
  const s = t.formatToParts(n);
  e && s.unshift({ type: "prefix", value: e }), i2 && s.push({ type: "suffix", value: i2 });
  const a = [], r = [], o = [], c = [], d = {}, p = (h) => `${h}:${d[h] = (d[h] ?? -1) + 1}`;
  let x = "", g = false, y = false;
  for (const h of s) {
    x += h.value;
    const l2 = h.type === "minusSign" || h.type === "plusSign" ? "sign" : h.type;
    l2 === "integer" ? (g = true, r.push(...h.value.split("").map((S) => ({ type: l2, value: parseInt(S) })))) : l2 === "group" ? r.push({ type: l2, value: h.value }) : l2 === "decimal" ? (y = true, o.push({ type: l2, value: h.value, key: p(l2) })) : l2 === "fraction" ? o.push(...h.value.split("").map((S) => ({
      type: l2,
      value: parseInt(S),
      key: p(l2),
      pos: -1 - d[l2]
    }))) : (g || y ? c : a).push({
      type: l2,
      value: h.value,
      key: p(l2)
    });
  }
  const P = [];
  for (let h = r.length - 1; h >= 0; h--) {
    const l2 = r[h];
    P.unshift(l2.type === "integer" ? {
      ...l2,
      key: p(l2.type),
      pos: d[l2.type]
    } : {
      ...l2,
      key: p(l2.type)
    });
  }
  return {
    pre: a,
    integer: P,
    fraction: o,
    post: c,
    valueAsString: x,
    value: typeof n == "string" ? parseFloat(n) : n
  };
}
var H = String.raw;
var L = String.raw;
var X = true_default && (() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return false;
  }
  return true;
})();
var I = true_default && typeof CSS < "u" && CSS.supports && CSS.supports("line-height", "mod(1,1)");
var A = true_default && typeof matchMedia < "u" ? matchMedia("(prefers-reduced-motion: reduce)") : null;
var b = "--_number-flow-d-opacity";
var U = "--_number-flow-d-width";
var $ = "--_number-flow-dx";
var R = "--_number-flow-d";
var O = (() => {
  try {
    return CSS.registerProperty({
      name: b,
      syntax: "<number>",
      inherits: false,
      initialValue: "0"
    }), CSS.registerProperty({
      name: $,
      syntax: "<length>",
      inherits: true,
      initialValue: "0px"
    }), CSS.registerProperty({
      name: U,
      syntax: "<number>",
      inherits: false,
      initialValue: "0"
    }), CSS.registerProperty({
      name: R,
      syntax: "<number>",
      inherits: true,
      initialValue: "0"
    }), true;
  } catch {
    return false;
  }
})();
var j = "var(--number-flow-char-height, 1em)";
var f2 = "var(--number-flow-mask-height, 0.25em)";
var C = `calc(${f2} / 2)`;
var k = "var(--number-flow-mask-width, 0.5em)";
var u = `calc(${k} / var(--scale-x))`;
var v = "#000 0, transparent 71%";
var z = L`:host{display:inline-block;direction:ltr;white-space:nowrap;isolation:isolate;line-height:${j} !important}.number,.number__inner{display:inline-block;transform-origin:left top}:host([data-will-change]) :is(.number,.number__inner,.section,.digit,.digit__num,.symbol){will-change:transform}.number{--scale-x:calc(1 + var(${U}) / var(--width));transform:translateX(var(${$})) scaleX(var(--scale-x));margin:0 calc(-1 * ${k});position:relative;-webkit-mask-image:linear-gradient(to right,transparent 0,#000 ${u},#000 calc(100% - ${u}),transparent ),linear-gradient(to bottom,transparent 0,#000 ${f2},#000 calc(100% - ${f2}),transparent 100% ),radial-gradient(at bottom right,${v}),radial-gradient(at bottom left,${v}),radial-gradient(at top left,${v}),radial-gradient(at top right,${v});-webkit-mask-size:100% calc(100% - ${f2} * 2),calc(100% - ${u} * 2) 100%,${u} ${f2},${u} ${f2},${u} ${f2},${u} ${f2};-webkit-mask-position:center,center,top left,top right,bottom right,bottom left;-webkit-mask-repeat:no-repeat}.number__inner{padding:${C} ${k};transform:scaleX(calc(1 / var(--scale-x))) translateX(calc(-1 * var(${$})))}:host > :not(.number){z-index:5}.section,.symbol{display:inline-block;position:relative;isolation:isolate}.section::after{content:'\200b';display:inline-block}.section--justify-left{transform-origin:center left}.section--justify-right{transform-origin:center right}.section > [inert],.symbol > [inert]{margin:0 !important;position:absolute !important;z-index:-1}.digit{display:inline-block;position:relative;--c:var(--current) + var(${R})}.digit__num,.number .section::after{padding:${C} 0}.digit__num{display:inline-block;--offset-raw:mod(var(--length) + var(--n) - mod(var(--c),var(--length)),var(--length));--offset:calc( var(--offset-raw) - var(--length) * round(down,var(--offset-raw) / (var(--length) / 2),1) );--y:clamp(-100%,var(--offset) * 100%,100%);transform:translateY(var(--y))}.digit__num[inert]{position:absolute;top:0;left:50%;transform:translateX(-50%) translateY(var(--y))}.digit:not(.is-spinning) .digit__num[inert]{display:none}.symbol__value{display:inline-block;mix-blend-mode:plus-lighter;white-space:pre}.section--justify-left .symbol > [inert]{left:0}.section--justify-right .symbol > [inert]{right:0}.animate-presence{opacity:calc(1 + var(${b}))}`;
var Y = true_default ? HTMLElement : class {
};
var G = L`:host{display:inline-block;direction:ltr;white-space:nowrap;line-height:${j} !important}span{display:inline-block}:host([data-will-change]) span{will-change:transform}.number,.digit{padding:${C} 0}.symbol{white-space:pre}`;
var K = (n) => `<span class="${n.type === "integer" || n.type === "fraction" ? "digit" : "symbol"}" part="${n.type === "integer" || n.type === "fraction" ? `digit ${n.type}-digit` : `symbol ${n.type}`}">${n.value}</span>`;
var w = (n, t) => `<span part="${t}">${n.reduce((e, i2) => e + K(i2), "")}</span>`;
var nt = (n) => (
  // shadowroot="open" non-standard attribute for old Chrome:
  H`<template shadowroot="open" shadowrootmode="open"
			><style>
				${G}</style
			><span role="img" aria-label="${n.valueAsString}"
				>${w(n.pre, "left")}<span part="number" class="number"
					>${w(n.integer, "integer")}${w(n.fraction, "fraction")}</span
				>${w(n.post, "right")}</span
			></template
		><span
			style="font-kerning: none; display: inline-block; line-height: ${j} !important; padding: ${f2} 0;"
			>${n.valueAsString}</span
		>`
);
var Z = I && X && O;
var q = class extends Y {
  constructor() {
    super(), this.created = false, this.batched = false;
    const { animated: t, ...e } = this.constructor.defaultProps;
    this._animated = this.computedAnimated = t, Object.assign(this, e);
  }
  get animated() {
    return this._animated;
  }
  set animated(t) {
    var e;
    this.animated !== t && (this._animated = t, (e = this.shadowRoot) == null || e.getAnimations().forEach((i2) => i2.finish()));
  }
  /**
   * @internal
   */
  set data(t) {
    var o;
    if (t == null)
      return;
    const { pre: e, integer: i2, fraction: s, post: a, value: r } = t;
    if (this.created) {
      const c = this._data;
      this._data = t, this.computedTrend = typeof this.trend == "function" ? this.trend(c.value, r) : this.trend, this.computedAnimated = Z && this._animated && (!this.respectMotionPreference || !(A != null && A.matches)) && // https://github.com/barvian/number-flow/issues/9
      D(this), (o = this.plugins) == null || o.forEach((d) => {
        var p;
        return (p = d.onUpdate) == null ? void 0 : p.call(d, t, c, this);
      }), this.batched || this.willUpdate(), this._pre.update(e), this._num.update({ integer: i2, fraction: s }), this._post.update(a), this.batched || this.didUpdate();
    } else {
      this._data = t, this.attachShadow({ mode: "open" });
      try {
        this._internals ?? (this._internals = this.attachInternals()), this._internals.role = "img";
      } catch {
      }
      const c = document.createElement("style");
      c.textContent = z, this.shadowRoot.appendChild(c), this._pre = new M(this, e, {
        justify: "right",
        part: "left"
      }), this.shadowRoot.appendChild(this._pre.el), this._num = new J(this, i2, s), this.shadowRoot.appendChild(this._num.el), this._post = new M(this, a, {
        justify: "left",
        part: "right"
      }), this.shadowRoot.appendChild(this._post.el), this.created = true;
    }
    try {
      this._internals.ariaLabel = t.valueAsString;
    } catch {
    }
  }
  /**
   * @internal
   */
  willUpdate() {
    this._pre.willUpdate(), this._num.willUpdate(), this._post.willUpdate();
  }
  /**
   * @internal
   */
  didUpdate() {
    if (!this.computedAnimated)
      return;
    this._abortAnimationsFinish ? this._abortAnimationsFinish.abort() : this.dispatchEvent(new Event("animationsstart")), this._pre.didUpdate(), this._num.didUpdate(), this._post.didUpdate();
    const t = new AbortController();
    Promise.all(this.shadowRoot.getAnimations().map((e) => e.finished)).then(() => {
      t.signal.aborted || (this.dispatchEvent(new Event("animationsfinish")), this._abortAnimationsFinish = void 0);
    }), this._abortAnimationsFinish = t;
  }
};
q.defaultProps = {
  transformTiming: {
    duration: 900,
    // Make sure to keep this minified:
    easing: "linear(0,.005,.019,.039,.066,.096,.129,.165,.202,.24,.278,.316,.354,.39,.426,.461,.494,.526,.557,.586,.614,.64,.665,.689,.711,.731,.751,.769,.786,.802,.817,.831,.844,.856,.867,.877,.887,.896,.904,.912,.919,.925,.931,.937,.942,.947,.951,.955,.959,.962,.965,.968,.971,.973,.976,.978,.98,.981,.983,.984,.986,.987,.988,.989,.99,.991,.992,.992,.993,.994,.994,.995,.995,.996,.996,.9963,.9967,.9969,.9972,.9975,.9977,.9979,.9981,.9982,.9984,.9985,.9987,.9988,.9989,1)"
  },
  spinTiming: void 0,
  opacityTiming: { duration: 450, easing: "ease-out" },
  animated: true,
  trend: (n, t) => Math.sign(t - n),
  respectMotionPreference: true,
  plugins: void 0,
  digits: void 0
};
var J = class {
  constructor(t, e, i2, { className: s, ...a } = {}) {
    this.flow = t, this._integer = new T(t, e, {
      justify: "right",
      part: "integer"
    }), this._fraction = new T(t, i2, {
      justify: "left",
      part: "fraction"
    }), this._inner = m("span", {
      className: "number__inner"
    }, [this._integer.el, this._fraction.el]), this.el = m("span", {
      ...a,
      part: "number",
      className: `number ${s ?? ""}`
    }, [this._inner]);
  }
  willUpdate() {
    this._prevWidth = this.el.offsetWidth, this._prevLeft = this.el.getBoundingClientRect().left, this._integer.willUpdate(), this._fraction.willUpdate();
  }
  update({ integer: t, fraction: e }) {
    this._integer.update(t), this._fraction.update(e);
  }
  didUpdate() {
    const t = this.el.getBoundingClientRect();
    this._integer.didUpdate(), this._fraction.didUpdate();
    const e = this._prevLeft - t.left, i2 = this.el.offsetWidth, s = this._prevWidth - i2;
    this.el.style.setProperty("--width", String(i2)), this.el.animate({
      [$]: [`${e}px`, "0px"],
      [U]: [s, 0]
    }, {
      ...this.flow.transformTiming,
      composite: "accumulate"
    });
  }
};
var N = class {
  constructor(t, e, { justify: i2, className: s, ...a }, r) {
    this.flow = t, this.children = /* @__PURE__ */ new Map(), this.onCharRemove = (c) => () => {
      this.children.delete(c);
    }, this.justify = i2;
    const o = e.map((c) => this.addChar(c).el);
    this.el = m("span", {
      ...a,
      className: `section section--justify-${i2} ${s ?? ""}`
    }, r ? r(o) : o);
  }
  addChar(t, { startDigitsAtZero: e = false, ...i2 } = {}) {
    const s = t.type === "integer" || t.type === "fraction" ? new W(this, t.type, e ? 0 : t.value, t.pos, {
      ...i2,
      onRemove: this.onCharRemove(t.key)
    }) : new Q(this, t.type, t.value, {
      ...i2,
      onRemove: this.onCharRemove(t.key)
    });
    return this.children.set(t.key, s), s;
  }
  unpop(t) {
    t.el.removeAttribute("inert"), t.el.style.top = "", t.el.style[this.justify] = "";
  }
  pop(t) {
    t.forEach((e) => {
      e.el.style.top = `${e.el.offsetTop}px`, e.el.style[this.justify] = `${B(e.el, this.justify)}px`;
    }), t.forEach((e) => {
      e.el.setAttribute("inert", ""), e.present = false;
    });
  }
  addNewAndUpdateExisting(t) {
    const e = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Map(), s = this.justify === "left", a = s ? "prepend" : "append";
    if (F(t, (r) => {
      let o;
      this.children.has(r.key) ? (o = this.children.get(r.key), i2.set(r, o), this.unpop(o), o.present = true) : (o = this.addChar(r, { startDigitsAtZero: true, animateIn: true }), e.set(r, o)), this.el[a](o.el);
    }, { reverse: s }), this.flow.computedAnimated) {
      const r = this.el.getBoundingClientRect();
      e.forEach((o) => {
        o.willUpdate(r);
      });
    }
    e.forEach((r, o) => {
      r.update(o.value);
    }), i2.forEach((r, o) => {
      r.update(o.value);
    });
  }
  willUpdate() {
    const t = this.el.getBoundingClientRect();
    this._prevOffset = t[this.justify], this.children.forEach((e) => e.willUpdate(t));
  }
  didUpdate() {
    const t = this.el.getBoundingClientRect();
    this.children.forEach((s) => s.didUpdate(t));
    const e = t[this.justify], i2 = this._prevOffset - e;
    i2 && this.children.size && this.el.animate({
      transform: [`translateX(${i2}px)`, "none"]
    }, {
      ...this.flow.transformTiming,
      composite: "accumulate"
    });
  }
};
var T = class extends N {
  update(t) {
    const e = /* @__PURE__ */ new Map();
    this.children.forEach((i2, s) => {
      t.find((a) => a.key === s) || e.set(s, i2), this.unpop(i2);
    }), this.addNewAndUpdateExisting(t), e.forEach((i2) => {
      i2 instanceof W && i2.update(0);
    }), this.pop(e);
  }
};
var M = class extends N {
  update(t) {
    const e = /* @__PURE__ */ new Map();
    this.children.forEach((i2, s) => {
      t.find((a) => a.key === s) || e.set(s, i2);
    }), this.pop(e), this.addNewAndUpdateExisting(t);
  }
};
var E = class {
  constructor(t, e, { onRemove: i2, animateIn: s = false } = {}) {
    this.flow = t, this.el = e, this._present = true, this._remove = () => {
      var a;
      this.el.remove(), (a = this._onRemove) == null || a.call(this);
    }, this.el.classList.add("animate-presence"), this.flow.computedAnimated && s && this.el.animate({
      [b]: [-0.9999, 0]
    }, {
      ...this.flow.opacityTiming,
      composite: "accumulate"
    }), this._onRemove = i2;
  }
  get present() {
    return this._present;
  }
  set present(t) {
    if (this._present !== t) {
      if (this._present = t, t ? this.el.removeAttribute("inert") : this.el.setAttribute("inert", ""), !this.flow.computedAnimated) {
        t || this._remove();
        return;
      }
      this.el.style.setProperty("--_number-flow-d-opacity", t ? "0" : "-.999"), this.el.animate({
        [b]: t ? [-0.9999, 0] : [0.999, 0]
      }, {
        ...this.flow.opacityTiming,
        composite: "accumulate"
      }), t ? this.flow.removeEventListener("animationsfinish", this._remove) : this.flow.addEventListener("animationsfinish", this._remove, {
        once: true
      });
    }
  }
};
var V = class extends E {
  constructor(t, e, i2, s) {
    super(t.flow, i2, s), this.section = t, this.value = e, this.el = i2;
  }
};
var W = class extends V {
  constructor(t, e, i2, s, a) {
    var d, p;
    const r = (((p = (d = t.flow.digits) == null ? void 0 : d[s]) == null ? void 0 : p.max) ?? 9) + 1, o = Array.from({ length: r }).map((x, g) => {
      const y = m("span", { className: "digit__num" }, [
        document.createTextNode(String(g))
      ]);
      return g !== i2 && y.setAttribute("inert", ""), y.style.setProperty("--n", String(g)), y;
    }), c = m("span", {
      part: `digit ${e}-digit`,
      className: "digit"
    }, o);
    c.style.setProperty("--current", String(i2)), c.style.setProperty("--length", String(r)), super(t, i2, c, a), this.pos = s, this._onAnimationsFinish = () => {
      this.el.classList.remove("is-spinning");
    }, this._numbers = o, this.length = r;
  }
  willUpdate(t) {
    const e = this.el.getBoundingClientRect();
    this._prevValue = this.value;
    const i2 = e[this.section.justify] - t[this.section.justify], s = e.width / 2;
    this._prevCenter = this.section.justify === "left" ? i2 + s : i2 - s;
  }
  update(t) {
    this.el.style.setProperty("--current", String(t)), this._numbers.forEach((e, i2) => i2 === t ? e.removeAttribute("inert") : e.setAttribute("inert", "")), this.value = t;
  }
  didUpdate(t) {
    const e = this.el.getBoundingClientRect(), i2 = e[this.section.justify] - t[this.section.justify], s = e.width / 2, a = this.section.justify === "left" ? i2 + s : i2 - s, r = this._prevCenter - a;
    r && this.el.animate({
      transform: [`translateX(${r}px)`, "none"]
    }, {
      ...this.flow.transformTiming,
      composite: "accumulate"
    });
    const o = this.getDelta();
    o && (this.el.classList.add("is-spinning"), this.el.animate({
      [R]: [-o, 0]
    }, {
      ...this.flow.spinTiming ?? this.flow.transformTiming,
      composite: "accumulate"
    }), this.flow.addEventListener("animationsfinish", this._onAnimationsFinish, { once: true }));
  }
  getDelta() {
    var i2;
    if (this.flow.plugins)
      for (const s of this.flow.plugins) {
        const a = (i2 = s.getDelta) == null ? void 0 : i2.call(s, this.value, this._prevValue, this);
        if (a != null)
          return a;
      }
    const t = this.value - this._prevValue, e = this.flow.computedTrend || Math.sign(t);
    return e < 0 && this.value > this._prevValue ? this.value - this.length - this._prevValue : e > 0 && this.value < this._prevValue ? this.length - this._prevValue + this.value : t;
  }
};
var Q = class extends V {
  constructor(t, e, i2, s) {
    const a = m("span", {
      className: "symbol__value",
      textContent: i2
    });
    super(t, i2, m("span", {
      part: `symbol ${e}`,
      className: "symbol"
    }, [a]), s), this.type = e, this._children = /* @__PURE__ */ new Map(), this._onChildRemove = (r) => () => {
      this._children.delete(r);
    }, this._children.set(i2, new E(this.flow, a, {
      onRemove: this._onChildRemove(i2)
    }));
  }
  willUpdate(t) {
    if (this.type === "decimal")
      return;
    const e = this.el.getBoundingClientRect();
    this._prevOffset = e[this.section.justify] - t[this.section.justify];
  }
  update(t) {
    if (this.value !== t) {
      const e = this._children.get(this.value);
      e && (e.present = false);
      const i2 = this._children.get(t);
      if (i2)
        i2.present = true;
      else {
        const s = m("span", {
          className: "symbol__value",
          textContent: t
        });
        this.el.appendChild(s), this._children.set(t, new E(this.flow, s, {
          animateIn: true,
          onRemove: this._onChildRemove(t)
        }));
      }
    }
    this.value = t;
  }
  didUpdate(t) {
    if (this.type === "decimal")
      return;
    const i2 = this.el.getBoundingClientRect()[this.section.justify] - t[this.section.justify], s = this._prevOffset - i2;
    s && this.el.animate({
      transform: [`translateX(${s}px)`, "none"]
    }, { ...this.flow.transformTiming, composite: "accumulate" });
  }
};

// node_modules/@number-flow/svelte/dist/group.js
var groupKey = /* @__PURE__ */ Symbol("group");
function setGroupContext(ctx) {
  setContext(groupKey, ctx);
}
function getGroupContext() {
  return getContext(groupKey);
}

// node_modules/@number-flow/svelte/dist/NumberFlowGroup.svelte
NumberFlowGroup[FILENAME] = "node_modules/@number-flow/svelte/dist/NumberFlowGroup.svelte";
function NumberFlowGroup($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, NumberFlowGroup);
  const flows = /* @__PURE__ */ new Set();
  let updating = false;
  const registerWithGroup = (el) => {
    flows.add(el);
    beforeUpdate(async () => {
      if (updating) return;
      updating = true;
      flows.forEach(async (flow) => {
        {
          const f3 = get2(flow);
          if (!f3 || !f3.created) return;
          f3.willUpdate();
        }
        (await track_reactivity_loss(tick()))();
        get2(flow)?.didUpdate();
      });
      (await track_reactivity_loss(tick()))();
      updating = false;
    });
    onDestroy(() => {
      flows.delete(el);
    });
  };
  setGroupContext({ register: registerWithGroup });
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  NumberFlowGroup = hmr(NumberFlowGroup);
  import.meta.hot.accept((module) => {
    NumberFlowGroup[HMR].update(module.default);
  });
}
var NumberFlowGroup_default = NumberFlowGroup;

// node_modules/@number-flow/svelte/dist/NumberFlow.svelte
NumberFlow[FILENAME] = "node_modules/@number-flow/svelte/dist/NumberFlow.svelte";
var NumberFlowElement = class extends q {
  set __svelte_batched(batched) {
    this.batched = batched;
  }
  set data(data) {
    super.data = data;
  }
};
Object.keys(NumberFlowElement.defaultProps).forEach((key) => {
  Object.defineProperty(NumberFlowElement.prototype, `__svelte_${key.toLowerCase()}`, {
    set(value) {
      this[key] = value;
    },
    enumerable: true,
    configurable: true
  });
});
it("number-flow-svelte", NumberFlowElement);
var root = add_locations(from_html(`<number-flow-svelte><!></number-flow-svelte>`, 2), NumberFlow[FILENAME], [[52, 0]]);
function NumberFlow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "locales",
    "format",
    "value",
    "prefix",
    "suffix",
    "willChange",
    "transformTiming",
    "spinTiming",
    "opacityTiming",
    "animated",
    "respectMotionPreference",
    "trend",
    "plugins",
    "digits",
    "el"
  ]);
  push($$props, false, NumberFlow);
  const $elStore = () => (validate_store(elStore, "elStore"), store_get(elStore, "$elStore", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  const formatter = mutable_source();
  const data = mutable_source();
  let locales = prop($$props, "locales", 24, () => void 0);
  let format = prop($$props, "format", 24, () => void 0);
  let value = prop($$props, "value", 8);
  let prefix = prop($$props, "prefix", 24, () => void 0);
  let suffix = prop($$props, "suffix", 24, () => void 0);
  let willChange = prop($$props, "willChange", 8, false);
  let transformTiming = prop($$props, "transformTiming", 24, () => NumberFlowElement.defaultProps.transformTiming);
  let spinTiming = prop($$props, "spinTiming", 24, () => NumberFlowElement.defaultProps.spinTiming);
  let opacityTiming = prop($$props, "opacityTiming", 24, () => NumberFlowElement.defaultProps.opacityTiming);
  let animated = prop($$props, "animated", 24, () => NumberFlowElement.defaultProps.animated);
  let respectMotionPreference = prop($$props, "respectMotionPreference", 24, () => NumberFlowElement.defaultProps.respectMotionPreference);
  let trend = prop($$props, "trend", 24, () => NumberFlowElement.defaultProps.trend);
  let plugins = prop($$props, "plugins", 24, () => NumberFlowElement.defaultProps.plugins);
  let digits = prop($$props, "digits", 24, () => NumberFlowElement.defaultProps.digits);
  let el = prop($$props, "el", 28, () => void 0);
  const elStore = writable(el());
  const group = getGroupContext();
  group?.register?.(elStore);
  legacy_pre_effect(() => deep_read_state(el()), () => {
    store_set(elStore, el());
  });
  legacy_pre_effect(() => (deep_read_state(locales()), deep_read_state(format())), () => {
    set(formatter, new Intl.NumberFormat(locales(), format()));
  });
  legacy_pre_effect(
    () => (st, deep_read_state(value()), get(formatter), deep_read_state(prefix()), deep_read_state(suffix())),
    () => {
      set(data, st(value(), get(formatter), prefix(), suffix()));
    }
  );
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  init();
  var number_flow_svelte = root();
  attribute_effect(
    number_flow_svelte,
    ($0) => ({
      ...$$restProps,
      "data-will-change": willChange() ? "" : void 0,
      __svelte_batched: $0,
      __svelte_transformtiming: transformTiming(),
      __svelte_spintiming: spinTiming(),
      __svelte_opacitytiming: opacityTiming(),
      __svelte_animated: animated(),
      __svelte_respectmotionpreference: respectMotionPreference(),
      __svelte_trend: trend(),
      __svelte_plugins: plugins(),
      __svelte_digits: digits(),
      data: get(data)
    }),
    [() => untrack(() => Boolean(group))]
  );
  var node = child(number_flow_svelte);
  html(node, () => (deep_read_state(true_default), deep_read_state(nt), get(data), untrack(() => true_default ? void 0 : nt(get(data)))));
  reset(number_flow_svelte);
  bind_this(number_flow_svelte, ($$value) => el($$value), () => el());
  event("animationsstart", number_flow_svelte, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event("animationsfinish", number_flow_svelte, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, number_flow_svelte);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  NumberFlow = hmr(NumberFlow);
  import.meta.hot.accept((module) => {
    NumberFlow[HMR].update(module.default);
  });
}
var NumberFlow_default = NumberFlow;

// node_modules/@number-flow/svelte/dist/index.js
var canAnimate = readable(false, (set2) => {
  onMount(() => {
    set2(Z);
  });
});
var prefersReducedMotion = readable(false, (set2) => {
  onMount(() => {
    set2(A?.matches ?? false);
    const onChange = ({ matches }) => {
      set2(matches);
    };
    A?.addEventListener("change", onChange);
    return () => {
      A?.removeEventListener("change", onChange);
    };
  });
});
var canAnimateWithPreference = derived([canAnimate, prefersReducedMotion], ([canAnimate2, prefersReducedMotion2]) => canAnimate2 && !prefersReducedMotion2);
var getCanAnimate = ({ respectMotionPreference = true } = {}) => respectMotionPreference ? canAnimateWithPreference : canAnimate;
export {
  NumberFlowElement,
  NumberFlowGroup_default as NumberFlowGroup,
  l as continuous,
  NumberFlow_default as default,
  getCanAnimate
};
//# sourceMappingURL=@number-flow_svelte.js.map
