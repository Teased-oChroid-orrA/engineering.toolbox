import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  hide,
  limitShift,
  offset,
  shift,
  size
} from "./chunk-OAO4W7NW.js";
import {
  add_locations,
  attribute_effect,
  check_target,
  createAttachmentKey,
  each,
  element,
  fromAction,
  hmr,
  if_block,
  legacy_api,
  log_if_contains_state,
  onDestroy,
  onMount,
  rest_props,
  snippet,
  validate_dynamic_element_tag,
  validate_each_keys,
  validate_snippet_args,
  validate_void_dynamic_element,
  wrap_snippet
} from "./chunk-5WFYUS7G.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html,
  from_svg,
  mount,
  props_id,
  set_text,
  text,
  unmount
} from "./chunk-PERA7TLK.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  exclude_from_object,
  fallback,
  first_child,
  flushSync,
  get,
  getAllContexts,
  getContext,
  next,
  noop,
  pop,
  proxy,
  push,
  replay_events,
  reset,
  set,
  setContext,
  sibling,
  state,
  strict_equals,
  tag,
  template_effect,
  to_array,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-UTYDR3E7.js";
import "./chunk-XWATFG4W.js";
import "./chunk-HNWPC2PS.js";
import "./chunk-64OFGQB4.js";
import "./chunk-OHYQYV5R.js";

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/create-context.js
function createContext(defaultValue) {
  const key = /* @__PURE__ */ Symbol();
  return {
    key,
    consume() {
      return getContext(key) || defaultValue;
    },
    provide(value) {
      return setContext(key, value);
    }
  };
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/modules/item-context.js
var ItemContext = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/modules/root-context.js
var RootContext = createContext();

// node_modules/@zag-js/utils/dist/index.mjs
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
function toArray(v) {
  if (v == null) return [];
  return Array.isArray(v) ? v : [v];
}
var fromLength = (length) => Array.from(Array(length).keys());
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var has = (v, t) => v.indexOf(t) !== -1;
var add = (v, ...items) => v.concat(items);
var remove = (v, ...items) => v.filter((t) => !items.includes(t));
var removeAt = (v, i) => v.filter((_, idx) => idx !== i);
var uniq = (v) => Array.from(new Set(v));
var diff = (a, b) => {
  const set2 = new Set(b);
  return a.filter((t) => !set2.has(t));
};
var addOrRemove = (v, item) => has(v, item) ? remove(v, item) : add(v, item);
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next22 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1) return step > 0 ? 0 : last2;
  if (next22 < 0) return loop ? last2 : 0;
  if (next22 >= len) return loop ? 0 : idx > len ? len : idx;
  return next22;
}
function next2(v, idx, opts = {}) {
  return v[nextIndex(v, idx, opts)];
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
function prev(v, index, opts = {}) {
  return v[prevIndex(v, index, opts)];
}
function chunk(v, size2) {
  return v.reduce((rows, value, index) => {
    if (index % size2 === 0) rows.push([value]);
    else last(rows)?.push(value);
    return rows;
  }, []);
}
function flatArray(arr) {
  return arr.reduce((flat, item) => {
    if (Array.isArray(item)) {
      return flat.concat(flatArray(item));
    }
    return flat.concat(item);
  }, []);
}
function partition(arr, fn) {
  return arr.reduce(
    ([pass, fail], value) => {
      if (fn(value)) pass.push(value);
      else fail.push(value);
      return [pass, fail];
    },
    [[], []]
  );
}
var isArrayLike = (value) => value?.constructor.name === "Array";
var isArrayEqual = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual(a[i], b[i])) return false;
  }
  return true;
};
var isEqual = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof a?.isEqual === "function" && typeof b?.isEqual === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike(a) && isArrayLike(b)) {
    return isArrayEqual(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    if (!isEqual(a[key], b[key])) return false;
  }
  return true;
};
var isArray = (v) => Array.isArray(v);
var isBoolean = (v) => v === true || v === false;
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject = (v) => isObjectLike(v) && !isArray(v);
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";
var isNull = (v) => v == null;
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v) => Object.prototype.toString.call(v);
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var isPlainObject = (v) => {
  if (!isObjectLike(v) || baseGetTag(v) != "[object Object]" || isFrameworkElement(v)) return false;
  const proto = Object.getPrototypeOf(v);
  if (proto === null) return true;
  const Ctor = hasProp(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;
};
var isReactElement = (x2) => typeof x2 === "object" && x2 !== null && "$$typeof" in x2 && "props" in x2;
var isVueElement = (x2) => typeof x2 === "object" && x2 !== null && "__v_isVNode" in x2;
var isFrameworkElement = (x2) => isReactElement(x2) || isVueElement(x2);
var runIfFn = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res ?? void 0;
};
var cast = (v) => v;
var identity = (v) => v();
var noop2 = () => {
};
var callAll = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn?.(...a);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
function match(key, record, ...args) {
  if (key in record) {
    const fn = record[key];
    return isFunction(fn) ? fn(...args) : fn;
  }
  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);
  Error.captureStackTrace?.(error, match);
  throw error;
}
function throttle(fn, wait = 0) {
  let lastCall = 0;
  let timeout = null;
  return ((...args) => {
    const now = Date.now();
    const timeSinceLastCall = now - lastCall;
    if (timeSinceLastCall >= wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      fn(...args);
      lastCall = now;
    } else if (!timeout) {
      timeout = setTimeout(() => {
        fn(...args);
        lastCall = Date.now();
        timeout = null;
      }, wait - timeSinceLastCall);
    }
  });
}
var toChar = (code) => String.fromCharCode(code + (code > 25 ? 39 : 97));
function toName(code) {
  let name = "";
  let x2;
  for (x2 = Math.abs(code); x2 > 52; x2 = x2 / 52 | 0) name = toChar(x2 % 52) + name;
  return toChar(x2 % 52) + name;
}
function toPhash(h, x2) {
  let i = x2.length;
  while (i) h = h * 33 ^ x2.charCodeAt(--i);
  return h;
}
var hash = (value) => toName(toPhash(5381, value) >>> 0);
var { floor, abs, round, min, max, pow, sign } = Math;
var isNaN2 = (v) => Number.isNaN(v);
var nan = (v) => isNaN2(v) ? 0 : v;
var getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];
var getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];
var isValueWithinRange = (v, vmin, vmax) => {
  const value = nan(v);
  const minCheck = vmin == null || value >= vmin;
  const maxCheck = vmax == null || value <= vmax;
  return minCheck && maxCheck;
};
var roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;
var clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);
var getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);
var getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);
var roundToStepPrecision = (v, step) => {
  let rv = v;
  let ss = step.toString();
  let pi = ss.indexOf(".");
  let p = pi >= 0 ? ss.length - pi : 0;
  if (p > 0) {
    let pw = pow(10, p);
    rv = round(rv * pw) / pw;
  }
  return rv;
};
var snapValueToStep = (v, vmin, vmax, step) => {
  const min23 = vmin != null ? Number(vmin) : 0;
  const max22 = Number(vmax);
  const remainder = (v - min23) % step;
  let snapped = abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder;
  snapped = roundToStepPrecision(snapped, step);
  if (!isNaN2(min23) && snapped < min23) {
    snapped = min23;
  } else if (!isNaN2(max22) && snapped > max22) {
    const stepsInRange = floor((max22 - min23) / step);
    const largestValidStep = min23 + stepsInRange * step;
    snapped = stepsInRange <= 0 || largestValidStep < min23 ? max22 : largestValidStep;
  }
  return roundToStepPrecision(snapped, step);
};
var setValueAtIndex = (vs, i, v) => {
  if (vs[i] === v) return vs;
  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];
};
function getValueSetterAtIndex(index, ctx) {
  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
  let nextValues = ctx.values.slice();
  return function setValue(value) {
    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
    nextValues = setValueAtIndex(nextValues, index, value);
    nextValues[index] = nextValue;
    return nextValues;
  };
}
function getNextStepValue(index, ctx) {
  const nextValue = ctx.values[index] + ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
  const nextValue = ctx.values[index] - ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
var getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({
  min: i === 0 ? vmin : vs[i - 1] + gap,
  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,
  value: v
}));
var getValueTransformer = (va, vb) => {
  const [a, b] = va;
  const [c, d] = vb;
  return (v) => a === b || c === d ? c : c + (d - c) / (b - a) * (v - a);
};
var toPx = (v) => typeof v === "number" ? `${v}px` : v;
function compact(obj) {
  if (!isPlainObject(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact(value);
    }
  }
  return filtered;
}
function pick(obj, keys) {
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = value;
    }
  }
  return filtered;
}
function splitProps(props25, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  const ownKeys = Reflect.ownKeys(props25);
  for (const key of ownKeys) {
    if (keySet.has(key)) {
      result[key] = props25[key];
    } else {
      rest[key] = props25[key];
    }
  }
  return [result, rest];
}
var createSplitProps = (keys) => {
  return function split(props25) {
    return splitProps(props25, keys);
  };
};
function createStore(initialState, compare = Object.is) {
  let state3 = { ...initialState };
  const listeners = /* @__PURE__ */ new Set();
  const subscribe2 = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const publish = () => {
    listeners.forEach((listener) => listener());
  };
  const get2 = (key) => {
    return state3[key];
  };
  const set2 = (key, value) => {
    if (!compare(state3[key], value)) {
      state3[key] = value;
      publish();
    }
  };
  const update = (updates) => {
    let hasChanges = false;
    for (const key in updates) {
      const value = updates[key];
      if (value !== void 0 && !compare(state3[key], value)) {
        state3[key] = value;
        hasChanges = true;
      }
    }
    if (hasChanges) {
      publish();
    }
  };
  const snapshot2 = () => ({ ...state3 });
  return {
    subscribe: subscribe2,
    get: get2,
    set: set2,
    update,
    snapshot: snapshot2
  };
}
var currentTime = () => performance.now();
var _tick;
var Timer = class {
  constructor(onTick) {
    this.onTick = onTick;
    __publicField(this, "frameId", null);
    __publicField(this, "pausedAtMs", null);
    __publicField(this, "context");
    __publicField(this, "cancelFrame", () => {
      if (this.frameId === null) return;
      cancelAnimationFrame(this.frameId);
      this.frameId = null;
    });
    __publicField(this, "setStartMs", (startMs) => {
      this.context.startMs = startMs;
    });
    __publicField(this, "start", () => {
      if (this.frameId !== null) return;
      const now = currentTime();
      if (this.pausedAtMs !== null) {
        this.context.startMs += now - this.pausedAtMs;
        this.pausedAtMs = null;
      } else {
        this.context.startMs = now;
      }
      this.frameId = requestAnimationFrame(__privateGet(this, _tick));
    });
    __publicField(this, "pause", () => {
      if (this.frameId === null) return;
      this.cancelFrame();
      this.pausedAtMs = currentTime();
    });
    __publicField(this, "stop", () => {
      if (this.frameId === null) return;
      this.cancelFrame();
      this.pausedAtMs = null;
    });
    __privateAdd(this, _tick, (now) => {
      this.context.now = now;
      this.context.deltaMs = now - this.context.startMs;
      const shouldContinue = this.onTick(this.context);
      if (shouldContinue === false) {
        this.stop();
        return;
      }
      this.frameId = requestAnimationFrame(__privateGet(this, _tick));
    });
    this.context = { now: 0, startMs: currentTime(), deltaMs: 0 };
  }
  get elapsedMs() {
    if (this.pausedAtMs !== null) {
      return this.pausedAtMs - this.context.startMs;
    }
    return currentTime() - this.context.startMs;
  }
};
_tick = /* @__PURE__ */ new WeakMap();
function setRafTimeout(fn, delayMs) {
  const timer = new Timer(({ deltaMs }) => {
    if (deltaMs >= delayMs) {
      fn();
      return false;
    }
  });
  timer.start();
  return () => timer.stop();
}
function warn(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function invariant(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    throw new Error(m);
  }
}
function ensure(c, m) {
  if (c == null) throw new Error(m());
}
function ensureProps(props25, keys, scope) {
  let missingKeys = [];
  for (const key of keys) {
    if (props25[key] == null) missingKeys.push(key);
  }
  if (missingKeys.length > 0)
    throw new Error(`[zag-js${scope ? ` > ${scope}` : ""}] missing required props: ${missingKeys.join(", ")}`);
}

// node_modules/@zag-js/dom-query/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
function isCaretAtStart(input) {
  if (!input) return false;
  try {
    return input.selectionStart === 0 && input.selectionEnd === 0;
  } catch {
    return input.value === "";
  }
}
function setCaretToEnd(input) {
  if (!input) return;
  const start = input.selectionStart ?? 0;
  const end = input.selectionEnd ?? 0;
  if (Math.abs(end - start) !== 0) return;
  if (start !== 0) return;
  input.setSelectionRange(input.value.length, input.value.length);
}
var clamp = (value) => Math.max(0, Math.min(1, value));
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop3 = () => void 0;
var isObject2 = (v) => typeof v === "object" && v !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement = (el) => isObject2(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el) => isObject2(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el) => isObject2(el) && el === el.window;
var getNodeName = (node) => {
  if (isHTMLElement(node)) return node.localName || "";
  return "#document";
};
function isRootElement(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var isNode = (el) => isObject2(el) && el.nodeType !== void 0;
var isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
var isInputElement = (el) => isHTMLElement(el) && el.localName === "input";
var isAnchorElement = (el) => !!el?.matches("a[href]");
var isElementVisible = (el) => {
  if (!isHTMLElement(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
};
function isActiveElement(element2) {
  if (!element2) return false;
  const rootNode = element2.getRootNode();
  return getActiveElement(rootNode) === element2;
}
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el) {
  if (el == null || !isHTMLElement(el)) return false;
  try {
    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute("contenteditable") === "true" || el.getAttribute("contenteditable") === "";
  } catch {
    return false;
  }
}
function contains(parent, child2) {
  if (!parent || !child2) return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child2)) return false;
  const rootNode = child2.getRootNode?.();
  if (parent === child2) return true;
  if (parent.contains(child2)) return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next3 = child2;
    while (next3) {
      if (parent === next3) return true;
      next3 = next3.parentNode || next3.host;
    }
  }
  return false;
}
function getDocument(el) {
  if (isDocument(el)) return el;
  if (isWindow(el)) return el.document;
  return el?.ownerDocument ?? document;
}
function getDocumentElement(el) {
  return getDocument(el).documentElement;
}
function getWindow(el) {
  if (isShadowRoot(el)) return getWindow(el.host);
  if (isDocument(el)) return el.defaultView ?? window;
  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement?.shadowRoot) {
    const el = activeElement.shadowRoot.activeElement;
    if (!el || el === activeElement) break;
    else activeElement = el;
  }
  return activeElement;
}
function getParentNode(node) {
  if (getNodeName(node) === "html") return node;
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getRootNode(node) {
  let result;
  try {
    result = node.getRootNode({ composed: true });
    if (isDocument(result) || isShadowRoot(result)) return result;
  } catch {
  }
  return node.ownerDocument ?? document;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle2(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}
var INTERACTIVE_CONTAINER_ROLE = /* @__PURE__ */ new Set(["menu", "listbox", "dialog", "grid", "tree", "region"]);
var isInteractiveContainerRole = (role) => INTERACTIVE_CONTAINER_ROLE.has(role);
var getAriaControls = (element2) => element2.getAttribute("aria-controls")?.split(" ") || [];
function isControlledElement(container, element2) {
  const visitedIds = /* @__PURE__ */ new Set();
  const rootNode = getRootNode(container);
  const checkElement = (searchRoot) => {
    const controllingElements = searchRoot.querySelectorAll("[aria-controls]");
    for (const controller of controllingElements) {
      if (controller.getAttribute("aria-expanded") !== "true") continue;
      const controlledIds = getAriaControls(controller);
      for (const id of controlledIds) {
        if (!id || visitedIds.has(id)) continue;
        visitedIds.add(id);
        const controlledElement = rootNode.getElementById(id);
        if (controlledElement) {
          const role = controlledElement.getAttribute("role");
          const modal = controlledElement.getAttribute("aria-modal") === "true";
          if (role && isInteractiveContainerRole(role) && !modal) {
            if (controlledElement === element2 || controlledElement.contains(element2)) {
              return true;
            }
            if (checkElement(controlledElement)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  };
  return checkElement(container);
}
function findControlledElements(searchRoot, callback) {
  const rootNode = getRootNode(searchRoot);
  const visitedIds = /* @__PURE__ */ new Set();
  const findRecursive = (root10) => {
    const controllingElements = root10.querySelectorAll("[aria-controls]");
    for (const controller of controllingElements) {
      if (controller.getAttribute("aria-expanded") !== "true") continue;
      const controlledIds = getAriaControls(controller);
      for (const id of controlledIds) {
        if (!id || visitedIds.has(id)) continue;
        visitedIds.add(id);
        const controlledElement = rootNode.getElementById(id);
        if (controlledElement) {
          const role = controlledElement.getAttribute("role");
          const modal = controlledElement.getAttribute("aria-modal") === "true";
          if (role && INTERACTIVE_CONTAINER_ROLE.has(role) && !modal) {
            callback(controlledElement);
            findRecursive(controlledElement);
          }
        }
      }
    }
  };
  findRecursive(searchRoot);
}
function getControlledElements(container) {
  const controlledElements = /* @__PURE__ */ new Set();
  findControlledElements(container, (controlledElement) => {
    if (!container.contains(controlledElement)) {
      controlledElements.add(controlledElement);
    }
  });
  return Array.from(controlledElements);
}
function isInteractiveContainerElement(element2) {
  const role = element2.getAttribute("role");
  return Boolean(role && INTERACTIVE_CONTAINER_ROLE.has(role));
}
function isControllerElement(element2) {
  return element2.hasAttribute("aria-controls") && element2.getAttribute("aria-expanded") === "true";
}
function hasControllerElements(element2) {
  if (isControllerElement(element2)) return true;
  return Boolean(element2.querySelector?.('[aria-controls][aria-expanded="true"]'));
}
function isControlledByExpandedController(element2) {
  if (!element2.id) return false;
  const rootNode = getRootNode(element2);
  const escapedId = CSS.escape(element2.id);
  const selector = `[aria-controls~="${escapedId}"][aria-expanded="true"], [aria-controls="${escapedId}"][aria-expanded="true"]`;
  const controller = rootNode.querySelector(selector);
  return Boolean(controller && isInteractiveContainerElement(element2));
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
function getUserAgent() {
  const ua2 = navigator.userAgentData;
  if (ua2 && Array.isArray(ua2.brands)) {
    return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(" ");
  }
  return navigator.userAgent;
}
var pt = (v) => isDom() && v.test(getPlatform());
var ua = (v) => isDom() && v.test(getUserAgent());
var vn = (v) => isDom() && v.test(navigator.vendor);
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isIPhone = () => pt(/^iPhone/i);
var isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;
var isIos = () => isIPhone() || isIPad();
var isApple = () => isMac() || isIos();
var isMac = () => pt(/^Mac/i);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/Firefox/i);
var isAndroid = () => ua(/Android/i);
function getComposedPath(event) {
  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return composedPath?.[0] ?? event.target;
}
function isOpeningInNewTab(event) {
  const element2 = event.currentTarget;
  if (!element2) return false;
  const validElement = element2.matches("a[href], button[type='submit'], input[type='submit']");
  if (!validElement) return false;
  const isMiddleClick = event.button === 1;
  const isModKeyClick = isCtrlOrMetaKey(event);
  return isMiddleClick || isModKeyClick;
}
function isDownloadingEvent(event) {
  const element2 = event.currentTarget;
  if (!element2) return false;
  const localName = element2.localName;
  if (!event.altKey) return false;
  if (localName === "a") return true;
  if (localName === "button" && element2.type === "submit") return true;
  if (localName === "input" && element2.type === "submit") return true;
  return false;
}
function isComposingEvent(event) {
  return getNativeEvent(event).isComposing || event.keyCode === 229;
}
function isCtrlOrMetaKey(e) {
  if (isMac()) return e.metaKey;
  return e.ctrlKey;
}
function isPrintableKey(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
function isVirtualClick(e) {
  if (e.pointerType === "" && e.isTrusted) return true;
  if (isAndroid() && e.pointerType) {
    return e.type === "click" && e.buttons === 1;
  }
  return e.detail === 0 && !e.pointerType;
}
var isLeftClick = (e) => e.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
var pageKeys = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var arrowKeys = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = pageKeys.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getEventPoint(event, type = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var addDomEvent = (target, eventName, handler, options) => {
  const node = typeof target === "function" ? target() : target;
  node?.addEventListener(eventName, handler, options);
  return () => {
    node?.removeEventListener(eventName, handler, options);
  };
};
function getDescriptor(el, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function getElementType(el) {
  if (el.localName === "input") return "HTMLInputElement";
  if (el.localName === "textarea") return "HTMLTextAreaElement";
  if (el.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el, value, property = "value") {
  if (!el) return;
  const type = getElementType(el);
  if (type) {
    const descriptor = getDescriptor(el, { type, property });
    descriptor.set?.call(el, value);
  }
  el.setAttribute(property, value);
}
function setElementChecked(el, checked) {
  if (!el) return;
  const descriptor = getDescriptor(el, { type: "HTMLInputElement", property: "checked" });
  descriptor.set?.call(el, checked);
  if (checked) el.setAttribute("checked", "");
  else el.removeAttribute("checked");
}
function dispatchInputValueEvent(el, options) {
  const { value, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementValue(el, `${value}`);
  el.dispatchEvent(new win.Event("input", { bubbles }));
}
function dispatchInputCheckedEvent(el, options) {
  const { checked, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementChecked(el, checked);
  el.dispatchEvent(new win.Event("click", { bubbles }));
}
function getClosestForm(el) {
  return isFormElement(el) ? el.form : el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el) return;
  const form = getClosestForm(el);
  const onReset = (e) => {
    if (e.defaultPrevented) return;
    callback();
  };
  form?.addEventListener("reset", onReset, { passive: true });
  return () => form?.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el?.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = getWindow(fieldset);
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el, options) {
  if (!el) return;
  const { onFieldsetDisabledChange, onFormReset } = options;
  const cleanups = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
  return () => cleanups.forEach((cleanup) => cleanup?.());
}
var isFrame = (el) => isHTMLElement(el) && el.tagName === "IFRAME";
var NATURALLY_TABBABLE_REGEX = /^(audio|video|details)$/;
function parseTabIndex(el) {
  const attr = el.getAttribute("tabindex");
  if (!attr) return NaN;
  return parseInt(attr, 10);
}
var hasTabIndex = (el) => !Number.isNaN(parseTabIndex(el));
var hasNegativeTabIndex = (el) => parseTabIndex(el) < 0;
function getShadowRootForNode(element2, getShadowRoot) {
  if (!getShadowRoot) return null;
  if (getShadowRoot === true) {
    return element2.shadowRoot || null;
  }
  const result = getShadowRoot(element2);
  return (result === true ? element2.shadowRoot : result) || null;
}
function collectElementsWithShadowDOM(elements, getShadowRoot, filterFn) {
  const allElements = [...elements];
  const toProcess = [...elements];
  const processed = /* @__PURE__ */ new Set();
  const positionMap = /* @__PURE__ */ new Map();
  elements.forEach((el, i) => positionMap.set(el, i));
  let processIndex = 0;
  while (processIndex < toProcess.length) {
    const element2 = toProcess[processIndex++];
    if (!element2 || processed.has(element2)) continue;
    processed.add(element2);
    const shadowRoot = getShadowRootForNode(element2, getShadowRoot);
    if (shadowRoot) {
      const shadowElements = Array.from(shadowRoot.querySelectorAll(focusableSelector)).filter(filterFn);
      const hostIndex = positionMap.get(element2);
      if (hostIndex !== void 0) {
        const insertPosition = hostIndex + 1;
        allElements.splice(insertPosition, 0, ...shadowElements);
        shadowElements.forEach((el, i) => {
          positionMap.set(el, insertPosition + i);
        });
        for (let i = insertPosition + shadowElements.length; i < allElements.length; i++) {
          positionMap.set(allElements[i], i);
        }
      } else {
        const insertPosition = allElements.length;
        allElements.push(...shadowElements);
        shadowElements.forEach((el, i) => {
          positionMap.set(el, insertPosition + i);
        });
      }
      toProcess.push(...shadowElements);
    }
  }
  return allElements;
}
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, options = {}) => {
  if (!container) return [];
  const { includeContainer = false, getShadowRoot } = options;
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = [];
  for (const element2 of elements) {
    if (!isFocusable(element2)) continue;
    if (isFrame(element2) && element2.contentDocument) {
      const frameBody = element2.contentDocument.body;
      focusableElements.push(...getFocusables(frameBody, { getShadowRoot }));
      continue;
    }
    focusableElements.push(element2);
  }
  if (getShadowRoot) {
    return collectElementsWithShadowDOM(focusableElements, getShadowRoot, isFocusable);
  }
  return focusableElements;
};
function isFocusable(element2) {
  if (!isHTMLElement(element2) || element2.closest("[inert]")) return false;
  return element2.matches(focusableSelector) && isElementVisible(element2);
}
function getTabbables(container, options = {}) {
  if (!container) return [];
  const { includeContainer, getShadowRoot } = options;
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  if (includeContainer && isTabbable(container)) {
    elements.unshift(container);
  }
  const tabbableElements = [];
  for (const element2 of elements) {
    if (!isTabbable(element2)) continue;
    if (isFrame(element2) && element2.contentDocument) {
      const frameBody = element2.contentDocument.body;
      tabbableElements.push(...getTabbables(frameBody, { getShadowRoot }));
      continue;
    }
    tabbableElements.push(element2);
  }
  if (getShadowRoot) {
    const allElements = collectElementsWithShadowDOM(tabbableElements, getShadowRoot, isTabbable);
    if (!allElements.length && includeContainer) {
      return elements;
    }
    return allElements;
  }
  if (!tabbableElements.length && includeContainer) {
    return elements;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (isHTMLElement(el) && el.tabIndex > 0) return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getTabbableEdges(container, options = {}) {
  const elements = getTabbables(container, options);
  const first2 = elements[0] || null;
  const last2 = elements[elements.length - 1] || null;
  return [first2, last2];
}
function getNextTabbable(container, options = {}) {
  const { current, getShadowRoot } = options;
  const tabbables = getTabbables(container, { getShadowRoot });
  const doc = container?.ownerDocument || document;
  const currentElement = current ?? getActiveElement(doc);
  if (!currentElement) return null;
  const index = tabbables.indexOf(currentElement);
  return tabbables[index + 1] || null;
}
function getTabIndex(node) {
  if (node.tabIndex < 0) {
    if ((NATURALLY_TABBABLE_REGEX.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
}
function getInitialFocus(options) {
  const { root: root10, getInitialEl, filter: filter2, enabled = true } = options;
  if (!enabled) return;
  let node = null;
  node || (node = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node || (node = root10?.querySelector("[data-autofocus],[autofocus]"));
  if (!node) {
    const tabbables = getTabbables(root10);
    node = filter2 ? tabbables.filter(filter2)[0] : tabbables[0];
  }
  return node || root10 || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  if (isActiveElement(firstTabbable) && event.shiftKey) return false;
  if (isActiveElement(lastTabbable) && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}
var AnimationFrame = class _AnimationFrame {
  constructor() {
    __publicField2(this, "id", null);
    __publicField2(this, "fn_cleanup");
    __publicField2(this, "cleanup", () => {
      this.cancel();
    });
  }
  static create() {
    return new _AnimationFrame();
  }
  request(fn) {
    this.cancel();
    this.id = globalThis.requestAnimationFrame(() => {
      this.id = null;
      this.fn_cleanup = fn?.();
    });
  }
  cancel() {
    if (this.id !== null) {
      globalThis.cancelAnimationFrame(this.id);
      this.id = null;
    }
    this.fn_cleanup?.();
    this.fn_cleanup = void 0;
  }
  isActive() {
    return this.id !== null;
  }
};
function raf(fn) {
  const frame = AnimationFrame.create();
  frame.request(fn);
  return frame.cleanup;
}
function nextTick(fn) {
  const set2 = /* @__PURE__ */ new Set();
  function raf22(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set2.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf22(() => raf22(fn));
  return function cleanup() {
    set2.forEach((fn2) => fn2());
  };
}
function queueBeforeEvent(el, type, cb) {
  const cancelTimer = raf(() => {
    el.removeEventListener(type, exec, true);
    cb();
  });
  const exec = () => {
    cancelTimer();
    cb();
  };
  el.addEventListener(type, exec, { once: true, capture: true });
  return cancelTimer;
}
function observeAttributesImpl(node, options) {
  if (!node) return;
  const { attributes, callback: fn } = options;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(observeAttributesImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function observeChildrenImpl(node, options) {
  const { callback: fn } = options;
  if (!node) return;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node, { childList: true, subtree: true });
  return () => obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(observeChildrenImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function clickIfLink(el) {
  const click = () => {
    const win = getWindow(el);
    el.dispatchEvent(new win.MouseEvent("click"));
  };
  if (isFirefox()) {
    queueBeforeEvent(el, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function getNearestOverflowAncestor(el) {
  const parentNode = getParentNode(el);
  if (isRootElement(parentNode)) return getDocument(parentNode).body;
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor(el);
  const isBody = scrollableAncestor === el.ownerDocument.body;
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
var nonOverflowValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(el) {
  const win = getWindow(el);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !nonOverflowValues.has(display);
}
function isScrollable(el) {
  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
  const { rootEl, ...scrollOptions } = options || {};
  if (!el || !rootEl) return;
  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;
  el.scrollIntoView(scrollOptions);
}
function getRelativePoint(point, element2) {
  const { left, top, width, height } = element2.getBoundingClientRect();
  const offset2 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp(offset2.x / width), y: clamp(offset2.y / height) };
  function getPercentValue2(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset2, percent, getPercentValue: getPercentValue2 };
}
var state2 = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state2 === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state2 = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state2 !== "disabled") return;
    state2 = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state2 === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state2 = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof target === "function" ? target() : target;
      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const point = getEventPoint(event);
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer) return;
    if (event.pointerType === "mouse" && event.buttons === 0) {
      handleUp(event);
      return;
    }
    onPointerMove({ point, event });
  };
  const handleUp = (event) => {
    const point = getEventPoint(event);
    onPointerUp({ point, event });
  };
  const cleanups = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", handleUp, false),
    addDomEvent(doc, "pointercancel", handleUp, false),
    addDomEvent(doc, "contextmenu", handleUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups.forEach((cleanup) => cleanup());
  };
}
function trackPress(options) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey: isValidKey2 = (e) => e.key === "Enter"
  } = options;
  if (!pointerNode) return noop3;
  const win = getWindow(pointerNode);
  let removeStartListeners = noop3;
  let removeEndListeners = noop3;
  let removeAccessibleListeners = noop3;
  const getInfo = (event) => ({
    point: getEventPoint(event),
    event
  });
  function startPress(event) {
    onPressStart?.(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd?.(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress?.(getInfo(endEvent));
      } else {
        onPressEnd?.(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, { passive: !onPress, once: true });
    const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, {
      passive: !onPressEnd,
      once: true
    });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (isActiveElement(keyboardNode) && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey2(keydownEvent)) return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey2(keyupEvent)) return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress?.(info);
        onPressEnd?.(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return () => {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}
function proxyTabFocusImpl(container, options = {}) {
  const { triggerElement, onFocus, onFocusEnter, getShadowRoot } = options;
  const doc = container?.ownerDocument || document;
  const body = doc.body;
  function onKeyDown(event) {
    if (event.key !== "Tab") return;
    let elementToFocus = null;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container, { includeContainer: true, getShadowRoot });
    const nextTabbableAfterTrigger = getNextTabbable(body, { current: triggerElement, getShadowRoot });
    const noTabbableElements = !firstTabbable && !lastTabbable;
    if (event.shiftKey && isActiveElement(nextTabbableAfterTrigger)) {
      onFocusEnter?.();
      elementToFocus = lastTabbable;
    } else if (event.shiftKey && (isActiveElement(firstTabbable) || noTabbableElements)) {
      elementToFocus = triggerElement;
    } else if (!event.shiftKey && isActiveElement(triggerElement)) {
      onFocusEnter?.();
      elementToFocus = firstTabbable;
    } else if (!event.shiftKey && (isActiveElement(lastTabbable) || noTabbableElements)) {
      elementToFocus = nextTabbableAfterTrigger;
    }
    if (!elementToFocus) return;
    event.preventDefault();
    if (typeof onFocus === "function") {
      onFocus(elementToFocus);
    } else {
      elementToFocus.focus();
    }
  }
  return addDomEvent(doc, "keydown", onKeyDown, true);
}
function proxyTabFocus(container, options) {
  const { defer, triggerElement, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof container === "function" ? container() : container;
      const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function queryAll(root10, selector) {
  return Array.from(root10?.querySelectorAll(selector) ?? []);
}
function query(root10, selector) {
  return root10?.querySelector(selector) ?? null;
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
function createSharedResizeObserver(options) {
  const listeners = /* @__PURE__ */ new WeakMap();
  let observer;
  const entries = /* @__PURE__ */ new WeakMap();
  const getObserver = (win) => {
    if (observer) return observer;
    observer = new win.ResizeObserver((observedEntries) => {
      for (const entry of observedEntries) {
        entries.set(entry.target, entry);
        const elementListeners = listeners.get(entry.target);
        if (elementListeners) {
          for (const listener of elementListeners) {
            listener(entry);
          }
        }
      }
    });
    return observer;
  };
  const observe = (element2, listener) => {
    let elementListeners = listeners.get(element2) || /* @__PURE__ */ new Set();
    elementListeners.add(listener);
    listeners.set(element2, elementListeners);
    const win = getWindow(element2);
    getObserver(win).observe(element2, options);
    return () => {
      const elementListeners2 = listeners.get(element2);
      if (!elementListeners2) return;
      elementListeners2.delete(listener);
      if (elementListeners2.size === 0) {
        listeners.delete(element2);
        getObserver(win).unobserve(element2);
      }
    };
  };
  const unobserve = (element2) => {
    listeners.delete(element2);
    observer?.unobserve(element2);
  };
  return {
    observe,
    unobserve
  };
}
var resizeObserverContentBox = createSharedResizeObserver({
  box: "content-box"
});
var resizeObserverBorderBox = createSharedResizeObserver({
  box: "border-box"
});
var resizeObserverDevicePixelContentBox = createSharedResizeObserver({
  box: "device-pixel-content-box"
});
var sanitize = (str) => str.split("").map((char) => {
  const code = char.charCodeAt(0);
  if (code > 0 && code < 128) return char;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el) => {
  return sanitize(el.dataset?.valuetext ?? el.textContent ?? "");
};
var match2 = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v, text2, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text2.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match2(getValueText(item), text2));
}
function setAttribute(el, attr, v) {
  const prev2 = el.getAttribute(attr);
  const exists = prev2 != null;
  el.setAttribute(attr, v);
  return () => {
    if (!exists) {
      el.removeAttribute(attr);
    } else {
      el.setAttribute(attr, prev2);
    }
  };
}
function setStyle(el, style) {
  if (!el) return noop3;
  const prev2 = Object.keys(style).reduce((acc, key) => {
    acc[key] = el.style.getPropertyValue(key);
    return acc;
  }, {});
  Object.assign(el.style, style);
  return () => {
    Object.assign(el.style, prev2);
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  };
}
function setStyleProperty(el, prop, value) {
  if (!el) return noop3;
  const prev2 = el.style.getPropertyValue(prop);
  el.style.setProperty(prop, value);
  return () => {
    el.style.setProperty(prop, prev2);
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  };
}
function getByTypeaheadImpl(baseItems, options) {
  const { state: state22, activeId, key, timeout = 350, itemToId } = options;
  const search = state22.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next3 = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state22.timer);
    state22.timer = -1;
  }
  function update(value) {
    state22.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state22.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead = Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
function waitForPromise(promise, controller, timeout) {
  const { signal } = controller;
  const wrappedPromise = new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      reject(new Error(`Timeout of ${timeout}ms exceeded`));
    }, timeout);
    signal.addEventListener("abort", () => {
      clearTimeout(timeoutId);
      reject(new Error("Promise aborted"));
    });
    promise.then((result) => {
      if (!signal.aborted) {
        clearTimeout(timeoutId);
        resolve(result);
      }
    }).catch((error) => {
      if (!signal.aborted) {
        clearTimeout(timeoutId);
        reject(error);
      }
    });
  });
  const abort = () => controller.abort();
  return [wrappedPromise, abort];
}
function waitForElement(target, options) {
  const { timeout, rootNode } = options;
  const win = getWindow(rootNode);
  const doc = getDocument(rootNode);
  const controller = new win.AbortController();
  return waitForPromise(
    new Promise((resolve) => {
      const el = target();
      if (el) {
        resolve(el);
        return;
      }
      const observer = new win.MutationObserver(() => {
        const el2 = target();
        if (el2 && el2.isConnected) {
          observer.disconnect();
          resolve(el2);
        }
      });
      observer.observe(doc.body, {
        childList: true,
        subtree: true
      });
    }),
    controller,
    timeout
  );
}

// node_modules/@zag-js/core/dist/index.mjs
var clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style) => {
  const res = {};
  let match4;
  while (match4 = CSS_REGEX.exec(style)) {
    res[match4[1]] = match4[2];
  }
  return res;
};
var css = (a, b) => {
  if (isString(a)) {
    if (isString(b)) return `${a};${b}`;
    a = serialize(a);
  } else if (isString(b)) {
    b = serialize(b);
  }
  return Object.assign({}, a ?? {}, b ?? {});
};
function mergeProps(...args) {
  let result = {};
  for (let props25 of args) {
    if (!props25) continue;
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props25[key] === "function") {
        result[key] = callAll(props25[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props25[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props25[key]);
        continue;
      }
      result[key] = props25[key] !== void 0 ? props25[key] : result[key];
    }
    for (let key in props25) {
      if (result[key] === void 0) {
        result[key] = props25[key];
      }
    }
    const symbols = Object.getOwnPropertySymbols(props25);
    for (let symbol of symbols) {
      result[symbol] = props25[symbol];
    }
  }
  return result;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => !isEqual(deps[index], dep));
    if (!depsChanged) return result;
    deps = newDeps;
    result = fn(newDeps, depArgs);
    opts?.onChange?.(result);
    return result;
  };
}
function createGuards() {
  return {
    and: (...guards4) => {
      return function andGuard(params) {
        return guards4.every((str) => params.guard(str));
      };
    },
    or: (...guards4) => {
      return function orGuard(params) {
        return guards4.some((str) => params.guard(str));
      };
    },
    not: (guard) => {
      return function notGuard(params) {
        return !params.guard(guard);
      };
    }
  };
}
function createMachine(config) {
  return config;
}
function setup() {
  return {
    guards: createGuards(),
    createMachine: (config) => {
      return createMachine(config);
    },
    choose: (transitions) => {
      return function chooseFn({ choose: choose2 }) {
        return choose2(transitions)?.actions;
      };
    }
  };
}
var MachineStatus = ((MachineStatus2) => {
  MachineStatus2["NotStarted"] = "Not Started";
  MachineStatus2["Started"] = "Started";
  MachineStatus2["Stopped"] = "Stopped";
  return MachineStatus2;
})(MachineStatus || {});
var INIT_STATE = "__init__";
function createScope(props25) {
  const getRootNode2 = () => props25.getRootNode?.() ?? document;
  const getDoc = () => getDocument(getRootNode2());
  const getWin = () => getDoc().defaultView ?? window;
  const getActiveElementFn = () => getActiveElement(getRootNode2());
  const getById = (id) => getRootNode2().getElementById(id);
  return {
    ...props25,
    getRootNode: getRootNode2,
    getDoc,
    getWin,
    getActiveElement: getActiveElementFn,
    isActiveElement,
    getById
  };
}

// node_modules/@zag-js/types/dist/index.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get(_target, key) {
      if (key === "style")
        return (props25) => {
          return fn({ style: props25 }).style;
        };
      return fn;
    }
  });
}
var createProps = () => (props25) => Array.from(new Set(props25));

// node_modules/@zag-js/svelte/dist/normalize-props.js
var propMap = {
  className: "class",
  defaultChecked: "checked",
  defaultValue: "value",
  htmlFor: "for",
  onBlur: "onfocusout",
  onChange: "oninput",
  onFocus: "onfocusin",
  onDoubleClick: "ondblclick"
};
function toStyleString(style) {
  let string = "";
  for (let key in style) {
    const value = style[key];
    if (value === null || value === void 0)
      continue;
    if (!key.startsWith("--"))
      key = key.replace(/[A-Z]/g, (match4) => `-${match4.toLowerCase()}`);
    string += `${key}:${value};`;
  }
  return string;
}
var preserveKeys = new Set("viewBox,className,preserveAspectRatio,fillRule,clipPath,clipRule,strokeWidth,strokeLinecap,strokeLinejoin,strokeDasharray,strokeDashoffset,strokeMiterlimit".split(","));
function toSvelteProp(key) {
  if (key in propMap)
    return propMap[key];
  if (preserveKeys.has(key))
    return key;
  return key.toLowerCase();
}
function toSveltePropValue(key, value) {
  if (key === "style" && typeof value === "object")
    return toStyleString(value);
  return value;
}
var normalizeProps = createNormalizer((props25) => {
  const normalized = {};
  for (const key in props25) {
    normalized[toSvelteProp(key)] = toSveltePropValue(key, props25[key]);
  }
  return normalized;
});

// node_modules/@zag-js/svelte/dist/merge-props.js
var CSS_REGEX2 = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize2 = (style) => {
  const res = {};
  let match4;
  while (match4 = CSS_REGEX2.exec(style)) {
    res[match4[1]] = match4[2];
  }
  return res;
};
function mergeProps2(...args) {
  const classNames = [];
  for (const props25 of args) {
    if (!props25)
      continue;
    if ("class" in props25 && props25.class != null) {
      classNames.push(props25.class);
    }
  }
  const merged = mergeProps(...args);
  if (classNames.length > 0) {
    merged.class = classNames.length === 1 ? classNames[0] : classNames;
  }
  if ("style" in merged) {
    if (typeof merged.style === "string") {
      merged.style = serialize2(merged.style);
    }
    merged.style = toStyleString(merged.style);
  }
  return merged;
}

// node_modules/@zag-js/svelte/dist/portal.js
function portal(node, props25 = {}) {
  function update(props26 = {}) {
    const { container, disabled, getRootNode: getRootNode2 } = props26;
    if (disabled)
      return;
    const doc = getRootNode2?.().ownerDocument ?? document;
    const mountNode = container ?? doc.body;
    mountNode.appendChild(node);
  }
  update(props25);
  return {
    destroy: () => node.remove(),
    update
  };
}

// node_modules/@zag-js/svelte/dist/bindable.svelte.js
function bindable(props25) {
  const initial = props25().defaultValue ?? props25().value;
  const eq = props25().isEqual ?? Object.is;
  let value = tag(state(proxy(initial)), "value");
  const controlled = tag(user_derived(() => strict_equals(props25().value, void 0, false)), "controlled");
  let valueRef = { current: untrack(() => get(value)) };
  let prevValue = { current: void 0 };
  user_pre_effect(() => {
    const v = get(controlled) ? props25().value : get(value);
    valueRef = { current: v };
    prevValue = { current: v };
  });
  const setValueFn = (v) => {
    const next3 = isFunction(v) ? v(valueRef.current) : v;
    const prev2 = prevValue.current;
    if (props25().debug) {
      console.log(...log_if_contains_state("log", `[bindable > ${props25().debug}] setValue`, { next: next3, prev: prev2 }));
    }
    if (!get(controlled)) set(value, next3, true);
    if (!eq(next3, prev2)) {
      props25().onChange?.(next3, prev2);
    }
  };
  function get2() {
    return get(controlled) ? props25().value : get(value);
  }
  return {
    initial,
    ref: valueRef,
    get: get2,
    set(val) {
      const exec = props25().sync ? flushSync : identity;
      exec(() => setValueFn(val));
    },
    invoke(nextValue, prevValue2) {
      props25().onChange?.(nextValue, prevValue2);
    },
    hash(value2) {
      return props25().hash?.(value2) ?? String(value2);
    }
  };
}
bindable.cleanup = (fn) => {
  onDestroy(() => fn());
};
bindable.ref = (defaultValue) => {
  let value = defaultValue;
  return {
    get: () => value,
    set: (next3) => {
      value = next3;
    }
  };
};

// node_modules/@zag-js/svelte/dist/refs.svelte.js
function useRefs(refs) {
  const ref = { current: refs };
  return {
    get(key) {
      return ref.current[key];
    },
    set(key, value) {
      ref.current[key] = value;
    }
  };
}

// node_modules/@zag-js/svelte/dist/track.svelte.js
var access = (value) => {
  if (strict_equals(typeof value, "function")) return value();
  return value;
};
var track = (deps, effect) => {
  let prevDeps = [];
  let isFirstRun = true;
  user_effect(() => {
    if (isFirstRun) {
      prevDeps = deps.map((d) => access(d));
      isFirstRun = false;
      return;
    }
    let changed = false;
    for (let i = 0; i < deps.length; i++) {
      if (!isEqual(prevDeps[i], access(deps[i]))) {
        changed = true;
        break;
      }
    }
    if (changed) {
      prevDeps = deps.map((d) => access(d));
      effect();
    }
  });
};

// node_modules/@zag-js/svelte/dist/machine.svelte.js
function access2(userProps) {
  if (isFunction(userProps)) return userProps();
  return userProps;
}
function useMachine(machine26, userProps) {
  const scope = tag(
    user_derived(() => {
      const { id, ids, getRootNode: getRootNode2 } = access2(userProps);
      return createScope({ id, ids, getRootNode: getRootNode2 });
    }),
    "scope"
  );
  const debug = (...args) => {
    if (machine26.debug) console.log(...log_if_contains_state("log", ...args));
  };
  const props25 = tag(user_derived(() => machine26.props?.({ props: compact(access2(userProps)), scope: get(scope) }) ?? access2(userProps)), "props");
  const prop = useProp(() => get(props25));
  const context = machine26.context?.({
    prop,
    bindable,
    get scope() {
      return get(scope);
    },
    flush,
    getContext() {
      return ctx;
    },
    getComputed() {
      return computed;
    },
    getRefs() {
      return refs;
    },
    getEvent() {
      return getEvent();
    }
  });
  const ctx = {
    get(key) {
      return context?.[key].get();
    },
    set(key, value) {
      context?.[key].set(value);
    },
    initial(key) {
      return context?.[key].initial;
    },
    hash(key) {
      const current = context?.[key].get();
      return context?.[key].hash(current);
    }
  };
  let effects = /* @__PURE__ */ new Map();
  let transitionRef = { current: null };
  let previousEventRef = { current: null };
  let eventRef = { current: { type: "" } };
  const getEvent = () => ({
    ...eventRef.current,
    current() {
      return eventRef.current;
    },
    previous() {
      return previousEventRef.current;
    }
  });
  const getState = () => ({
    ...state3,
    hasTag(tag2) {
      const currentState = state3.get();
      return !!machine26.states[currentState]?.tags?.includes(tag2);
    },
    matches(...values) {
      const currentState = state3.get();
      return values.includes(currentState);
    }
  });
  const refs = useRefs(machine26.refs?.({ prop, context: ctx }) ?? {});
  const getParams = () => ({
    state: getState(),
    context: ctx,
    event: getEvent(),
    prop,
    send,
    action,
    guard,
    track,
    refs,
    computed,
    flush,
    scope: get(scope),
    choose: choose2
  });
  const action = (keys) => {
    const strs = isFunction(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine26.implementations?.actions?.[s];
      if (!fn) warn(`[zag-js] No implementation found for action "${JSON.stringify(s)}"`);
      return fn;
    });
    for (const fn of fns) {
      fn?.(getParams());
    }
  };
  const guard = (str) => {
    if (isFunction(str)) return str(getParams());
    return machine26.implementations?.guards?.[str](getParams());
  };
  const effect = (keys) => {
    const strs = isFunction(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine26.implementations?.effects?.[s];
      if (!fn) warn(`[zag-js] No implementation found for effect "${JSON.stringify(s)}"`);
      return fn;
    });
    const cleanups = [];
    for (const fn of fns) {
      const cleanup = fn?.(getParams());
      if (cleanup) cleanups.push(cleanup);
    }
    return () => cleanups.forEach((fn) => fn?.());
  };
  const choose2 = (transitions) => {
    return toArray(transitions).find((t) => {
      let result = !t.guard;
      if (isString(t.guard)) result = !!guard(t.guard);
      else if (isFunction(t.guard)) result = t.guard(getParams());
      return result;
    });
  };
  const computed = (key) => {
    ensure(machine26.computed, () => `[zag-js] No computed object found on machine`);
    const fn = machine26.computed[key];
    return fn({
      context: ctx,
      event: getEvent(),
      prop,
      refs,
      scope: get(scope),
      computed
    });
  };
  const state3 = bindable(() => ({
    defaultValue: machine26.initialState({ prop }),
    onChange(nextState, prevState) {
      if (prevState) {
        const exitEffects = effects.get(prevState);
        exitEffects?.();
        effects.delete(prevState);
      }
      if (prevState) {
        action(machine26.states[prevState]?.exit);
      }
      action(transitionRef.current?.actions);
      const cleanup = effect(machine26.states[nextState]?.effects);
      if (cleanup) effects.set(nextState, cleanup);
      if (strict_equals(prevState, INIT_STATE)) {
        action(machine26.entry);
        const cleanup2 = effect(machine26.effects);
        if (cleanup2) effects.set(INIT_STATE, cleanup2);
      }
      action(machine26.states[nextState]?.entry);
    }
  }));
  let status = MachineStatus.NotStarted;
  onMount(() => {
    const started = strict_equals(status, MachineStatus.Started);
    status = MachineStatus.Started;
    debug(started ? "rehydrating..." : "initializing...");
    state3.invoke(state3.initial, INIT_STATE);
  });
  onDestroy(() => {
    debug("unmounting...");
    status = MachineStatus.Stopped;
    effects.forEach((fn) => fn?.());
    effects = /* @__PURE__ */ new Map();
    transitionRef.current = null;
    action(machine26.exit);
  });
  const send = (event) => {
    if (strict_equals(status, MachineStatus.Started, false)) return;
    previousEventRef.current = eventRef.current;
    eventRef.current = event;
    let currentState = state3.get();
    const transitions = machine26.states[currentState].on?.[event.type] ?? machine26.on?.[event.type];
    const transition = choose2(transitions);
    if (!transition) return;
    transitionRef.current = transition;
    const target = transition.target ?? currentState;
    debug("transition", event.type, transition.target || currentState, `(${transition.actions})`);
    const changed = strict_equals(target, currentState, false);
    if (changed) {
      state3.set(target);
    } else if (transition.reenter && !changed) {
      state3.invoke(currentState, currentState);
    } else {
      action(transition.actions);
    }
  };
  machine26.watch?.(getParams());
  return {
    get state() {
      return getState();
    },
    send,
    context: ctx,
    prop,
    get scope() {
      return get(scope);
    },
    refs,
    computed,
    get event() {
      return getEvent();
    },
    getStatus: () => status
  };
}
function useProp(value) {
  return function get2(key) {
    return value()[key];
  };
}
function flush(fn) {
  flushSync(() => {
    queueMicrotask(() => fn());
  });
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/item-content.svelte
Item_content[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/item-content.svelte";
var root_2 = add_locations(from_html(`<div><!></div>`), Item_content[FILENAME], [[26, 1]]);
function Item_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_content);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const accordion = RootContext.consume();
  const itemProps13 = ItemContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(accordion().getItemContentProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_content, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_content, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_content,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_content = hmr(Item_content);
  import.meta.hot.accept((module) => {
    Item_content[HMR].update(module.default);
  });
}
var item_content_default = Item_content;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/item-indicator.svelte
Item_indicator[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/item-indicator.svelte";
var root_22 = add_locations(from_html(`<div><!></div>`), Item_indicator[FILENAME], [[26, 1]]);
function Item_indicator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_indicator);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const accordion = RootContext.consume();
  const itemProps13 = ItemContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(accordion().getItemIndicatorProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_indicator, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_22();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_indicator, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_indicator,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_indicator = hmr(Item_indicator);
  import.meta.hot.accept((module) => {
    Item_indicator[HMR].update(module.default);
  });
}
var item_indicator_default = Item_indicator;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/item-trigger.svelte
Item_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/item-trigger.svelte";
var root_23 = add_locations(from_html(`<button><!></button>`), Item_trigger[FILENAME], [[26, 1]]);
function Item_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const accordion = RootContext.consume();
  const itemProps13 = ItemContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(accordion().getItemTriggerProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_trigger, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_23();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_trigger, 27, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_trigger,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_trigger = hmr(Item_trigger);
  import.meta.hot.accept((module) => {
    Item_trigger[HMR].update(module.default);
  });
}
var item_trigger_default = Item_trigger;

// node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts26 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts26)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts26, ...values]),
  omit: (...values) => createAnatomy(name, parts26.filter((part) => !values.includes(part))),
  rename: (newName) => createAnatomy(newName, parts26),
  keys: () => parts26,
  build: () => [...new Set(parts26)].reduce(
    (prev2, part) => Object.assign(prev2, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/@zag-js/accordion/dist/index.mjs
var anatomy = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `accordion:${ctx.id}`;
var getItemId = (ctx, value) => ctx.ids?.item?.(value) ?? `accordion:${ctx.id}:item:${value}`;
var getItemContentId = (ctx, value) => ctx.ids?.itemContent?.(value) ?? `accordion:${ctx.id}:content:${value}`;
var getItemTriggerId = (ctx, value) => ctx.ids?.itemTrigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getTriggerEls = (ctx) => {
  const ownerId = CSS.escape(getRootId(ctx));
  const selector = `[data-controls][data-ownedby='${ownerId}']:not([disabled])`;
  return queryAll(getRootEl(ctx), selector);
};
var getFirstTriggerEl = (ctx) => first(getTriggerEls(ctx));
var getLastTriggerEl = (ctx) => last(getTriggerEls(ctx));
var getNextTriggerEl = (ctx, id) => nextById(getTriggerEls(ctx), getItemTriggerId(ctx, id));
var getPrevTriggerEl = (ctx, id) => prevById(getTriggerEls(ctx), getItemTriggerId(ctx, id));
function connect(service, normalize2) {
  const { send, context, prop, scope, computed } = service;
  const focusedValue = context.get("focusedValue");
  const value = context.get("value");
  const multiple = prop("multiple");
  function setValue(value2) {
    let nextValue = value2;
    if (!multiple && nextValue.length > 1) {
      nextValue = [nextValue[0]];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props25) {
    return {
      expanded: value.includes(props25.value),
      focused: focusedValue === props25.value,
      disabled: Boolean(props25.disabled ?? prop("disabled"))
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts.root.attrs,
        dir: prop("dir"),
        id: getRootId(scope),
        "data-orientation": prop("orientation")
      });
    },
    getItemProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts.item.attrs,
        dir: prop("dir"),
        id: getItemId(scope, props25.value),
        "data-state": itemState.expanded ? "open" : "closed",
        "data-focus": dataAttr(itemState.focused),
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": prop("orientation")
      });
    },
    getItemContentProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts.itemContent.attrs,
        dir: prop("dir"),
        role: "region",
        id: getItemContentId(scope, props25.value),
        "aria-labelledby": getItemTriggerId(scope, props25.value),
        hidden: !itemState.expanded,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": prop("orientation")
      });
    },
    getItemIndicatorProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts.itemIndicator.attrs,
        dir: prop("dir"),
        "aria-hidden": true,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": prop("orientation")
      });
    },
    getItemTriggerProps(props25) {
      const { value: value2 } = props25;
      const itemState = getItemState(props25);
      return normalize2.button({
        ...parts.itemTrigger.attrs,
        type: "button",
        dir: prop("dir"),
        id: getItemTriggerId(scope, value2),
        "aria-controls": getItemContentId(scope, value2),
        "data-controls": getItemContentId(scope, value2),
        "aria-expanded": itemState.expanded,
        disabled: itemState.disabled,
        "data-orientation": prop("orientation"),
        "aria-disabled": itemState.disabled,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-ownedby": getRootId(scope),
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.BLUR" });
        },
        onClick(event) {
          if (itemState.disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          const keyMap2 = {
            ArrowDown() {
              if (computed("isHorizontal")) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (computed("isHorizontal")) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!computed("isHorizontal")) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!computed("isHorizontal")) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
var { and, not } = createGuards();
var machine = createMachine({
  props({ props: props25 }) {
    return {
      collapsible: false,
      multiple: false,
      orientation: "vertical",
      defaultValue: [],
      ...props25
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable: bindable2 }) {
    return {
      focusedValue: bindable2(() => ({
        defaultValue: null,
        sync: true,
        onChange(value) {
          prop("onFocusChange")?.({ value });
        }
      })),
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      }))
    };
  },
  computed: {
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal"
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    }
  },
  states: {
    idle: {
      on: {
        "TRIGGER.FOCUS": {
          target: "focused",
          actions: ["setFocusedValue"]
        }
      }
    },
    focused: {
      on: {
        "GOTO.NEXT": {
          actions: ["focusNextTrigger"]
        },
        "GOTO.PREV": {
          actions: ["focusPrevTrigger"]
        },
        "TRIGGER.CLICK": [
          {
            guard: and("isExpanded", "canToggle"),
            actions: ["collapse"]
          },
          {
            guard: not("isExpanded"),
            actions: ["expand"]
          }
        ],
        "GOTO.FIRST": {
          actions: ["focusFirstTrigger"]
        },
        "GOTO.LAST": {
          actions: ["focusLastTrigger"]
        },
        "TRIGGER.BLUR": {
          target: "idle",
          actions: ["clearFocusedValue"]
        }
      }
    }
  },
  implementations: {
    guards: {
      canToggle: ({ prop }) => !!prop("collapsible") || !!prop("multiple"),
      isExpanded: ({ context, event }) => context.get("value").includes(event.value)
    },
    actions: {
      collapse({ context, prop, event }) {
        const next3 = prop("multiple") ? remove(context.get("value"), event.value) : [];
        context.set("value", next3);
      },
      expand({ context, prop, event }) {
        const next3 = prop("multiple") ? add(context.get("value"), event.value) : [event.value];
        context.set("value", next3);
      },
      focusFirstTrigger({ scope }) {
        getFirstTriggerEl(scope)?.focus();
      },
      focusLastTrigger({ scope }) {
        getLastTriggerEl(scope)?.focus();
      },
      focusNextTrigger({ context, scope }) {
        const focusedValue = context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getNextTriggerEl(scope, focusedValue);
        triggerEl?.focus();
      },
      focusPrevTrigger({ context, scope }) {
        const focusedValue = context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getPrevTriggerEl(scope, focusedValue);
        triggerEl?.focus();
      },
      setFocusedValue({ context, event }) {
        context.set("focusedValue", event.value);
      },
      clearFocusedValue({ context }) {
        context.set("focusedValue", null);
      },
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      coarseValue({ context, prop }) {
        if (!prop("multiple") && context.get("value").length > 1) {
          warn(`The value of accordion should be a single value when multiple is false.`);
          context.set("value", [context.get("value")[0]]);
        }
      }
    }
  }
});
var props = createProps()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value",
  "defaultValue"
]);
var splitProps2 = createSplitProps(props);
var itemProps = createProps()(["value", "disabled"]);
var splitItemProps = createSplitProps(itemProps);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/item.svelte
Item[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/item.svelte";
var root_24 = add_locations(from_html(`<div><!></div>`), Item[FILENAME], [[30, 1]]);
function Item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const accordion = RootContext.consume();
  const $$d = user_derived(() => splitItemProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(accordion().getItemProps(get(itemProps13)), get(rest))), "attributes");
  ItemContext.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_24();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item = hmr(Item);
  import.meta.hot.accept((module) => {
    Item[HMR].update(module.default);
  });
}
var item_default = Item;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/root-context.svelte
Root_context[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/root-context.svelte";
function Root_context($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const accordion = RootContext.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => accordion), "render", Root_context, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context = hmr(Root_context);
  import.meta.hot.accept((module) => {
    Root_context[HMR].update(module.default);
  });
}
var root_context_default = Root_context;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/root-provider.svelte
Root_provider[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/root-provider.svelte";
var root_25 = add_locations(from_html(`<div><!></div>`), Root_provider[FILENAME], [[27, 1]]);
function Root_provider($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), accordion = tag(user_derived(() => $$props.value), "accordion"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(accordion)().getRootProps(), get(rest))), "attributes");
  RootContext.provide(() => get(accordion)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_25();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider = hmr(Root_provider);
  import.meta.hot.accept((module) => {
    Root_provider[HMR].update(module.default);
  });
}
var root_provider_default = Root_provider;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/modules/provider.svelte.js
function useAccordion(props25) {
  const service = useMachine(machine, props25);
  const accordion = tag(user_derived(() => connect(service, normalizeProps)), "accordion");
  return () => get(accordion);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/root.svelte
Root[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/anatomy/root.svelte";
var root_26 = add_locations(from_html(`<div><!></div>`), Root[FILENAME], [[34, 1]]);
function Root($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps2(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), accordionProps = tag(user_derived(() => get($$array)[0]), "accordionProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const accordion = useAccordion(() => ({ ...get(accordionProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(accordion().getRootProps(), get(rest))), "attributes");
  RootContext.provide(() => accordion());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_26();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root = hmr(Root);
  import.meta.hot.accept((module) => {
    Root[HMR].update(module.default);
  });
}
var root_default = Root;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/accordion/modules/anatomy.js
var Accordion = Object.assign(root_default, {
  Provider: root_provider_default,
  Context: root_context_default,
  Item: item_default,
  ItemTrigger: item_trigger_default,
  ItemIndicator: item_indicator_default,
  ItemContent: item_content_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/headline.svelte
Headline[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/headline.svelte";
var root_27 = add_locations(from_html(`<div><!></div>`), Headline[FILENAME], [[29, 1]]);
function Headline($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Headline);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2({ "data-scope": "app-bar", "data-part": "headline" }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Headline, 27, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_27();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Headline, 30, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Headline,
      26,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Headline = hmr(Headline);
  import.meta.hot.accept((module) => {
    Headline[HMR].update(module.default);
  });
}
var headline_default = Headline;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/lead.svelte
Lead[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/lead.svelte";
var root_28 = add_locations(from_html(`<nav><!></nav>`), Lead[FILENAME], [[29, 1]]);
function Lead($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Lead);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2({ "data-scope": "app-bar", "data-part": "lead" }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Lead, 27, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var nav = root_28();
      attribute_effect(nav, () => ({ ...get(attributes) }));
      var node_2 = child(nav);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Lead, 30, 2);
      reset(nav);
      append($$anchor2, nav);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Lead,
      26,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Lead = hmr(Lead);
  import.meta.hot.accept((module) => {
    Lead[HMR].update(module.default);
  });
}
var lead_default = Lead;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/root.svelte
Root2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/root.svelte";
var root_29 = add_locations(from_html(`<header><!></header>`), Root2[FILENAME], [[29, 1]]);
function Root2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2({ "data-scope": "app-bar", "data-part": "root" }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root2, 27, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var header = root_29();
      attribute_effect(header, () => ({ ...get(attributes) }));
      var node_2 = child(header);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root2, 30, 2);
      reset(header);
      append($$anchor2, header);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root2,
      26,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root2 = hmr(Root2);
  import.meta.hot.accept((module) => {
    Root2[HMR].update(module.default);
  });
}
var root_default2 = Root2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/toolbar.svelte
Toolbar[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/toolbar.svelte";
var root_210 = add_locations(from_html(`<div><!></div>`), Toolbar[FILENAME], [[29, 1]]);
function Toolbar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Toolbar);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2({ "data-scope": "app-bar", "data-part": "toolbar" }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Toolbar, 27, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_210();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Toolbar, 30, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Toolbar,
      26,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Toolbar = hmr(Toolbar);
  import.meta.hot.accept((module) => {
    Toolbar[HMR].update(module.default);
  });
}
var toolbar_default = Toolbar;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/trail.svelte
Trail[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/anatomy/trail.svelte";
var root_211 = add_locations(from_html(`<nav><!></nav>`), Trail[FILENAME], [[29, 1]]);
function Trail($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trail);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2({ "data-scope": "app-bar", "data-part": "trail" }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trail, 27, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var nav = root_211();
      attribute_effect(nav, () => ({ ...get(attributes) }));
      var node_2 = child(nav);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trail, 30, 2);
      reset(nav);
      append($$anchor2, nav);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trail,
      26,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trail = hmr(Trail);
  import.meta.hot.accept((module) => {
    Trail[HMR].update(module.default);
  });
}
var trail_default = Trail;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/app-bar/modules/anatomy.js
var AppBar = Object.assign(root_default2, {
  Toolbar: toolbar_default,
  Lead: lead_default,
  Headline: headline_default,
  Trail: trail_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/modules/root-context.js
var RootContext2 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/fallback.svelte
Fallback[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/fallback.svelte";
var root_212 = add_locations(from_html(`<span><!></span>`), Fallback[FILENAME], [[24, 1]]);
function Fallback($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Fallback);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const avatar = RootContext2.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(avatar().getFallbackProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Fallback, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_212();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Fallback, 25, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Fallback,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Fallback = hmr(Fallback);
  import.meta.hot.accept((module) => {
    Fallback[HMR].update(module.default);
  });
}
var fallback_default = Fallback;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/image.svelte
Image[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/image.svelte";
var root_213 = add_locations(from_html(`<img/>`), Image[FILENAME], [[24, 1]]);
function Image($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Image);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const avatar = RootContext2.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(avatar().getImageProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Image, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var img = root_213();
      attribute_effect(img, () => ({ ...get(attributes) }));
      replay_events(img);
      append($$anchor2, img);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Image,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Image = hmr(Image);
  import.meta.hot.accept((module) => {
    Image[HMR].update(module.default);
  });
}
var image_default = Image;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/root-context.svelte
Root_context2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/root-context.svelte";
function Root_context2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const avatar = RootContext2.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => avatar), "render", Root_context2, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context2 = hmr(Root_context2);
  import.meta.hot.accept((module) => {
    Root_context2[HMR].update(module.default);
  });
}
var root_context_default2 = Root_context2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/root-provider.svelte
Root_provider2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/root-provider.svelte";
var root_214 = add_locations(from_html(`<div><!></div>`), Root_provider2[FILENAME], [[27, 1]]);
function Root_provider2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), avatar = tag(user_derived(() => $$props.value), "avatar"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(avatar)().getRootProps(), get(rest))), "attributes");
  RootContext2.provide(() => get(avatar)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider2, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_214();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider2, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider2,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider2 = hmr(Root_provider2);
  import.meta.hot.accept((module) => {
    Root_provider2[HMR].update(module.default);
  });
}
var root_provider_default2 = Root_provider2;

// node_modules/@zag-js/avatar/dist/index.mjs
var anatomy2 = createAnatomy("avatar").parts("root", "image", "fallback");
var parts2 = anatomy2.build();
var getRootId2 = (ctx) => ctx.ids?.root ?? `avatar:${ctx.id}`;
var getImageId = (ctx) => ctx.ids?.image ?? `avatar:${ctx.id}:image`;
var getFallbackId = (ctx) => ctx.ids?.fallback ?? `avatar:${ctx.id}:fallback`;
var getRootEl2 = (ctx) => ctx.getById(getRootId2(ctx));
var getImageEl = (ctx) => ctx.getById(getImageId(ctx));
function connect2(service, normalize2) {
  const { state: state3, send, prop, scope } = service;
  const loaded = state3.matches("loaded");
  return {
    loaded,
    setSrc(src) {
      const img = getImageEl(scope);
      img?.setAttribute("src", src);
    },
    setLoaded() {
      send({ type: "img.loaded", src: "api" });
    },
    setError() {
      send({ type: "img.error", src: "api" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts2.root.attrs,
        dir: prop("dir"),
        id: getRootId2(scope)
      });
    },
    getImageProps() {
      return normalize2.img({
        ...parts2.image.attrs,
        hidden: !loaded,
        dir: prop("dir"),
        id: getImageId(scope),
        "data-state": loaded ? "visible" : "hidden",
        onLoad() {
          send({ type: "img.loaded", src: "element" });
        },
        onError() {
          send({ type: "img.error", src: "element" });
        }
      });
    },
    getFallbackProps() {
      return normalize2.element({
        ...parts2.fallback.attrs,
        dir: prop("dir"),
        id: getFallbackId(scope),
        hidden: loaded,
        "data-state": loaded ? "hidden" : "visible"
      });
    }
  };
}
var machine2 = createMachine({
  initialState() {
    return "loading";
  },
  effects: ["trackImageRemoval", "trackSrcChange"],
  on: {
    "src.change": {
      target: "loading"
    },
    "img.unmount": {
      target: "error"
    }
  },
  states: {
    loading: {
      entry: ["checkImageStatus"],
      on: {
        "img.loaded": {
          target: "loaded",
          actions: ["invokeOnLoad"]
        },
        "img.error": {
          target: "error",
          actions: ["invokeOnError"]
        }
      }
    },
    error: {
      on: {
        "img.loaded": {
          target: "loaded",
          actions: ["invokeOnLoad"]
        }
      }
    },
    loaded: {
      on: {
        "img.error": {
          target: "error",
          actions: ["invokeOnError"]
        }
      }
    }
  },
  implementations: {
    actions: {
      invokeOnLoad({ prop }) {
        prop("onStatusChange")?.({ status: "loaded" });
      },
      invokeOnError({ prop }) {
        prop("onStatusChange")?.({ status: "error" });
      },
      checkImageStatus({ send, scope }) {
        const imageEl = getImageEl(scope);
        if (!imageEl?.complete) return;
        const type = hasLoaded(imageEl) ? "img.loaded" : "img.error";
        send({ type, src: "ssr" });
      }
    },
    effects: {
      trackImageRemoval({ send, scope }) {
        const rootEl = getRootEl2(scope);
        return observeChildren(rootEl, {
          callback(records) {
            const removedNodes = Array.from(records[0].removedNodes);
            const removed = removedNodes.find(
              (node) => node.nodeType === Node.ELEMENT_NODE && node.matches("[data-scope=avatar][data-part=image]")
            );
            if (removed) {
              send({ type: "img.unmount" });
            }
          }
        });
      },
      trackSrcChange({ send, scope }) {
        const imageEl = getImageEl(scope);
        return observeAttributes(imageEl, {
          attributes: ["src", "srcset"],
          callback() {
            send({ type: "src.change" });
          }
        });
      }
    }
  }
});
function hasLoaded(image) {
  return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
var props2 = createProps()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var splitProps3 = createSplitProps(props2);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/modules/provider.svelte.js
function useAvatar(props25) {
  const service = useMachine(machine2, props25);
  const avatar = tag(user_derived(() => connect2(service, normalizeProps)), "avatar");
  return () => get(avatar);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/root.svelte
Root3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/anatomy/root.svelte";
var root_215 = add_locations(from_html(`<div><!></div>`), Root3[FILENAME], [[34, 1]]);
function Root3($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps3(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), avatarProps = tag(user_derived(() => get($$array)[0]), "avatarProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const avatar = useAvatar(() => ({ ...get(avatarProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(avatar().getRootProps(), get(rest))), "attributes");
  RootContext2.provide(() => avatar());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root3, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_215();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root3, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root3,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root3 = hmr(Root3);
  import.meta.hot.accept((module) => {
    Root3[HMR].update(module.default);
  });
}
var root_default3 = Root3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/avatar/modules/anatomy.js
var Avatar = Object.assign(root_default3, {
  Provider: root_provider_default2,
  Context: root_context_default2,
  Image: image_default,
  Fallback: fallback_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/modules/root-context.js
var RootContext3 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/autoplay-trigger.svelte
Autoplay_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/autoplay-trigger.svelte";
var root_216 = add_locations(from_html(`<button><!></button>`), Autoplay_trigger[FILENAME], [[24, 1]]);
function Autoplay_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Autoplay_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(carousel().getAutoplayTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Autoplay_trigger, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_216();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Autoplay_trigger, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Autoplay_trigger,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Autoplay_trigger = hmr(Autoplay_trigger);
  import.meta.hot.accept((module) => {
    Autoplay_trigger[HMR].update(module.default);
  });
}
var autoplay_trigger_default = Autoplay_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/control.svelte
Control[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/control.svelte";
var root_217 = add_locations(from_html(`<div><!></div>`), Control[FILENAME], [[24, 1]]);
function Control($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(carousel().getControlProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Control, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_217();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Control, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Control,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Control = hmr(Control);
  import.meta.hot.accept((module) => {
    Control[HMR].update(module.default);
  });
}
var control_default = Control;

// node_modules/@zag-js/scroll-snap/dist/index.mjs
var getDirection = (element2) => getComputedStyle2(element2).direction;
function getScrollPadding(element2) {
  const style = getComputedStyle2(element2);
  const rect = element2.getBoundingClientRect();
  let xBeforeRaw = style.getPropertyValue("scroll-padding-left").replace("auto", "0px");
  let yBeforeRaw = style.getPropertyValue("scroll-padding-top").replace("auto", "0px");
  let xAfterRaw = style.getPropertyValue("scroll-padding-right").replace("auto", "0px");
  let yAfterRaw = style.getPropertyValue("scroll-padding-bottom").replace("auto", "0px");
  function convert(raw, size2) {
    let n = parseFloat(raw);
    if (/%/.test(raw)) {
      n /= 100;
      n *= size2;
    }
    return Number.isNaN(n) ? 0 : n;
  }
  let xBefore = convert(xBeforeRaw, rect.width);
  let yBefore = convert(yBeforeRaw, rect.height);
  let xAfter = convert(xAfterRaw, rect.width);
  let yAfter = convert(yAfterRaw, rect.height);
  return {
    x: { before: xBefore, after: xAfter },
    y: { before: yBefore, after: yAfter }
  };
}
function isRectIntersecting(a, b, axis = "both") {
  return axis === "x" && a.right >= b.left && a.left <= b.right || axis === "y" && a.bottom >= b.top && a.top <= b.bottom || axis === "both" && a.right >= b.left && a.left <= b.right && a.bottom >= b.top && a.top <= b.bottom;
}
function getDescendants(parent) {
  let children = [];
  for (const child2 of parent.children) {
    children = children.concat(child2, getDescendants(child2));
  }
  return children;
}
function getSnapPositions(parent, subtree = false) {
  const parentRect = parent.getBoundingClientRect();
  const dir = getDirection(parent);
  const isRtl = dir === "rtl";
  const positions = {
    x: { start: [], center: [], end: [] },
    y: { start: [], center: [], end: [] }
  };
  const children = subtree ? getDescendants(parent) : parent.children;
  for (const axis of ["x", "y"]) {
    const orthogonalAxis = axis === "x" ? "y" : "x";
    const axisStart = axis === "x" ? "left" : "top";
    const axisEnd = axis === "x" ? "right" : "bottom";
    const axisSize = axis === "x" ? "width" : "height";
    const axisScroll = axis === "x" ? "scrollLeft" : "scrollTop";
    const useRtlCalc = isRtl && axis === "x";
    for (const child2 of children) {
      const childRect = child2.getBoundingClientRect();
      if (!isRectIntersecting(parentRect, childRect, orthogonalAxis)) {
        continue;
      }
      const childStyle = getComputedStyle2(child2);
      let [childAlignY, childAlignX] = childStyle.getPropertyValue("scroll-snap-align").split(" ");
      if (typeof childAlignX === "undefined") {
        childAlignX = childAlignY;
      }
      const childAlign = axis === "x" ? childAlignX : childAlignY;
      let childOffsetStart;
      let childOffsetEnd;
      let childOffsetCenter;
      if (useRtlCalc) {
        const scrollOffset = Math.abs(parent[axisScroll]);
        const rightOffset = parentRect[axisEnd] - childRect[axisEnd] + scrollOffset;
        childOffsetStart = rightOffset;
        childOffsetEnd = rightOffset + childRect[axisSize];
        childOffsetCenter = rightOffset + childRect[axisSize] / 2;
      } else {
        childOffsetStart = childRect[axisStart] - parentRect[axisStart] + parent[axisScroll];
        childOffsetEnd = childOffsetStart + childRect[axisSize];
        childOffsetCenter = childOffsetStart + childRect[axisSize] / 2;
      }
      switch (childAlign) {
        case "none":
          break;
        case "start":
          positions[axis].start.push({ node: child2, position: childOffsetStart });
          break;
        case "center":
          positions[axis].center.push({ node: child2, position: childOffsetCenter });
          break;
        case "end":
          positions[axis].end.push({ node: child2, position: childOffsetEnd });
          break;
      }
    }
  }
  return positions;
}
function getScrollSnapPositions(element2) {
  const dir = getDirection(element2);
  const rect = element2.getBoundingClientRect();
  const scrollPadding = getScrollPadding(element2);
  const snapPositions = getSnapPositions(element2);
  const maxScroll = {
    x: element2.scrollWidth - element2.offsetWidth,
    y: element2.scrollHeight - element2.offsetHeight
  };
  const isRtl = dir === "rtl";
  const usesNegativeScrollLeft = isRtl && element2.scrollLeft <= 0;
  let xPositions;
  if (isRtl) {
    xPositions = uniq2(
      [
        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.after),
        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),
        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.before)
      ].map(clamp2(0, maxScroll.x))
    );
    if (usesNegativeScrollLeft) {
      xPositions = xPositions.map((pos) => -pos);
    }
  } else {
    xPositions = uniq2(
      [
        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.before),
        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),
        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.after)
      ].map(clamp2(0, maxScroll.x))
    );
  }
  return {
    x: xPositions,
    y: uniq2(
      [
        ...snapPositions.y.start.map((v) => v.position - scrollPadding.y.before),
        ...snapPositions.y.center.map((v) => v.position - rect.height / 2),
        ...snapPositions.y.end.map((v) => v.position - rect.height + scrollPadding.y.after)
      ].map(clamp2(0, maxScroll.y))
    )
  };
}
function findSnapPoint(parent, axis, predicate) {
  const dir = getDirection(parent);
  const scrollPadding = getScrollPadding(parent);
  const snapPositions = getSnapPositions(parent);
  const items = [...snapPositions[axis].start, ...snapPositions[axis].center, ...snapPositions[axis].end];
  const isRtl = dir === "rtl";
  const usesNegativeScrollLeft = isRtl && axis === "x" && parent.scrollLeft <= 0;
  for (const item of items) {
    if (predicate(item.node)) {
      let position;
      if (axis === "x" && isRtl) {
        position = item.position - scrollPadding.x.after;
        if (usesNegativeScrollLeft) {
          position = -position;
        }
      } else {
        position = item.position - (axis === "x" ? scrollPadding.x.before : scrollPadding.y.before);
      }
      return position;
    }
  }
}
var uniq2 = (arr) => [...new Set(arr)];
var clamp2 = (min3, max3) => (value) => Math.max(min3, Math.min(max3, value));

// node_modules/@zag-js/carousel/dist/index.mjs
var anatomy3 = createAnatomy("carousel").parts(
  "root",
  "itemGroup",
  "item",
  "control",
  "nextTrigger",
  "prevTrigger",
  "indicatorGroup",
  "indicator",
  "autoplayTrigger",
  "progressText"
);
var parts3 = anatomy3.build();
var getRootId3 = (ctx) => ctx.ids?.root ?? `carousel:${ctx.id}`;
var getItemId2 = (ctx, index) => ctx.ids?.item?.(index) ?? `carousel:${ctx.id}:item:${index}`;
var getItemGroupId = (ctx) => ctx.ids?.itemGroup ?? `carousel:${ctx.id}:item-group`;
var getNextTriggerId = (ctx) => ctx.ids?.nextTrigger ?? `carousel:${ctx.id}:next-trigger`;
var getPrevTriggerId = (ctx) => ctx.ids?.prevTrigger ?? `carousel:${ctx.id}:prev-trigger`;
var getIndicatorGroupId = (ctx) => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`;
var getIndicatorId = (ctx, index) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`;
var getItemGroupEl = (ctx) => ctx.getById(getItemGroupId(ctx));
var getItemEls = (ctx) => queryAll(getItemGroupEl(ctx), `[data-part=item]`);
var getIndicatorEl = (ctx, page) => ctx.getById(getIndicatorId(ctx, page));
var syncTabIndex = (ctx) => {
  const el = getItemGroupEl(ctx);
  if (!el) return;
  const tabbables = getTabbables(el);
  el.setAttribute("tabindex", tabbables.length > 0 ? "-1" : "0");
};
function connect3(service, normalize2) {
  const { state: state3, context, computed, send, scope, prop } = service;
  const isPlaying = state3.matches("autoplay");
  const isDragging = state3.matches("dragging");
  const canScrollNext = computed("canScrollNext");
  const canScrollPrev = computed("canScrollPrev");
  const horizontal = computed("isHorizontal");
  const autoSize = prop("autoSize");
  const pageSnapPoints = Array.from(context.get("pageSnapPoints"));
  const page = context.get("page");
  const slidesPerPage = prop("slidesPerPage");
  const padding = prop("padding");
  const translations = prop("translations");
  return {
    isPlaying,
    isDragging,
    page,
    pageSnapPoints,
    canScrollNext,
    canScrollPrev,
    getProgress() {
      return page / pageSnapPoints.length;
    },
    getProgressText() {
      const details = { page: page + 1, totalPages: pageSnapPoints.length };
      return translations.progressText?.(details) ?? "";
    },
    scrollToIndex(index, instant) {
      send({ type: "INDEX.SET", index, instant });
    },
    scrollTo(index, instant) {
      send({ type: "PAGE.SET", index, instant });
    },
    scrollNext(instant) {
      send({ type: "PAGE.NEXT", instant });
    },
    scrollPrev(instant) {
      send({ type: "PAGE.PREV", instant });
    },
    play() {
      send({ type: "AUTOPLAY.START" });
    },
    pause() {
      send({ type: "AUTOPLAY.PAUSE" });
    },
    isInView(index) {
      return Array.from(context.get("slidesInView")).includes(index);
    },
    refresh() {
      send({ type: "SNAP.REFRESH" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts3.root.attrs,
        id: getRootId3(scope),
        role: "region",
        "aria-roledescription": "carousel",
        "data-orientation": prop("orientation"),
        dir: prop("dir"),
        style: {
          "--slides-per-page": slidesPerPage,
          "--slide-spacing": prop("spacing"),
          "--slide-item-size": autoSize ? "auto" : "calc(100% / var(--slides-per-page) - var(--slide-spacing) * (var(--slides-per-page) - 1) / var(--slides-per-page))"
        }
      });
    },
    getItemGroupProps() {
      return normalize2.element({
        ...parts3.itemGroup.attrs,
        id: getItemGroupId(scope),
        "data-orientation": prop("orientation"),
        "data-dragging": dataAttr(isDragging),
        dir: prop("dir"),
        "aria-live": isPlaying ? "off" : "polite",
        onFocus(event) {
          if (!contains(event.currentTarget, getEventTarget(event))) return;
          send({ type: "VIEWPORT.FOCUS" });
        },
        onBlur(event) {
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "VIEWPORT.BLUR" });
        },
        onMouseDown(event) {
          if (event.defaultPrevented) return;
          if (!prop("allowMouseDrag")) return;
          if (!isLeftClick(event)) return;
          const target = getEventTarget(event);
          if (isFocusable(target) && target !== event.currentTarget) return;
          event.preventDefault();
          send({ type: "DRAGGING.START" });
        },
        onWheel: throttle((event) => {
          const axis = prop("orientation") === "horizontal" ? "deltaX" : "deltaY";
          const isScrollingLeft = event[axis] < 0;
          if (isScrollingLeft && !computed("canScrollPrev")) return;
          const isScrollingRight = event[axis] > 0;
          if (isScrollingRight && !computed("canScrollNext")) return;
          send({ type: "USER.SCROLL" });
        }, 150),
        onTouchStart() {
          send({ type: "USER.SCROLL" });
        },
        style: {
          display: autoSize ? "flex" : "grid",
          gap: "var(--slide-spacing)",
          scrollSnapType: [horizontal ? "x" : "y", prop("snapType")].join(" "),
          gridAutoFlow: horizontal ? "column" : "row",
          scrollbarWidth: "none",
          overscrollBehaviorX: "contain",
          [horizontal ? "gridAutoColumns" : "gridAutoRows"]: autoSize ? void 0 : "var(--slide-item-size)",
          [horizontal ? "scrollPaddingInline" : "scrollPaddingBlock"]: padding,
          [horizontal ? "paddingInline" : "paddingBlock"]: padding,
          [horizontal ? "overflowX" : "overflowY"]: "auto"
        }
      });
    },
    getItemProps(props25) {
      const isInView = context.get("slidesInView").includes(props25.index);
      return normalize2.element({
        ...parts3.item.attrs,
        id: getItemId2(scope, props25.index),
        dir: prop("dir"),
        role: "group",
        "data-index": props25.index,
        "data-inview": dataAttr(isInView),
        "aria-roledescription": "slide",
        "data-orientation": prop("orientation"),
        "aria-label": translations.item(props25.index, prop("slideCount")),
        "aria-hidden": ariaAttr(!isInView),
        style: {
          flex: "0 0 auto",
          [horizontal ? "maxWidth" : "maxHeight"]: "100%",
          scrollSnapAlign: (() => {
            const snapAlign = props25.snapAlign ?? "start";
            const slidesPerMove = prop("slidesPerMove");
            const perMove = slidesPerMove === "auto" ? Math.floor(prop("slidesPerPage")) : slidesPerMove;
            const shouldSnap = (props25.index + perMove) % perMove === 0;
            return shouldSnap ? snapAlign : void 0;
          })()
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts3.control.attrs,
        "data-orientation": prop("orientation")
      });
    },
    getPrevTriggerProps() {
      return normalize2.button({
        ...parts3.prevTrigger.attrs,
        id: getPrevTriggerId(scope),
        type: "button",
        disabled: !canScrollPrev,
        dir: prop("dir"),
        "aria-label": translations.prevTrigger,
        "data-orientation": prop("orientation"),
        "aria-controls": getItemGroupId(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.PREV", src: "trigger" });
        }
      });
    },
    getNextTriggerProps() {
      return normalize2.button({
        ...parts3.nextTrigger.attrs,
        dir: prop("dir"),
        id: getNextTriggerId(scope),
        type: "button",
        "aria-label": translations.nextTrigger,
        "data-orientation": prop("orientation"),
        "aria-controls": getItemGroupId(scope),
        disabled: !canScrollNext,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.NEXT", src: "trigger" });
        }
      });
    },
    getIndicatorGroupProps() {
      return normalize2.element({
        ...parts3.indicatorGroup.attrs,
        dir: prop("dir"),
        id: getIndicatorGroupId(scope),
        "data-orientation": prop("orientation"),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const src = "indicator";
          const keyMap2 = {
            ArrowDown(event2) {
              if (horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowUp(event2) {
              if (horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            ArrowRight(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowLeft(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            Home(event2) {
              send({ type: "PAGE.SET", index: 0, src });
              event2.preventDefault();
            },
            End(event2) {
              send({ type: "PAGE.SET", index: pageSnapPoints.length - 1, src });
              event2.preventDefault();
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          exec?.(event);
        }
      });
    },
    getIndicatorProps(props25) {
      return normalize2.button({
        ...parts3.indicator.attrs,
        dir: prop("dir"),
        id: getIndicatorId(scope, props25.index),
        type: "button",
        "data-orientation": prop("orientation"),
        "data-index": props25.index,
        "data-readonly": dataAttr(props25.readOnly),
        "data-current": dataAttr(props25.index === page),
        "aria-label": translations.indicator(props25.index),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (props25.readOnly) return;
          send({ type: "PAGE.SET", index: props25.index, src: "indicator" });
        }
      });
    },
    getAutoplayTriggerProps() {
      return normalize2.button({
        ...parts3.autoplayTrigger.attrs,
        type: "button",
        "data-orientation": prop("orientation"),
        "data-pressed": dataAttr(isPlaying),
        "aria-label": isPlaying ? translations.autoplayStop : translations.autoplayStart,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: isPlaying ? "AUTOPLAY.PAUSE" : "AUTOPLAY.START" });
        }
      });
    },
    getProgressTextProps() {
      return normalize2.element({
        ...parts3.progressText.attrs
      });
    }
  };
}
var machine3 = createMachine({
  props({ props: props25 }) {
    ensureProps(props25, ["slideCount"], "carousel");
    return {
      dir: "ltr",
      defaultPage: 0,
      orientation: "horizontal",
      snapType: "mandatory",
      loop: !!props25.autoplay,
      slidesPerPage: 1,
      slidesPerMove: "auto",
      spacing: "0px",
      autoplay: false,
      allowMouseDrag: false,
      inViewThreshold: 0.6,
      autoSize: false,
      ...props25,
      translations: {
        nextTrigger: "Next slide",
        prevTrigger: "Previous slide",
        indicator: (index) => `Go to slide ${index + 1}`,
        item: (index, count) => `${index + 1} of ${count}`,
        autoplayStart: "Start slide rotation",
        autoplayStop: "Stop slide rotation",
        progressText: ({ page, totalPages }) => `${page} / ${totalPages}`,
        ...props25.translations
      }
    };
  },
  refs() {
    return {
      timeoutRef: void 0
    };
  },
  initialState({ prop }) {
    return prop("autoplay") ? "autoplay" : "idle";
  },
  context({ prop, bindable: bindable2, getContext: getContext2 }) {
    return {
      page: bindable2(() => ({
        defaultValue: prop("defaultPage"),
        value: prop("page"),
        onChange(page) {
          const ctx = getContext2();
          const pageSnapPoints = ctx.get("pageSnapPoints");
          prop("onPageChange")?.({ page, pageSnapPoint: pageSnapPoints[page] });
        }
      })),
      pageSnapPoints: bindable2(() => {
        return {
          defaultValue: prop("autoSize") ? Array.from({ length: prop("slideCount") }, (_, i) => i) : getPageSnapPoints(prop("slideCount"), prop("slidesPerMove"), prop("slidesPerPage"))
        };
      }),
      slidesInView: bindable2(() => ({
        defaultValue: []
      }))
    };
  },
  computed: {
    isRtl: ({ prop }) => prop("dir") === "rtl",
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal",
    canScrollNext: ({ prop, context }) => prop("loop") || context.get("page") < context.get("pageSnapPoints").length - 1,
    canScrollPrev: ({ prop, context }) => prop("loop") || context.get("page") > 0,
    autoplayInterval: ({ prop }) => {
      const autoplay = prop("autoplay");
      return isObject(autoplay) ? autoplay.delay : 4e3;
    }
  },
  watch({ track: track2, action, context, prop, send }) {
    track2([() => prop("slidesPerPage"), () => prop("slidesPerMove")], () => {
      action(["setSnapPoints"]);
    });
    track2([() => context.get("page")], () => {
      action(["scrollToPage", "focusIndicatorEl"]);
    });
    track2([() => prop("orientation"), () => prop("autoSize"), () => prop("dir")], () => {
      action(["setSnapPoints", "scrollToPage"]);
    });
    track2([() => prop("slideCount")], () => {
      send({ type: "SNAP.REFRESH", src: "slide.count" });
    });
    track2([() => !!prop("autoplay")], () => {
      send({ type: prop("autoplay") ? "AUTOPLAY.START" : "AUTOPLAY.PAUSE", src: "autoplay.prop.change" });
    });
  },
  on: {
    "PAGE.NEXT": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setNextPage"]
    },
    "PAGE.PREV": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setPrevPage"]
    },
    "PAGE.SET": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setPage"]
    },
    "INDEX.SET": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setMatchingPage"]
    },
    "SNAP.REFRESH": {
      actions: ["setSnapPoints", "clampPage"]
    },
    "PAGE.SCROLL": {
      actions: ["scrollToPage"]
    }
  },
  effects: ["trackSlideMutation", "trackSlideIntersections", "trackSlideResize"],
  entry: ["setSnapPoints", "setPage"],
  exit: ["clearScrollEndTimer"],
  states: {
    idle: {
      on: {
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "AUTOPLAY.START": {
          target: "autoplay",
          actions: ["invokeAutoplayStart"]
        },
        "USER.SCROLL": {
          target: "userScroll"
        },
        "VIEWPORT.FOCUS": {
          target: "focus"
        }
      }
    },
    focus: {
      effects: ["trackKeyboardScroll"],
      on: {
        "VIEWPORT.BLUR": {
          target: "idle"
        },
        "PAGE.NEXT": {
          actions: ["clearScrollEndTimer", "setNextPage"]
        },
        "PAGE.PREV": {
          actions: ["clearScrollEndTimer", "setPrevPage"]
        },
        "PAGE.SET": {
          actions: ["clearScrollEndTimer", "setPage"]
        },
        "INDEX.SET": {
          actions: ["clearScrollEndTimer", "setMatchingPage"]
        },
        "USER.SCROLL": {
          target: "userScroll"
        }
      }
    },
    dragging: {
      effects: ["trackPointerMove"],
      entry: ["disableScrollSnap"],
      on: {
        DRAGGING: {
          actions: ["scrollSlides", "invokeDragging"]
        },
        "DRAGGING.END": {
          target: "idle",
          actions: ["endDragging", "invokeDraggingEnd"]
        }
      }
    },
    userScroll: {
      effects: ["trackScroll"],
      on: {
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "SCROLL.END": [
          {
            guard: "isFocused",
            target: "focus",
            actions: ["setClosestPage"]
          },
          {
            target: "idle",
            actions: ["setClosestPage"]
          }
        ]
      }
    },
    autoplay: {
      effects: ["trackDocumentVisibility", "trackScroll", "autoUpdateSlide"],
      exit: ["invokeAutoplayEnd"],
      on: {
        "AUTOPLAY.TICK": {
          actions: ["setNextPage", "invokeAutoplay"]
        },
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "AUTOPLAY.PAUSE": {
          target: "idle"
        }
      }
    }
  },
  implementations: {
    guards: {
      isFocused: ({ scope }) => scope.isActiveElement(getItemGroupEl(scope))
    },
    effects: {
      autoUpdateSlide({ computed, send }) {
        const id = setInterval(() => {
          send({
            type: computed("canScrollNext") ? "AUTOPLAY.TICK" : "AUTOPLAY.PAUSE",
            src: "autoplay.interval"
          });
        }, computed("autoplayInterval"));
        return () => clearInterval(id);
      },
      trackSlideMutation({ scope, send }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const win = scope.getWin();
        const observer = new win.MutationObserver(() => {
          send({ type: "SNAP.REFRESH", src: "slide.mutation" });
          syncTabIndex(scope);
        });
        syncTabIndex(scope);
        observer.observe(el, { childList: true, subtree: true });
        return () => observer.disconnect();
      },
      trackSlideResize({ scope, send }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const exec = () => {
          send({ type: "SNAP.REFRESH", src: "slide.resize" });
        };
        raf(() => {
          exec();
          raf(() => {
            send({ type: "PAGE.SCROLL", instant: true });
          });
        });
        const itemEls = getItemEls(scope);
        itemEls.forEach(exec);
        const cleanups = itemEls.map((el2) => resizeObserverBorderBox.observe(el2, exec));
        return callAll(...cleanups);
      },
      trackSlideIntersections({ scope, prop, context }) {
        const el = getItemGroupEl(scope);
        const win = scope.getWin();
        const observer = new win.IntersectionObserver(
          (entries) => {
            const slidesInView = entries.reduce((acc, entry) => {
              const target = entry.target;
              const index = Number(target.dataset.index ?? "-1");
              if (index == null || Number.isNaN(index) || index === -1) return acc;
              return entry.isIntersecting ? add(acc, index) : remove(acc, index);
            }, context.get("slidesInView"));
            context.set("slidesInView", uniq(slidesInView));
          },
          {
            root: el,
            threshold: prop("inViewThreshold")
          }
        );
        getItemEls(scope).forEach((slide) => observer.observe(slide));
        return () => observer.disconnect();
      },
      trackScroll({ send, refs, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const onScroll = () => {
          clearTimeout(refs.get("timeoutRef"));
          refs.set("timeoutRef", void 0);
          refs.set(
            "timeoutRef",
            setTimeout(() => {
              send({ type: "SCROLL.END" });
            }, 150)
          );
        };
        return addDomEvent(el, "scroll", onScroll, { passive: true });
      },
      trackDocumentVisibility({ scope, send }) {
        const doc = scope.getDoc();
        const onVisibilityChange = () => {
          if (doc.visibilityState === "visible") return;
          send({ type: "AUTOPLAY.PAUSE", src: "doc.hidden" });
        };
        return addDomEvent(doc, "visibilitychange", onVisibilityChange);
      },
      trackPointerMove({ scope, send }) {
        const doc = scope.getDoc();
        return trackPointerMove(doc, {
          onPointerMove({ event }) {
            send({ type: "DRAGGING", left: -event.movementX, top: -event.movementY });
          },
          onPointerUp() {
            send({ type: "DRAGGING.END" });
          }
        });
      },
      trackKeyboardScroll({ scope, send, context }) {
        const win = scope.getWin();
        const onKeyDown = (event) => {
          switch (event.key) {
            case "ArrowRight":
              event.preventDefault();
              send({ type: "PAGE.NEXT" });
              break;
            case "ArrowLeft":
              event.preventDefault();
              send({ type: "PAGE.PREV" });
              break;
            case "Home":
              event.preventDefault();
              send({ type: "PAGE.SET", index: 0 });
              break;
            case "End":
              event.preventDefault();
              send({ type: "PAGE.SET", index: context.get("pageSnapPoints").length - 1 });
          }
        };
        return addDomEvent(win, "keydown", onKeyDown, { capture: true });
      }
    },
    actions: {
      clearScrollEndTimer({ refs }) {
        if (refs.get("timeoutRef") == null) return;
        clearTimeout(refs.get("timeoutRef"));
        refs.set("timeoutRef", void 0);
      },
      scrollToPage({ context, event, scope, computed, flush: flush2 }) {
        const behavior = event.instant ? "instant" : "smooth";
        const index = clampValue(event.index ?? context.get("page"), 0, context.get("pageSnapPoints").length - 1);
        const el = getItemGroupEl(scope);
        if (!el) return;
        const axis = computed("isHorizontal") ? "left" : "top";
        flush2(() => {
          el.scrollTo({ [axis]: context.get("pageSnapPoints")[index], behavior });
        });
      },
      setClosestPage({ context, scope, computed }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const scrollPosition = computed("isHorizontal") ? el.scrollLeft : el.scrollTop;
        const page = context.get("pageSnapPoints").findIndex((point) => Math.abs(point - scrollPosition) < 1);
        if (page === -1) return;
        context.set("page", page);
      },
      setNextPage({ context, prop, state: state3 }) {
        const loop = state3.matches("autoplay") || prop("loop");
        const page = nextIndex(context.get("pageSnapPoints"), context.get("page"), { loop });
        context.set("page", page);
      },
      setPrevPage({ context, prop, state: state3 }) {
        const loop = state3.matches("autoplay") || prop("loop");
        const page = prevIndex(context.get("pageSnapPoints"), context.get("page"), { loop });
        context.set("page", page);
      },
      setMatchingPage({ context, event, computed, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const snapPoint = findSnapPoint(
          el,
          computed("isHorizontal") ? "x" : "y",
          (node) => node.dataset.index === event.index.toString()
        );
        if (snapPoint == null) return;
        const page = context.get("pageSnapPoints").findIndex((point) => Math.abs(point - snapPoint) < 1);
        context.set("page", page);
      },
      setPage({ context, event }) {
        const page = event.index ?? context.get("page");
        context.set("page", page);
      },
      clampPage({ context }) {
        const index = clampValue(context.get("page"), 0, context.get("pageSnapPoints").length - 1);
        context.set("page", index);
      },
      setSnapPoints({ context, computed, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const scrollSnapPoints = getScrollSnapPositions(el);
        context.set("pageSnapPoints", computed("isHorizontal") ? scrollSnapPoints.x : scrollSnapPoints.y);
      },
      disableScrollSnap({ scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const styles = getComputedStyle(el);
        el.dataset.scrollSnapType = styles.getPropertyValue("scroll-snap-type");
        el.style.setProperty("scroll-snap-type", "none");
      },
      scrollSlides({ scope, event }) {
        const el = getItemGroupEl(scope);
        el?.scrollBy({ left: event.left, top: event.top, behavior: "instant" });
      },
      endDragging({ scope, context, computed }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const isHorizontal = computed("isHorizontal");
        const scrollPos = isHorizontal ? el.scrollLeft : el.scrollTop;
        const snapPoints = context.get("pageSnapPoints");
        const closest = snapPoints.reduce((closest2, curr) => {
          return Math.abs(curr - scrollPos) < Math.abs(closest2 - scrollPos) ? curr : closest2;
        }, snapPoints[0]);
        raf(() => {
          el.scrollTo({
            left: isHorizontal ? closest : el.scrollLeft,
            top: isHorizontal ? el.scrollTop : closest,
            behavior: "smooth"
          });
          context.set("page", snapPoints.indexOf(closest));
          const scrollSnapType = el.dataset.scrollSnapType;
          if (scrollSnapType) {
            el.style.setProperty("scroll-snap-type", scrollSnapType);
            delete el.dataset.scrollSnapType;
          }
        });
      },
      focusIndicatorEl({ context, event, scope }) {
        if (event.src !== "indicator") return;
        const el = getIndicatorEl(scope, context.get("page"));
        if (!el) return;
        raf(() => el.focus({ preventScroll: true }));
      },
      invokeDragStart({ context, prop }) {
        prop("onDragStatusChange")?.({ type: "dragging.start", isDragging: true, page: context.get("page") });
      },
      invokeDragging({ context, prop }) {
        prop("onDragStatusChange")?.({ type: "dragging", isDragging: true, page: context.get("page") });
      },
      invokeDraggingEnd({ context, prop }) {
        prop("onDragStatusChange")?.({ type: "dragging.end", isDragging: false, page: context.get("page") });
      },
      invokeAutoplay({ context, prop }) {
        prop("onAutoplayStatusChange")?.({ type: "autoplay", isPlaying: true, page: context.get("page") });
      },
      invokeAutoplayStart({ context, prop }) {
        prop("onAutoplayStatusChange")?.({ type: "autoplay.start", isPlaying: true, page: context.get("page") });
      },
      invokeAutoplayEnd({ context, prop }) {
        prop("onAutoplayStatusChange")?.({ type: "autoplay.stop", isPlaying: false, page: context.get("page") });
      }
    }
  }
});
function getPageSnapPoints(totalSlides, slidesPerMove, slidesPerPage) {
  if (totalSlides == null || slidesPerPage <= 0) {
    return [];
  }
  const snapPoints = [];
  const perMove = slidesPerMove === "auto" ? Math.floor(slidesPerPage) : slidesPerMove;
  if (perMove <= 0) {
    return [];
  }
  for (let i = 0; i < totalSlides; i += perMove) {
    if (i + slidesPerPage > totalSlides) break;
    snapPoints.push(i);
  }
  return snapPoints;
}
var props3 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loop",
  "page",
  "defaultPage",
  "onPageChange",
  "orientation",
  "slideCount",
  "slidesPerPage",
  "slidesPerMove",
  "spacing",
  "padding",
  "autoplay",
  "allowMouseDrag",
  "inViewThreshold",
  "translations",
  "snapType",
  "autoSize",
  "onDragStatusChange",
  "onAutoplayStatusChange"
]);
var splitProps4 = createSplitProps(props3);
var indicatorProps = createProps()(["index", "readOnly"]);
var splitIndicatorProps = createSplitProps(indicatorProps);
var itemProps2 = createProps()(["index", "snapAlign"]);
var splitItemProps2 = createSplitProps(itemProps2);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/indicator.svelte
Indicator[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/indicator.svelte";
var root_218 = add_locations(from_html(`<button><!></button>`), Indicator[FILENAME], [[27, 1]]);
function Indicator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Indicator);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const $$d = user_derived(() => splitIndicatorProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), indicatorProps2 = tag(user_derived(() => get($$array)[0]), "indicatorProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(carousel().getIndicatorProps(get(indicatorProps2)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Indicator, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_218();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Indicator, 28, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Indicator,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Indicator = hmr(Indicator);
  import.meta.hot.accept((module) => {
    Indicator[HMR].update(module.default);
  });
}
var indicator_default = Indicator;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/indicator-group.svelte
Indicator_group[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/indicator-group.svelte";
var root_219 = add_locations(from_html(`<div><!></div>`), Indicator_group[FILENAME], [[24, 1]]);
function Indicator_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Indicator_group);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(carousel().getIndicatorGroupProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Indicator_group, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_219();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Indicator_group, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Indicator_group,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Indicator_group = hmr(Indicator_group);
  import.meta.hot.accept((module) => {
    Indicator_group[HMR].update(module.default);
  });
}
var indicator_group_default = Indicator_group;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/item.svelte
Item2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/item.svelte";
var root_220 = add_locations(from_html(`<div><!></div>`), Item2[FILENAME], [[27, 1]]);
function Item2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const $$d = user_derived(() => splitItemProps2(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(carousel().getItemProps(get(itemProps13)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item2, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_220();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item2, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item2,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item2 = hmr(Item2);
  import.meta.hot.accept((module) => {
    Item2[HMR].update(module.default);
  });
}
var item_default2 = Item2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/item-group.svelte
Item_group[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/item-group.svelte";
var root_221 = add_locations(from_html(`<div><!></div>`), Item_group[FILENAME], [[24, 1]]);
function Item_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_group);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(carousel().getItemGroupProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_group, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_221();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_group, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_group,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_group = hmr(Item_group);
  import.meta.hot.accept((module) => {
    Item_group[HMR].update(module.default);
  });
}
var item_group_default = Item_group;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/next-trigger.svelte
Next_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/next-trigger.svelte";
var root_222 = add_locations(from_html(`<button><!></button>`), Next_trigger[FILENAME], [[24, 1]]);
function Next_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Next_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(carousel().getNextTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Next_trigger, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_222();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Next_trigger, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Next_trigger,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Next_trigger = hmr(Next_trigger);
  import.meta.hot.accept((module) => {
    Next_trigger[HMR].update(module.default);
  });
}
var next_trigger_default = Next_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/prev-trigger.svelte
Prev_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/prev-trigger.svelte";
var root_223 = add_locations(from_html(`<button><!></button>`), Prev_trigger[FILENAME], [[24, 1]]);
function Prev_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Prev_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(carousel().getPrevTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Prev_trigger, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_223();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Prev_trigger, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Prev_trigger,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Prev_trigger = hmr(Prev_trigger);
  import.meta.hot.accept((module) => {
    Prev_trigger[HMR].update(module.default);
  });
}
var prev_trigger_default = Prev_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/progress-text.svelte
Progress_text[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/progress-text.svelte";
var root_224 = add_locations(from_html(`<div><!></div>`), Progress_text[FILENAME], [[24, 1]]);
function Progress_text($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Progress_text);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(carousel().getProgressTextProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Progress_text, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_224();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Progress_text, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Progress_text,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Progress_text = hmr(Progress_text);
  import.meta.hot.accept((module) => {
    Progress_text[HMR].update(module.default);
  });
}
var progress_text_default = Progress_text;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/root-context.svelte
Root_context3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/root-context.svelte";
function Root_context3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const carousel = RootContext3.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => carousel), "render", Root_context3, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context3 = hmr(Root_context3);
  import.meta.hot.accept((module) => {
    Root_context3[HMR].update(module.default);
  });
}
var root_context_default3 = Root_context3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/root-provider.svelte
Root_provider3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/root-provider.svelte";
var root_225 = add_locations(from_html(`<div><!></div>`), Root_provider3[FILENAME], [[26, 1]]);
function Root_provider3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), carousel = tag(user_derived(() => $$props.value), "carousel"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(carousel)().getRootProps(), get(rest))), "attributes");
  RootContext3.provide(() => get(carousel)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider3, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_225();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider3, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider3,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider3 = hmr(Root_provider3);
  import.meta.hot.accept((module) => {
    Root_provider3[HMR].update(module.default);
  });
}
var root_provider_default3 = Root_provider3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/modules/provider.svelte.js
function useCarousel(props25) {
  const service = useMachine(machine3, props25);
  const carousel = tag(user_derived(() => connect3(service, normalizeProps)), "carousel");
  return () => get(carousel);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/root.svelte
Root4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/anatomy/root.svelte";
var root_226 = add_locations(from_html(`<div><!></div>`), Root4[FILENAME], [[34, 1]]);
function Root4($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps4(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), carouselProps = tag(user_derived(() => get($$array)[0]), "carouselProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const carousel = useCarousel(() => ({ ...get(carouselProps), slideCount: $$props.slideCount, id }));
  const attributes = tag(user_derived(() => mergeProps2(carousel().getRootProps(), get(rest))), "attributes");
  RootContext3.provide(() => carousel());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root4, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_226();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root4, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root4,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root4 = hmr(Root4);
  import.meta.hot.accept((module) => {
    Root4[HMR].update(module.default);
  });
}
var root_default4 = Root4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/carousel/modules/anatomy.js
var Carousel = Object.assign(root_default4, {
  Provider: root_provider_default3,
  Context: root_context_default3,
  Control: control_default,
  ItemGroup: item_group_default,
  Item: item_default2,
  PrevTrigger: prev_trigger_default,
  NextTrigger: next_trigger_default,
  AutoplayTrigger: autoplay_trigger_default,
  IndicatorGroup: indicator_group_default,
  Indicator: indicator_default,
  ProgressText: progress_text_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/modules/root-context.js
var RootContext4 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/content.svelte
Content[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/content.svelte";
var root_227 = add_locations(from_html(`<div><!></div>`), Content[FILENAME], [[24, 1]]);
function Content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const collapsible = RootContext4.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(collapsible().getContentProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_227();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content = hmr(Content);
  import.meta.hot.accept((module) => {
    Content[HMR].update(module.default);
  });
}
var content_default = Content;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/indicator.svelte
Indicator2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/indicator.svelte";
var root_228 = add_locations(from_html(`<div><!></div>`), Indicator2[FILENAME], [[24, 1]]);
function Indicator2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Indicator2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const collapsible = RootContext4.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(collapsible().getIndicatorProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Indicator2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_228();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Indicator2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Indicator2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Indicator2 = hmr(Indicator2);
  import.meta.hot.accept((module) => {
    Indicator2[HMR].update(module.default);
  });
}
var indicator_default2 = Indicator2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/root-context.svelte
Root_context4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/root-context.svelte";
function Root_context4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const collapsible = RootContext4.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => collapsible), "render", Root_context4, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context4 = hmr(Root_context4);
  import.meta.hot.accept((module) => {
    Root_context4[HMR].update(module.default);
  });
}
var root_context_default4 = Root_context4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/root-provider.svelte
Root_provider4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/root-provider.svelte";
var root_229 = add_locations(from_html(`<div><!></div>`), Root_provider4[FILENAME], [[27, 1]]);
function Root_provider4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), collapsible = tag(user_derived(() => $$props.value), "collapsible"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(collapsible)().getRootProps(), get(rest))), "attributes");
  RootContext4.provide(() => get(collapsible)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider4, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_229();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider4, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider4,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider4 = hmr(Root_provider4);
  import.meta.hot.accept((module) => {
    Root_provider4[HMR].update(module.default);
  });
}
var root_provider_default4 = Root_provider4;

// node_modules/@zag-js/collapsible/dist/index.mjs
var anatomy4 = createAnatomy("collapsible").parts("root", "trigger", "content", "indicator");
var parts4 = anatomy4.build();
var getRootId4 = (ctx) => ctx.ids?.root ?? `collapsible:${ctx.id}`;
var getContentId = (ctx) => ctx.ids?.content ?? `collapsible:${ctx.id}:content`;
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `collapsible:${ctx.id}:trigger`;
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));
function connect4(service, normalize2) {
  const { state: state3, send, context, scope, prop } = service;
  const visible = state3.matches("open") || state3.matches("closing");
  const open = state3.matches("open");
  const closed = state3.matches("closed");
  const { width, height } = context.get("size");
  const disabled = !!prop("disabled");
  const collapsedHeight = prop("collapsedHeight");
  const collapsedWidth = prop("collapsedWidth");
  const hasCollapsedHeight = collapsedHeight != null;
  const hasCollapsedWidth = collapsedWidth != null;
  const hasCollapsedSize = hasCollapsedHeight || hasCollapsedWidth;
  const skip = !context.get("initial") && open;
  return {
    disabled,
    visible,
    open,
    measureSize() {
      send({ type: "size.measure" });
    },
    setOpen(nextOpen) {
      const open2 = state3.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "open" : "close" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts4.root.attrs,
        "data-state": open ? "open" : "closed",
        dir: prop("dir"),
        id: getRootId4(scope)
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts4.content.attrs,
        id: getContentId(scope),
        "data-collapsible": "",
        "data-state": skip ? void 0 : open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-has-collapsed-size": dataAttr(hasCollapsedSize),
        hidden: !visible && !hasCollapsedSize,
        dir: prop("dir"),
        style: {
          "--height": toPx(height),
          "--width": toPx(width),
          "--collapsed-height": toPx(collapsedHeight),
          "--collapsed-width": toPx(collapsedWidth),
          ...closed && hasCollapsedHeight && {
            overflow: "hidden",
            minHeight: toPx(collapsedHeight),
            maxHeight: toPx(collapsedHeight)
          },
          ...closed && hasCollapsedWidth && {
            overflow: "hidden",
            minWidth: toPx(collapsedWidth),
            maxWidth: toPx(collapsedWidth)
          }
        }
      });
    },
    getTriggerProps() {
      return normalize2.element({
        ...parts4.trigger.attrs,
        id: getTriggerId(scope),
        dir: prop("dir"),
        type: "button",
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "aria-controls": getContentId(scope),
        "aria-expanded": visible || false,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: open ? "close" : "open" });
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts4.indicator.attrs,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled)
      });
    }
  };
}
var machine4 = createMachine({
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable: bindable2 }) {
    return {
      size: bindable2(() => ({
        defaultValue: { height: 0, width: 0 },
        sync: true
      })),
      initial: bindable2(() => ({
        defaultValue: false
      }))
    };
  },
  refs() {
    return {
      cleanup: void 0,
      stylesRef: void 0
    };
  },
  watch({ track: track2, prop, action }) {
    track2([() => prop("open")], () => {
      action(["setInitial", "computeSize", "toggleVisibility"]);
    });
  },
  exit: ["cleanupNode"],
  states: {
    closed: {
      effects: ["trackTabbableElements"],
      on: {
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitial", "computeSize", "invokeOnOpen"]
          }
        ]
      }
    },
    closing: {
      effects: ["trackExitAnimation"],
      on: {
        "controlled.close": {
          target: "closed"
        },
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitial", "invokeOnOpen"]
          }
        ],
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnExitComplete"]
          },
          {
            target: "closed",
            actions: ["setInitial", "computeSize", "invokeOnExitComplete"]
          }
        ],
        "animation.end": {
          target: "closed",
          actions: ["invokeOnExitComplete", "clearInitial"]
        }
      }
    },
    open: {
      effects: ["trackEnterAnimation"],
      on: {
        "controlled.close": {
          target: "closing"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closing",
            actions: ["setInitial", "computeSize", "invokeOnClose"]
          }
        ],
        "size.measure": {
          actions: ["measureSize"]
        },
        "animation.end": {
          actions: ["clearInitial"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackEnterAnimation: ({ send, scope }) => {
        let cleanup;
        const rafCleanup = raf(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const animationName = getComputedStyle2(contentEl).animationName;
          const hasNoAnimation = !animationName || animationName === "none";
          if (hasNoAnimation) {
            send({ type: "animation.end" });
            return;
          }
          const onEnd = (event) => {
            const target = getEventTarget(event);
            if (target === contentEl) {
              send({ type: "animation.end" });
            }
          };
          contentEl.addEventListener("animationend", onEnd);
          cleanup = () => {
            contentEl.removeEventListener("animationend", onEnd);
          };
        });
        return () => {
          rafCleanup();
          cleanup?.();
        };
      },
      trackExitAnimation: ({ send, scope }) => {
        let cleanup;
        const rafCleanup = raf(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const animationName = getComputedStyle2(contentEl).animationName;
          const hasNoAnimation = !animationName || animationName === "none";
          if (hasNoAnimation) {
            send({ type: "animation.end" });
            return;
          }
          const onEnd = (event) => {
            const target = getEventTarget(event);
            if (target === contentEl) {
              send({ type: "animation.end" });
            }
          };
          contentEl.addEventListener("animationend", onEnd);
          const restoreStyles = setStyle(contentEl, {
            animationFillMode: "forwards"
          });
          cleanup = () => {
            contentEl.removeEventListener("animationend", onEnd);
            nextTick(() => restoreStyles());
          };
        });
        return () => {
          rafCleanup();
          cleanup?.();
        };
      },
      trackTabbableElements: ({ scope, prop }) => {
        if (!prop("collapsedHeight") && !prop("collapsedWidth")) return;
        const contentEl = getContentEl(scope);
        if (!contentEl) return;
        const applyInertToTabbables = () => {
          const tabbables = getTabbables(contentEl);
          const restoreAttrs = tabbables.map((tabbable) => setAttribute(tabbable, "inert", ""));
          return () => {
            restoreAttrs.forEach((attr) => attr());
          };
        };
        let restoreInert = applyInertToTabbables();
        const observerCleanup = observeChildren(contentEl, {
          callback() {
            restoreInert();
            restoreInert = applyInertToTabbables();
          }
        });
        return () => {
          restoreInert();
          observerCleanup();
        };
      }
    },
    actions: {
      setInitial: ({ context, flush: flush2 }) => {
        flush2(() => {
          context.set("initial", true);
        });
      },
      clearInitial: ({ context }) => {
        context.set("initial", false);
      },
      cleanupNode: ({ refs }) => {
        refs.set("stylesRef", null);
      },
      measureSize: ({ context, scope }) => {
        const contentEl = getContentEl(scope);
        if (!contentEl) return;
        const { height, width } = contentEl.getBoundingClientRect();
        context.set("size", { height, width });
      },
      computeSize: ({ refs, scope, context }) => {
        refs.get("cleanup")?.();
        const rafCleanup = raf(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const hidden = contentEl.hidden;
          contentEl.style.animationName = "none";
          contentEl.style.animationDuration = "0s";
          contentEl.hidden = false;
          const rect = contentEl.getBoundingClientRect();
          context.set("size", { height: rect.height, width: rect.width });
          if (context.get("initial")) {
            contentEl.style.animationName = "";
            contentEl.style.animationDuration = "";
          }
          contentEl.hidden = hidden;
        });
        refs.set("cleanup", rafCleanup);
      },
      invokeOnOpen: ({ prop }) => {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose: ({ prop }) => {
        prop("onOpenChange")?.({ open: false });
      },
      invokeOnExitComplete: ({ prop }) => {
        prop("onExitComplete")?.();
      },
      toggleVisibility: ({ prop, send }) => {
        send({ type: prop("open") ? "controlled.open" : "controlled.close" });
      }
    }
  }
});
var props4 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "collapsedHeight",
  "collapsedWidth",
  "onExitComplete",
  "onOpenChange",
  "defaultOpen",
  "open"
]);
var splitProps5 = createSplitProps(props4);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/modules/provider.svelte.js
function useCollapsible(props25) {
  const service = useMachine(machine4, props25);
  const collapsible = tag(user_derived(() => connect4(service, normalizeProps)), "collapsible");
  return () => get(collapsible);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/root.svelte
Root5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/root.svelte";
var root_230 = add_locations(from_html(`<div><!></div>`), Root5[FILENAME], [[34, 1]]);
function Root5($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps5(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), collapsibleProps = tag(user_derived(() => get($$array)[0]), "collapsibleProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const collapsible = useCollapsible(() => ({ ...get(collapsibleProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(collapsible().getRootProps(), get(rest))), "attributes");
  RootContext4.provide(() => collapsible());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root5, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_230();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root5, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root5,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root5 = hmr(Root5);
  import.meta.hot.accept((module) => {
    Root5[HMR].update(module.default);
  });
}
var root_default5 = Root5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/trigger.svelte
Trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/anatomy/trigger.svelte";
var root_231 = add_locations(from_html(`<button><!></button>`), Trigger[FILENAME], [[24, 1]]);
function Trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const collapsible = RootContext4.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(collapsible().getTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_231();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger = hmr(Trigger);
  import.meta.hot.accept((module) => {
    Trigger[HMR].update(module.default);
  });
}
var trigger_default = Trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/collapsible/modules/anatomy.js
var Collapsible = Object.assign(root_default5, {
  Provider: root_provider_default4,
  Context: root_context_default4,
  Trigger: trigger_default,
  Indicator: indicator_default2,
  Content: content_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/modules/root-context.js
var RootContext5 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/clear-trigger.svelte
Clear_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/clear-trigger.svelte";
var root_232 = add_locations(from_html(`<button><!></button>`), Clear_trigger[FILENAME], [[24, 1]]);
function Clear_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Clear_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getClearTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Clear_trigger, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_232();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Clear_trigger, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Clear_trigger,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Clear_trigger = hmr(Clear_trigger);
  import.meta.hot.accept((module) => {
    Clear_trigger[HMR].update(module.default);
  });
}
var clear_trigger_default = Clear_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/content.svelte
Content2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/content.svelte";
var root_233 = add_locations(from_html(`<ul><!></ul>`), Content2[FILENAME], [[24, 1]]);
function Content2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getContentProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var ul = root_233();
      attribute_effect(ul, () => ({ ...get(attributes) }));
      var node_2 = child(ul);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content2, 25, 2);
      reset(ul);
      append($$anchor2, ul);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content2 = hmr(Content2);
  import.meta.hot.accept((module) => {
    Content2[HMR].update(module.default);
  });
}
var content_default2 = Content2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/control.svelte
Control2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/control.svelte";
var root_234 = add_locations(from_html(`<div><!></div>`), Control2[FILENAME], [[24, 1]]);
function Control2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getControlProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Control2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_234();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Control2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Control2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Control2 = hmr(Control2);
  import.meta.hot.accept((module) => {
    Control2[HMR].update(module.default);
  });
}
var control_default2 = Control2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/input.svelte
Input[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/input.svelte";
var root_235 = add_locations(from_html(`<input/>`), Input[FILENAME], [[24, 1]]);
function Input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Input);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getInputProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Input, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_235();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Input,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Input = hmr(Input);
  import.meta.hot.accept((module) => {
    Input[HMR].update(module.default);
  });
}
var input_default = Input;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/modules/item-group-context.js
var ItemGroupContext = createContext();

// node_modules/@zag-js/collection/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback2 = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject(item) && hasProp(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject(item) && hasProp(item, "label")) return item.label;
    return fallback2.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject(item) && hasProp(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var ListCollection = class _ListCollection {
  constructor(options) {
    this.options = options;
    __publicField3(this, "items");
    __publicField3(this, "indexMap", null);
    __publicField3(this, "copy", (items) => {
      return new _ListCollection({ ...this.options, items: items ?? [...this.items] });
    });
    __publicField3(this, "isEqual", (other) => {
      return isEqual(this.items, other.items);
    });
    __publicField3(this, "setItems", (items) => {
      return this.copy(items);
    });
    __publicField3(this, "getValues", (items = this.items) => {
      const values = [];
      for (const item of items) {
        const value = this.getItemValue(item);
        if (value != null) values.push(value);
      }
      return values;
    });
    __publicField3(this, "find", (value) => {
      if (value == null) return null;
      const index = this.indexOf(value);
      return index !== -1 ? this.at(index) : null;
    });
    __publicField3(this, "findMany", (values) => {
      const result = [];
      for (const value of values) {
        const item = this.find(value);
        if (item != null) result.push(item);
      }
      return result;
    });
    __publicField3(this, "at", (index) => {
      if (!this.options.groupBy && !this.options.groupSort) {
        return this.items[index] ?? null;
      }
      let idx = 0;
      const groups = this.group();
      for (const [, items] of groups) {
        for (const item of items) {
          if (idx === index) return item;
          idx++;
        }
      }
      return null;
    });
    __publicField3(this, "sortFn", (valueA, valueB) => {
      const indexA = this.indexOf(valueA);
      const indexB = this.indexOf(valueB);
      return (indexA ?? 0) - (indexB ?? 0);
    });
    __publicField3(this, "sort", (values) => {
      return [...values].sort(this.sortFn.bind(this));
    });
    __publicField3(this, "getItemValue", (item) => {
      if (item == null) return null;
      return this.options.itemToValue?.(item) ?? fallback2.itemToValue(item);
    });
    __publicField3(this, "getItemDisabled", (item) => {
      if (item == null) return false;
      return this.options.isItemDisabled?.(item) ?? fallback2.isItemDisabled(item);
    });
    __publicField3(this, "stringifyItem", (item) => {
      if (item == null) return null;
      return this.options.itemToString?.(item) ?? fallback2.itemToString(item);
    });
    __publicField3(this, "stringify", (value) => {
      if (value == null) return null;
      return this.stringifyItem(this.find(value));
    });
    __publicField3(this, "stringifyItems", (items, separator = ", ") => {
      const strs = [];
      for (const item of items) {
        const str = this.stringifyItem(item);
        if (str != null) strs.push(str);
      }
      return strs.join(separator);
    });
    __publicField3(this, "stringifyMany", (value, separator) => {
      return this.stringifyItems(this.findMany(value), separator);
    });
    __publicField3(this, "has", (value) => {
      return this.indexOf(value) !== -1;
    });
    __publicField3(this, "hasItem", (item) => {
      if (item == null) return false;
      return this.has(this.getItemValue(item));
    });
    __publicField3(this, "group", () => {
      const { groupBy, groupSort } = this.options;
      if (!groupBy) return [["", [...this.items]]];
      const groups = /* @__PURE__ */ new Map();
      this.items.forEach((item, index) => {
        const groupKey = groupBy(item, index);
        if (!groups.has(groupKey)) {
          groups.set(groupKey, []);
        }
        groups.get(groupKey).push(item);
      });
      let entries = Array.from(groups.entries());
      if (groupSort) {
        entries.sort(([a], [b]) => {
          if (typeof groupSort === "function") return groupSort(a, b);
          if (Array.isArray(groupSort)) {
            const indexA = groupSort.indexOf(a);
            const indexB = groupSort.indexOf(b);
            if (indexA === -1) return 1;
            if (indexB === -1) return -1;
            return indexA - indexB;
          }
          if (groupSort === "asc") return a.localeCompare(b);
          if (groupSort === "desc") return b.localeCompare(a);
          return 0;
        });
      }
      return entries;
    });
    __publicField3(this, "getNextValue", (value, step = 1, clamp4 = false) => {
      let index = this.indexOf(value);
      if (index === -1) return null;
      index = clamp4 ? Math.min(index + step, this.size - 1) : index + step;
      while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
      return this.getItemValue(this.at(index));
    });
    __publicField3(this, "getPreviousValue", (value, step = 1, clamp4 = false) => {
      let index = this.indexOf(value);
      if (index === -1) return null;
      index = clamp4 ? Math.max(index - step, 0) : index - step;
      while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
      return this.getItemValue(this.at(index));
    });
    __publicField3(this, "indexOf", (value) => {
      if (value == null) return -1;
      if (!this.options.groupBy && !this.options.groupSort) {
        return this.items.findIndex((item) => this.getItemValue(item) === value);
      }
      if (!this.indexMap) {
        this.indexMap = /* @__PURE__ */ new Map();
        let idx = 0;
        const groups = this.group();
        for (const [, items] of groups) {
          for (const item of items) {
            const itemValue = this.getItemValue(item);
            if (itemValue != null) {
              this.indexMap.set(itemValue, idx);
            }
            idx++;
          }
        }
      }
      return this.indexMap.get(value) ?? -1;
    });
    __publicField3(this, "getByText", (text2, current) => {
      const currentIndex = current != null ? this.indexOf(current) : -1;
      const isSingleKey = text2.length === 1;
      for (let i = 0; i < this.items.length; i++) {
        const item = this.items[(currentIndex + i + 1) % this.items.length];
        if (isSingleKey && this.getItemValue(item) === current) continue;
        if (this.getItemDisabled(item)) continue;
        if (match3(this.stringifyItem(item), text2)) return item;
      }
      return void 0;
    });
    __publicField3(this, "search", (queryString, options2) => {
      const { state: state3, currentValue, timeout = 350 } = options2;
      const search = state3.keysSoFar + queryString;
      const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
      const query2 = isRepeated ? search[0] : search;
      const item = this.getByText(query2, currentValue);
      const value = this.getItemValue(item);
      function cleanup() {
        clearTimeout(state3.timer);
        state3.timer = -1;
      }
      function update(value2) {
        state3.keysSoFar = value2;
        cleanup();
        if (value2 !== "") {
          state3.timer = +setTimeout(() => {
            update("");
            cleanup();
          }, timeout);
        }
      }
      update(search);
      return value;
    });
    __publicField3(this, "update", (value, item) => {
      let index = this.indexOf(value);
      if (index === -1) return this;
      return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);
    });
    __publicField3(this, "upsert", (value, item, mode = "append") => {
      let index = this.indexOf(value);
      if (index === -1) {
        const fn = mode === "append" ? this.append : this.prepend;
        return fn(item);
      }
      return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);
    });
    __publicField3(this, "insert", (index, ...items) => {
      return this.copy(insert(this.items, index, ...items));
    });
    __publicField3(this, "insertBefore", (value, ...items) => {
      let toIndex = this.indexOf(value);
      if (toIndex === -1) {
        if (this.items.length === 0) toIndex = 0;
        else return this;
      }
      return this.copy(insert(this.items, toIndex, ...items));
    });
    __publicField3(this, "insertAfter", (value, ...items) => {
      let toIndex = this.indexOf(value);
      if (toIndex === -1) {
        if (this.items.length === 0) toIndex = 0;
        else return this;
      }
      return this.copy(insert(this.items, toIndex + 1, ...items));
    });
    __publicField3(this, "prepend", (...items) => {
      return this.copy(insert(this.items, 0, ...items));
    });
    __publicField3(this, "append", (...items) => {
      return this.copy(insert(this.items, this.items.length, ...items));
    });
    __publicField3(this, "filter", (fn) => {
      const filteredItems = this.items.filter((item, index) => fn(this.stringifyItem(item), index, item));
      return this.copy(filteredItems);
    });
    __publicField3(this, "remove", (...itemsOrValues) => {
      const values = itemsOrValues.map(
        (itemOrValue) => typeof itemOrValue === "string" ? itemOrValue : this.getItemValue(itemOrValue)
      );
      return this.copy(
        this.items.filter((item) => {
          const value = this.getItemValue(item);
          if (value == null) return false;
          return !values.includes(value);
        })
      );
    });
    __publicField3(this, "move", (value, toIndex) => {
      const fromIndex = this.indexOf(value);
      if (fromIndex === -1) return this;
      return this.copy(move(this.items, [fromIndex], toIndex));
    });
    __publicField3(this, "moveBefore", (value, ...values) => {
      let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);
      if (toIndex === -1) return this;
      let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a, b) => a - b);
      return this.copy(move(this.items, indices, toIndex));
    });
    __publicField3(this, "moveAfter", (value, ...values) => {
      let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);
      if (toIndex === -1) return this;
      let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a, b) => a - b);
      return this.copy(move(this.items, indices, toIndex + 1));
    });
    __publicField3(this, "reorder", (fromIndex, toIndex) => {
      return this.copy(move(this.items, [fromIndex], toIndex));
    });
    __publicField3(this, "compareValue", (a, b) => {
      const indexA = this.indexOf(a);
      const indexB = this.indexOf(b);
      if (indexA < indexB) return -1;
      if (indexA > indexB) return 1;
      return 0;
    });
    __publicField3(this, "range", (from, to) => {
      let keys = [];
      let key = from;
      while (key != null) {
        let item = this.find(key);
        if (item) keys.push(key);
        if (key === to) return keys;
        key = this.getNextValue(key);
      }
      return [];
    });
    __publicField3(this, "getValueRange", (from, to) => {
      if (from && to) {
        if (this.compareValue(from, to) <= 0) {
          return this.range(from, to);
        }
        return this.range(to, from);
      }
      return [];
    });
    __publicField3(this, "toString", () => {
      let result = "";
      for (const item of this.items) {
        const value = this.getItemValue(item);
        const label = this.stringifyItem(item);
        const disabled = this.getItemDisabled(item);
        const itemString = [value, label, disabled].filter(Boolean).join(":");
        result += itemString + ",";
      }
      return result;
    });
    __publicField3(this, "toJSON", () => {
      return {
        size: this.size,
        first: this.firstValue,
        last: this.lastValue
      };
    });
    this.items = [...options.items];
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
};
var match3 = (label, query2) => {
  return !!label?.toLowerCase().startsWith(query2.toLowerCase());
};
function insert(items, index, ...values) {
  return [...items.slice(0, index), ...values, ...items.slice(index)];
}
function move(items, indices, toIndex) {
  indices = [...indices].sort((a, b) => a - b);
  const itemsToMove = indices.map((i) => items[i]);
  for (let i = indices.length - 1; i >= 0; i--) {
    items = [...items.slice(0, indices[i]), ...items.slice(indices[i] + 1)];
  }
  toIndex = Math.max(0, toIndex - indices.filter((i) => i < toIndex).length);
  return [...items.slice(0, toIndex), ...itemsToMove, ...items.slice(toIndex)];
}
var GridCollection = class extends ListCollection {
  constructor(options) {
    const { columnCount } = options;
    super(options);
    __publicField3(this, "columnCount");
    __publicField3(this, "rows", null);
    __publicField3(this, "getRows", () => {
      if (!this.rows) {
        this.rows = chunk([...this.items], this.columnCount);
      }
      return this.rows;
    });
    __publicField3(this, "getRowCount", () => {
      return Math.ceil(this.items.length / this.columnCount);
    });
    __publicField3(this, "getCellIndex", (row, column) => {
      return row * this.columnCount + column;
    });
    __publicField3(this, "getCell", (row, column) => {
      return this.at(this.getCellIndex(row, column));
    });
    __publicField3(this, "getValueCell", (value) => {
      const index = this.indexOf(value);
      if (index === -1) return null;
      const row = Math.floor(index / this.columnCount);
      const column = index % this.columnCount;
      return { row, column };
    });
    __publicField3(this, "getLastEnabledColumnIndex", (row) => {
      for (let col = this.columnCount - 1; col >= 0; col--) {
        const cell = this.getCell(row, col);
        if (cell && !this.getItemDisabled(cell)) {
          return col;
        }
      }
      return null;
    });
    __publicField3(this, "getFirstEnabledColumnIndex", (row) => {
      for (let col = 0; col < this.columnCount; col++) {
        const cell = this.getCell(row, col);
        if (cell && !this.getItemDisabled(cell)) {
          return col;
        }
      }
      return null;
    });
    __publicField3(this, "getPreviousRowValue", (value, loop = false) => {
      const currentCell = this.getValueCell(value);
      if (currentCell === null) return null;
      const rows = this.getRows();
      const rowCount = rows.length;
      let prevRowIndex = currentCell.row;
      let prevColumnIndex = currentCell.column;
      for (let i = 1; i <= rowCount; i++) {
        prevRowIndex = prevIndex(rows, prevRowIndex, { loop });
        const prevRow = rows[prevRowIndex];
        if (!prevRow) continue;
        const prevCell = prevRow[prevColumnIndex];
        if (!prevCell) {
          const lastColumnIndex = this.getLastEnabledColumnIndex(prevRowIndex);
          if (lastColumnIndex != null) {
            prevColumnIndex = lastColumnIndex;
          }
        }
        const cell = this.getCell(prevRowIndex, prevColumnIndex);
        if (!this.getItemDisabled(cell)) {
          return this.getItemValue(cell);
        }
      }
      return this.firstValue;
    });
    __publicField3(this, "getNextRowValue", (value, loop = false) => {
      const currentCell = this.getValueCell(value);
      if (currentCell === null) return null;
      const rows = this.getRows();
      const rowCount = rows.length;
      let nextRowIndex = currentCell.row;
      let nextColumnIndex = currentCell.column;
      for (let i = 1; i <= rowCount; i++) {
        nextRowIndex = nextIndex(rows, nextRowIndex, { loop });
        const nextRow = rows[nextRowIndex];
        if (!nextRow) continue;
        const nextCell = nextRow[nextColumnIndex];
        if (!nextCell) {
          const lastColumnIndex = this.getLastEnabledColumnIndex(nextRowIndex);
          if (lastColumnIndex != null) {
            nextColumnIndex = lastColumnIndex;
          }
        }
        const cell = this.getCell(nextRowIndex, nextColumnIndex);
        if (!this.getItemDisabled(cell)) {
          return this.getItemValue(cell);
        }
      }
      return this.lastValue;
    });
    this.columnCount = columnCount;
  }
};
function isGridCollection(v) {
  return hasProp(v, "columnCount") && hasProp(v, "getRows");
}
var Selection = class _Selection extends Set {
  constructor(values = []) {
    super(values);
    __publicField3(this, "selectionMode", "single");
    __publicField3(this, "deselectable", true);
    __publicField3(this, "copy", () => {
      const clone = new _Selection([...this]);
      return this.sync(clone);
    });
    __publicField3(this, "sync", (other) => {
      other.selectionMode = this.selectionMode;
      other.deselectable = this.deselectable;
      return other;
    });
    __publicField3(this, "isEmpty", () => {
      return this.size === 0;
    });
    __publicField3(this, "isSelected", (value) => {
      if (this.selectionMode === "none" || value == null) {
        return false;
      }
      return this.has(value);
    });
    __publicField3(this, "canSelect", (collection4, value) => {
      return this.selectionMode !== "none" || !collection4.getItemDisabled(collection4.find(value));
    });
    __publicField3(this, "firstSelectedValue", (collection4) => {
      let firstValue = null;
      for (let value of this) {
        if (!firstValue || collection4.compareValue(value, firstValue) < 0) {
          firstValue = value;
        }
      }
      return firstValue;
    });
    __publicField3(this, "lastSelectedValue", (collection4) => {
      let lastValue = null;
      for (let value of this) {
        if (!lastValue || collection4.compareValue(value, lastValue) > 0) {
          lastValue = value;
        }
      }
      return lastValue;
    });
    __publicField3(this, "extendSelection", (collection4, anchorValue, targetValue) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (this.selectionMode === "single") {
        return this.replaceSelection(collection4, targetValue);
      }
      const selection = this.copy();
      const lastSelected = Array.from(this).pop();
      for (let key of collection4.getValueRange(anchorValue, lastSelected ?? targetValue)) {
        selection.delete(key);
      }
      for (let key of collection4.getValueRange(targetValue, anchorValue)) {
        if (this.canSelect(collection4, key)) {
          selection.add(key);
        }
      }
      return selection;
    });
    __publicField3(this, "toggleSelection", (collection4, value) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (this.selectionMode === "single" && !this.isSelected(value)) {
        return this.replaceSelection(collection4, value);
      }
      const selection = this.copy();
      if (selection.has(value)) {
        selection.delete(value);
      } else if (selection.canSelect(collection4, value)) {
        selection.add(value);
      }
      return selection;
    });
    __publicField3(this, "replaceSelection", (collection4, value) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (value == null) {
        return this;
      }
      if (!this.canSelect(collection4, value)) {
        return this;
      }
      const selection = new _Selection([value]);
      return this.sync(selection);
    });
    __publicField3(this, "setSelection", (values2) => {
      if (this.selectionMode === "none") {
        return this;
      }
      let selection = new _Selection();
      for (let value of values2) {
        if (value != null) {
          selection.add(value);
          if (this.selectionMode === "single") {
            break;
          }
        }
      }
      return this.sync(selection);
    });
    __publicField3(this, "clearSelection", () => {
      const selection = this.copy();
      if (selection.deselectable && selection.size > 0) {
        selection.clear();
      }
      return selection;
    });
    __publicField3(this, "select", (collection4, value, forceToggle) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (this.selectionMode === "single") {
        if (this.isSelected(value) && this.deselectable) {
          return this.toggleSelection(collection4, value);
        } else {
          return this.replaceSelection(collection4, value);
        }
      } else if (this.selectionMode === "multiple" || forceToggle) {
        return this.toggleSelection(collection4, value);
      } else {
        return this.replaceSelection(collection4, value);
      }
    });
    __publicField3(this, "deselect", (value) => {
      const selection = this.copy();
      selection.delete(value);
      return selection;
    });
    __publicField3(this, "isEqual", (other) => {
      return isEqual(Array.from(this), Array.from(other));
    });
  }
};
function access3(node, indexPath, options) {
  for (let i = 0; i < indexPath.length; i++) node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];
  return node;
}
function ancestorIndexPaths(indexPaths) {
  const sortedPaths = sortIndexPaths(indexPaths);
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const indexPath of sortedPaths) {
    const key = indexPath.join();
    if (!seen.has(key)) {
      seen.add(key);
      result.push(indexPath);
    }
  }
  return result;
}
function compareIndexPaths(a, b) {
  for (let i = 0; i < Math.min(a.length, b.length); i++) {
    if (a[i] < b[i]) return -1;
    if (a[i] > b[i]) return 1;
  }
  return a.length - b.length;
}
function sortIndexPaths(indexPaths) {
  return indexPaths.sort(compareIndexPaths);
}
function find(node, options) {
  let found;
  visit(node, {
    ...options,
    onEnter: (child2, indexPath) => {
      if (options.predicate(child2, indexPath)) {
        found = child2;
        return "stop";
      }
    }
  });
  return found;
}
function findAll(node, options) {
  const found = [];
  visit(node, {
    onEnter: (child2, indexPath) => {
      if (options.predicate(child2, indexPath)) found.push(child2);
    },
    getChildren: options.getChildren
  });
  return found;
}
function findIndexPath(node, options) {
  let found;
  visit(node, {
    onEnter: (child2, indexPath) => {
      if (options.predicate(child2, indexPath)) {
        found = [...indexPath];
        return "stop";
      }
    },
    getChildren: options.getChildren
  });
  return found;
}
function reduce(node, options) {
  let result = options.initialResult;
  visit(node, {
    ...options,
    onEnter: (child2, indexPath) => {
      result = options.nextResult(result, child2, indexPath);
    }
  });
  return result;
}
function flatMap(node, options) {
  return reduce(node, {
    ...options,
    initialResult: [],
    nextResult: (result, child2, indexPath) => {
      result.push(...options.transform(child2, indexPath));
      return result;
    }
  });
}
function filter(node, options) {
  const { predicate, create, getChildren } = options;
  const filterRecursive = (node2, indexPath) => {
    const children = getChildren(node2, indexPath);
    const filteredChildren = [];
    children.forEach((child2, index) => {
      const childIndexPath = [...indexPath, index];
      const filteredChild = filterRecursive(child2, childIndexPath);
      if (filteredChild) filteredChildren.push(filteredChild);
    });
    const isRoot = indexPath.length === 0;
    const nodeMatches = predicate(node2, indexPath);
    const hasFilteredChildren = filteredChildren.length > 0;
    if (isRoot || nodeMatches || hasFilteredChildren) {
      return create(node2, filteredChildren, indexPath);
    }
    return null;
  };
  return filterRecursive(node, []) || create(node, [], []);
}
function flatten(rootNode, options) {
  const nodes = [];
  let idx = 0;
  const idxMap = /* @__PURE__ */ new Map();
  const parentMap = /* @__PURE__ */ new Map();
  visit(rootNode, {
    getChildren: options.getChildren,
    onEnter: (node, indexPath) => {
      if (!idxMap.has(node)) {
        idxMap.set(node, idx++);
      }
      const children = options.getChildren(node, indexPath);
      children.forEach((child2) => {
        if (!parentMap.has(child2)) {
          parentMap.set(child2, node);
        }
        if (!idxMap.has(child2)) {
          idxMap.set(child2, idx++);
        }
      });
      const _children = children.length > 0 ? children.map((child2) => idxMap.get(child2)) : void 0;
      const parent = parentMap.get(node);
      const _parent = parent ? idxMap.get(parent) : void 0;
      const _index = idxMap.get(node);
      nodes.push({ ...node, _children, _parent, _index });
    }
  });
  return nodes;
}
function insertOperation(index, nodes) {
  return { type: "insert", index, nodes };
}
function removeOperation(indexes) {
  return { type: "remove", indexes };
}
function replaceOperation() {
  return { type: "replace" };
}
function splitIndexPath(indexPath) {
  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];
}
function getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */ new Map()) {
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    switch (operations.get(parentKey)?.type) {
      case "remove":
        continue;
    }
    operations.set(parentKey, replaceOperation());
  }
  const operation = operations.get(parentIndexPath.join());
  switch (operation?.type) {
    case "remove":
      operations.set(parentIndexPath.join(), {
        type: "removeThenInsert",
        removeIndexes: operation.indexes,
        insertIndex: index,
        insertNodes: nodes
      });
      break;
    default:
      operations.set(parentIndexPath.join(), insertOperation(index, nodes));
  }
  return operations;
}
function getRemovalOperations(indexPaths) {
  const operations = /* @__PURE__ */ new Map();
  const indexesToRemove = /* @__PURE__ */ new Map();
  for (const indexPath of indexPaths) {
    const parentKey = indexPath.slice(0, -1).join();
    const value = indexesToRemove.get(parentKey) ?? [];
    value.push(indexPath[indexPath.length - 1]);
    indexesToRemove.set(
      parentKey,
      value.sort((a, b) => a - b)
    );
  }
  for (const indexPath of indexPaths) {
    for (let i = indexPath.length - 2; i >= 0; i--) {
      const parentKey = indexPath.slice(0, i).join();
      if (!operations.has(parentKey)) {
        operations.set(parentKey, replaceOperation());
      }
    }
  }
  for (const [parentKey, indexes] of indexesToRemove) {
    operations.set(parentKey, removeOperation(indexes));
  }
  return operations;
}
function getReplaceOperations(indexPath, node) {
  const operations = /* @__PURE__ */ new Map();
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    operations.set(parentKey, replaceOperation());
  }
  operations.set(parentIndexPath.join(), {
    type: "removeThenInsert",
    removeIndexes: [index],
    insertIndex: index,
    insertNodes: [node]
  });
  return operations;
}
function mutate(node, operations, options) {
  return map(node, {
    ...options,
    getChildren: (node2, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation?.type) {
        case "replace":
        case "remove":
        case "removeThenInsert":
        case "insert":
          return options.getChildren(node2, indexPath);
        default:
          return [];
      }
    },
    transform: (node2, children, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation?.type) {
        case "remove":
          return options.create(
            node2,
            children.filter((_, index) => !operation.indexes.includes(index)),
            indexPath
          );
        case "removeThenInsert":
          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));
          const adjustedIndex = operation.removeIndexes.reduce(
            (index, removedIndex) => removedIndex < index ? index - 1 : index,
            operation.insertIndex
          );
          return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);
        case "insert":
          return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);
        case "replace":
          return options.create(node2, children, indexPath);
        default:
          return node2;
      }
    }
  });
}
function splice(array, start, deleteCount, ...items) {
  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];
}
function map(node, options) {
  const childrenMap = {};
  visit(node, {
    ...options,
    onLeave: (child2, indexPath) => {
      const keyIndexPath = [0, ...indexPath];
      const key = keyIndexPath.join();
      const transformed = options.transform(child2, childrenMap[key] ?? [], indexPath);
      const parentKey = keyIndexPath.slice(0, -1).join();
      const parentChildren = childrenMap[parentKey] ?? [];
      parentChildren.push(transformed);
      childrenMap[parentKey] = parentChildren;
    }
  });
  return childrenMap[""][0];
}
function insert2(node, options) {
  const { nodes, at } = options;
  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);
  const state3 = getInsertionOperations(at, nodes);
  return mutate(node, state3, options);
}
function replace(node, options) {
  if (options.at.length === 0) return options.node;
  const operations = getReplaceOperations(options.at, options.node);
  return mutate(node, operations, options);
}
function remove2(node, options) {
  if (options.indexPaths.length === 0) return node;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);
  }
  const operations = getRemovalOperations(options.indexPaths);
  return mutate(node, operations, options);
}
function move2(node, options) {
  if (options.indexPaths.length === 0) return node;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't move the root node`);
  }
  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);
  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);
  const nodesToInsert = _ancestorIndexPaths.map((indexPath) => access3(node, indexPath, options));
  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));
  return mutate(node, operations, options);
}
function visit(node, options) {
  const { onEnter, onLeave, getChildren } = options;
  let indexPath = [];
  let stack = [{ node }];
  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();
  while (stack.length > 0) {
    let wrapper = stack[stack.length - 1];
    if (wrapper.state === void 0) {
      const enterResult = onEnter?.(wrapper.node, getIndexPath());
      if (enterResult === "stop") return;
      wrapper.state = enterResult === "skip" ? -1 : 0;
    }
    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());
    wrapper.children || (wrapper.children = children);
    if (wrapper.state !== -1) {
      if (wrapper.state < children.length) {
        let currentIndex = wrapper.state;
        indexPath.push(currentIndex);
        stack.push({ node: children[currentIndex] });
        wrapper.state = currentIndex + 1;
        continue;
      }
      const leaveResult = onLeave?.(wrapper.node, getIndexPath());
      if (leaveResult === "stop") return;
    }
    indexPath.pop();
    stack.pop();
  }
}
var TreeCollection = class _TreeCollection {
  constructor(options) {
    this.options = options;
    __publicField3(this, "rootNode");
    __publicField3(this, "isEqual", (other) => {
      return isEqual(this.rootNode, other.rootNode);
    });
    __publicField3(this, "getNodeChildren", (node) => {
      return this.options.nodeToChildren?.(node) ?? fallbackMethods.nodeToChildren(node) ?? [];
    });
    __publicField3(this, "resolveIndexPath", (valueOrIndexPath) => {
      return typeof valueOrIndexPath === "string" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;
    });
    __publicField3(this, "resolveNode", (valueOrIndexPath) => {
      const indexPath = this.resolveIndexPath(valueOrIndexPath);
      return indexPath ? this.at(indexPath) : void 0;
    });
    __publicField3(this, "getNodeChildrenCount", (node) => {
      return this.options.nodeToChildrenCount?.(node) ?? fallbackMethods.nodeToChildrenCount(node);
    });
    __publicField3(this, "getNodeValue", (node) => {
      return this.options.nodeToValue?.(node) ?? fallbackMethods.nodeToValue(node);
    });
    __publicField3(this, "getNodeDisabled", (node) => {
      return this.options.isNodeDisabled?.(node) ?? fallbackMethods.isNodeDisabled(node);
    });
    __publicField3(this, "stringify", (value) => {
      const node = this.findNode(value);
      if (!node) return null;
      return this.stringifyNode(node);
    });
    __publicField3(this, "stringifyNode", (node) => {
      return this.options.nodeToString?.(node) ?? fallbackMethods.nodeToString(node);
    });
    __publicField3(this, "getFirstNode", (rootNode = this.rootNode) => {
      let firstChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {
            firstChild = node;
            return "stop";
          }
        }
      });
      return firstChild;
    });
    __publicField3(this, "getLastNode", (rootNode = this.rootNode, opts = {}) => {
      let lastChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (this.isSameNode(node, rootNode)) return;
          if (opts.skip?.({ value: this.getNodeValue(node), node, indexPath })) return "skip";
          if (indexPath.length > 0 && !this.getNodeDisabled(node)) {
            lastChild = node;
          }
        }
      });
      return lastChild;
    });
    __publicField3(this, "at", (indexPath) => {
      return access3(this.rootNode, indexPath, {
        getChildren: this.getNodeChildren
      });
    });
    __publicField3(this, "findNode", (value, rootNode = this.rootNode) => {
      return find(rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
    });
    __publicField3(this, "findNodes", (values, rootNode = this.rootNode) => {
      const v = new Set(values.filter((v2) => v2 != null));
      return findAll(rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => v.has(this.getNodeValue(node))
      });
    });
    __publicField3(this, "sort", (values) => {
      return values.reduce((acc, value) => {
        const indexPath = this.getIndexPath(value);
        if (indexPath) acc.push({ value, indexPath });
        return acc;
      }, []).sort((a, b) => compareIndexPaths(a.indexPath, b.indexPath)).map(({ value }) => value);
    });
    __publicField3(this, "getIndexPath", (value) => {
      return findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
    });
    __publicField3(this, "getValue", (indexPath) => {
      const node = this.at(indexPath);
      return node ? this.getNodeValue(node) : void 0;
    });
    __publicField3(this, "getValuePath", (indexPath) => {
      if (!indexPath) return [];
      const valuePath = [];
      let currentPath = [...indexPath];
      while (currentPath.length > 0) {
        const node = this.at(currentPath);
        if (node) valuePath.unshift(this.getNodeValue(node));
        currentPath.pop();
      }
      return valuePath;
    });
    __publicField3(this, "getDepth", (value) => {
      const indexPath = findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
      return indexPath?.length ?? 0;
    });
    __publicField3(this, "isSameNode", (node, other) => {
      return this.getNodeValue(node) === this.getNodeValue(other);
    });
    __publicField3(this, "isRootNode", (node) => {
      return this.isSameNode(node, this.rootNode);
    });
    __publicField3(this, "contains", (parentIndexPath, valueIndexPath) => {
      if (!parentIndexPath || !valueIndexPath) return false;
      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);
    });
    __publicField3(this, "getNextNode", (value, opts = {}) => {
      let found = false;
      let nextNode;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (this.isRootNode(node)) return;
          const nodeValue = this.getNodeValue(node);
          if (opts.skip?.({ value: nodeValue, node, indexPath })) {
            if (nodeValue === value) {
              found = true;
            }
            return "skip";
          }
          if (found && !this.getNodeDisabled(node)) {
            nextNode = node;
            return "stop";
          }
          if (nodeValue === value) {
            found = true;
          }
        }
      });
      return nextNode;
    });
    __publicField3(this, "getPreviousNode", (value, opts = {}) => {
      let previousNode;
      let found = false;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (this.isRootNode(node)) return;
          const nodeValue = this.getNodeValue(node);
          if (opts.skip?.({ value: nodeValue, node, indexPath })) {
            return "skip";
          }
          if (nodeValue === value) {
            found = true;
            return "stop";
          }
          if (!this.getNodeDisabled(node)) {
            previousNode = node;
          }
        }
      });
      return found ? previousNode : void 0;
    });
    __publicField3(this, "getParentNodes", (valueOrIndexPath) => {
      const indexPath = this.resolveIndexPath(valueOrIndexPath)?.slice();
      if (!indexPath) return [];
      const result = [];
      while (indexPath.length > 0) {
        indexPath.pop();
        const parentNode = this.at(indexPath);
        if (parentNode && !this.isRootNode(parentNode)) {
          result.unshift(parentNode);
        }
      }
      return result;
    });
    __publicField3(this, "getDescendantNodes", (valueOrIndexPath, options2) => {
      const parentNode = this.resolveNode(valueOrIndexPath);
      if (!parentNode) return [];
      const result = [];
      visit(parentNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, nodeIndexPath) => {
          if (nodeIndexPath.length === 0) return;
          if (!options2?.withBranch && this.isBranchNode(node)) return;
          result.push(node);
        }
      });
      return result;
    });
    __publicField3(this, "getDescendantValues", (valueOrIndexPath, options2) => {
      const children = this.getDescendantNodes(valueOrIndexPath, options2);
      return children.map((child2) => this.getNodeValue(child2));
    });
    __publicField3(this, "getParentIndexPath", (indexPath) => {
      return indexPath.slice(0, -1);
    });
    __publicField3(this, "getParentNode", (valueOrIndexPath) => {
      const indexPath = this.resolveIndexPath(valueOrIndexPath);
      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;
    });
    __publicField3(this, "visit", (opts) => {
      const { skip, ...rest } = opts;
      visit(this.rootNode, {
        ...rest,
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (this.isRootNode(node)) return;
          if (skip?.({ value: this.getNodeValue(node), node, indexPath })) return "skip";
          return rest.onEnter?.(node, indexPath);
        }
      });
    });
    __publicField3(this, "getPreviousSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = indexPath[indexPath.length - 1];
      while (--idx >= 0) {
        const sibling2 = siblings[idx];
        if (!this.getNodeDisabled(sibling2)) return sibling2;
      }
      return;
    });
    __publicField3(this, "getNextSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = indexPath[indexPath.length - 1];
      while (++idx < siblings.length) {
        const sibling2 = siblings[idx];
        if (!this.getNodeDisabled(sibling2)) return sibling2;
      }
      return;
    });
    __publicField3(this, "getSiblingNodes", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this.getNodeChildren(parentNode) : [];
    });
    __publicField3(this, "getValues", (rootNode = this.rootNode) => {
      const values = flatMap(rootNode, {
        getChildren: this.getNodeChildren,
        transform: (node) => [this.getNodeValue(node)]
      });
      return values.slice(1);
    });
    __publicField3(this, "isValidDepth", (indexPath, depth) => {
      if (depth == null) return true;
      if (typeof depth === "function") return depth(indexPath.length);
      return indexPath.length === depth;
    });
    __publicField3(this, "isBranchNode", (node) => {
      return this.getNodeChildren(node).length > 0 || this.getNodeChildrenCount(node) != null;
    });
    __publicField3(this, "getBranchValues", (rootNode = this.rootNode, opts = {}) => {
      let values = [];
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (indexPath.length === 0) return;
          const nodeValue = this.getNodeValue(node);
          if (opts.skip?.({ value: nodeValue, node, indexPath })) return "skip";
          if (this.isBranchNode(node) && this.isValidDepth(indexPath, opts.depth)) {
            values.push(this.getNodeValue(node));
          }
        }
      });
      return values;
    });
    __publicField3(this, "flatten", (rootNode = this.rootNode) => {
      return flatten(rootNode, { getChildren: this.getNodeChildren });
    });
    __publicField3(this, "_create", (node, children) => {
      if (this.getNodeChildren(node).length > 0 || children.length > 0) {
        return { ...node, children };
      }
      return { ...node };
    });
    __publicField3(this, "_insert", (rootNode, indexPath, nodes) => {
      return this.copy(
        insert2(rootNode, { at: indexPath, nodes, getChildren: this.getNodeChildren, create: this._create })
      );
    });
    __publicField3(this, "copy", (rootNode) => {
      return new _TreeCollection({ ...this.options, rootNode });
    });
    __publicField3(this, "_replace", (rootNode, indexPath, node) => {
      return this.copy(
        replace(rootNode, { at: indexPath, node, getChildren: this.getNodeChildren, create: this._create })
      );
    });
    __publicField3(this, "_move", (rootNode, indexPaths, to) => {
      return this.copy(move2(rootNode, { indexPaths, to, getChildren: this.getNodeChildren, create: this._create }));
    });
    __publicField3(this, "_remove", (rootNode, indexPaths) => {
      return this.copy(remove2(rootNode, { indexPaths, getChildren: this.getNodeChildren, create: this._create }));
    });
    __publicField3(this, "replace", (indexPath, node) => {
      return this._replace(this.rootNode, indexPath, node);
    });
    __publicField3(this, "remove", (indexPaths) => {
      return this._remove(this.rootNode, indexPaths);
    });
    __publicField3(this, "insertBefore", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;
    });
    __publicField3(this, "insertAfter", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const nextIndex2 = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];
      return this._insert(this.rootNode, nextIndex2, nodes);
    });
    __publicField3(this, "move", (fromIndexPaths, toIndexPath) => {
      return this._move(this.rootNode, fromIndexPaths, toIndexPath);
    });
    __publicField3(this, "filter", (predicate) => {
      const filteredRoot = filter(this.rootNode, {
        predicate,
        getChildren: this.getNodeChildren,
        create: this._create
      });
      return this.copy(filteredRoot);
    });
    __publicField3(this, "toJSON", () => {
      return this.getValues(this.rootNode);
    });
    this.rootNode = options.rootNode;
  }
};
var fallbackMethods = {
  nodeToValue(node) {
    if (typeof node === "string") return node;
    if (isObject(node) && hasProp(node, "value")) return node.value;
    return "";
  },
  nodeToString(node) {
    if (typeof node === "string") return node;
    if (isObject(node) && hasProp(node, "label")) return node.label;
    return fallbackMethods.nodeToValue(node);
  },
  isNodeDisabled(node) {
    if (isObject(node) && hasProp(node, "disabled")) return !!node.disabled;
    return false;
  },
  nodeToChildren(node) {
    return node.children;
  },
  nodeToChildrenCount(node) {
    if (isObject(node) && hasProp(node, "childrenCount")) return node.childrenCount;
  }
};

// node_modules/@zag-js/popper/dist/index.mjs
function createDOMRect(x2 = 0, y = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x2, y, width, height);
  }
  const rect = {
    x: x2,
    y,
    width,
    height,
    top: y,
    right: x2 + width,
    bottom: y + height,
    left: x2
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x: x2, y, width, height } = anchorRect;
  return createDOMRect(x2, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement(anchorElement) ? anchorElement : anchorElement?.contextElement,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect?.(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getSideAxis = (side) => side === "top" || side === "bottom" ? "y" : "x";
function createTransformOriginMiddleware(opts, arrowEl) {
  return {
    name: "transformOrigin",
    fn(state3) {
      const { elements, middlewareData, placement, rects, y } = state3;
      const side = placement.split("-")[0];
      const axis = getSideAxis(side);
      const arrowX = middlewareData.arrow?.x || 0;
      const arrowY = middlewareData.arrow?.y || 0;
      const arrowWidth = arrowEl?.clientWidth || 0;
      const arrowHeight = arrowEl?.clientHeight || 0;
      const transformX = arrowX + arrowWidth / 2;
      const transformY = arrowY + arrowHeight / 2;
      const shiftY = Math.abs(middlewareData.shift?.y || 0);
      const halfAnchorHeight = rects.reference.height / 2;
      const arrowOffset = arrowHeight / 2;
      const gutter = opts.offset?.mainAxis ?? opts.gutter;
      const sideOffsetValue = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
      const isOverlappingAnchor = shiftY > sideOffsetValue;
      const adjacentTransformOrigin = {
        top: `${transformX}px calc(100% + ${sideOffsetValue}px)`,
        bottom: `${transformX}px ${-sideOffsetValue}px`,
        left: `calc(100% + ${sideOffsetValue}px) ${transformY}px`,
        right: `${-sideOffsetValue}px ${transformY}px`
      }[side];
      const overlapTransformOrigin = `${transformX}px ${rects.reference.y + halfAnchorHeight - y}px`;
      const useOverlap = Boolean(opts.overlap) && axis === "y" && isOverlappingAnchor;
      elements.floating.style.setProperty(
        cssVars.transformOrigin.variable,
        useOverlap ? overlapTransformOrigin : adjacentTransformOrigin
      );
      return {
        data: {
          transformOrigin: useOverlap ? overlapTransformOrigin : adjacentTransformOrigin
        }
      };
    }
  };
}
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x: x2, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x2 != null ? `${x2}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide(placement) {
  return placement.split("-")[0];
}
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function resolveBoundaryOption(boundary) {
  if (typeof boundary === "function") return boundary();
  if (boundary === "clipping-ancestors") return "clippingAncestors";
  return boundary;
}
function getArrowMiddleware(arrowElement, doc, opts) {
  const element2 = arrowElement || doc.createElement("div");
  return arrow({ element: element2, padding: opts.arrowPadding });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter)) return;
  return offset(({ placement }) => {
    const arrowOffset = (arrowElement?.clientHeight || 0) / 2;
    const gutter = opts.offset?.mainAxis ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift2 = !hasAlign ? opts.shift : void 0;
    const crossAxis = opts.offset?.crossAxis ?? shift2;
    return compact({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  const boundary = resolveBoundaryOption(opts.boundary);
  return flip({
    ...boundary ? { boundary } : void 0,
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  const boundary = resolveBoundaryOption(opts.boundary);
  return shift({
    ...boundary ? { boundary } : void 0,
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift()
  });
}
function getSizeMiddleware(opts) {
  return size({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      const referenceHeight = Math.round(rects.reference.height);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--reference-height", `${referenceHeight}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  if (!opts.hideWhenDetached) return;
  return hide({ strategy: "referenceHidden", boundary: resolveBoundaryOption(opts.boundary) ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const anchor = opts.getAnchorElement?.() ?? referenceOrVirtual;
  const reference = getAnchorElement(anchor, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, floating.ownerDocument, options),
    shiftArrowMiddleware(arrowEl),
    createTransformOriginMiddleware(
      { gutter: options.gutter, offset: options.offset, overlap: options.overlap },
      arrowEl
    ),
    getSizeMiddleware(options),
    hideWhenDetachedMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    if (!reference || !floating) return;
    const pos = await computePosition(reference, floating, {
      placement,
      middleware,
      strategy
    });
    onComplete?.(pos);
    onPositioned?.({ placed: true });
    const win = getWindow(floating);
    const x2 = roundByDpr(win, pos.x);
    const y = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x2}px`);
    floating.style.setProperty("--y", `${y}px`);
    if (options.hideWhenDetached) {
      const isHidden = pos.middlewareData.hide?.referenceHidden;
      if (isHidden) {
        floating.style.setProperty("visibility", "hidden");
        floating.style.setProperty("pointer-events", "none");
      } else {
        floating.style.removeProperty("visibility");
        floating.style.removeProperty("pointer-events");
      }
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const styles = getComputedStyle2(contentEl);
      floating.style.setProperty("--z-index", styles.zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition, floatingElement: floating });
      onPositioned?.({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop2;
  update();
  return () => {
    cancelAutoUpdate?.();
    onPositioned?.({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      pointerEvents: !placement ? "none" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}

// node_modules/@zag-js/interact-outside/dist/index.mjs
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      for (let i = 0; i < win.frames?.length; i += 1) {
        const frame = win.frames[i];
        if (frame) cb(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener, options) => {
      try {
        parent?.addEventListener(event, listener, options);
      } catch {
      }
      return () => {
        try {
          parent?.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener, options) => {
      try {
        parent?.removeEventListener(event, listener, options);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node of composedPath) {
    if (isHTMLElement(node) && isFocusable(node)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node, event) {
  if (!isPointerEvent(event) || !node) return false;
  const rect = node.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
  if (!ancestor || !isPointerEvent(event)) return false;
  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
  const rect = {
    x: ancestor.offsetLeft,
    y: ancestor.offsetTop,
    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
  };
  const point = {
    x: event.clientX,
    y: event.clientY
  };
  if (!isPointInRect(rect, point)) return false;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node, options) {
  const {
    exclude,
    onFocusOutside,
    onPointerDownOutside,
    onInteractOutside,
    defer,
    followControlledElements = true
  } = options;
  if (!node) return;
  const doc = getDocument(node);
  const win = getWindow(node);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event, target) {
    if (!isHTMLElement(target)) return false;
    if (!target.isConnected) return false;
    if (contains(node, target)) return false;
    if (isEventPointWithin(node, event)) return false;
    if (followControlledElements && isControlledElement(node, target)) return false;
    const triggerEl = doc.querySelector(`[aria-controls="${node.id}"]`);
    if (triggerEl) {
      const triggerAncestor = getNearestOverflowAncestor(triggerEl);
      if (isEventWithinScrollbar(event, triggerAncestor)) return false;
    }
    const nodeAncestor = getNearestOverflowAncestor(node);
    if (isEventWithinScrollbar(event, nodeAncestor)) return false;
    return !exclude?.(target);
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  const isInShadowRoot = isShadowRoot(node?.getRootNode());
  function onPointerDown(event) {
    function handler(clickEvent) {
      const func = defer && !isTouchDevice() ? raf : (v) => v();
      const evt = clickEvent ?? event;
      const composedPath = evt?.composedPath?.() ?? [evt?.target];
      func(() => {
        const target = isInShadowRoot ? composedPath[0] : getEventTarget(event);
        if (!node || !isEventOutside(event, target)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll(onPointerDownOutside, onInteractOutside);
          node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: evt,
            contextmenu: isContextMenuEvent(evt),
            focusable: isComposedPathFocusable(composedPath),
            target
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
    cleanups.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf : (v) => v();
    func(() => {
      const composedPath = event?.composedPath?.() ?? [event?.target];
      const target = isInShadowRoot ? composedPath[0] : getEventTarget(event);
      if (!node || !isEventOutside(event, target)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll(onFocusOutside, onInteractOutside);
        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(target),
          target
        }
      });
    });
  }
  if (!isTouchDevice()) {
    cleanups.add(addDomEvent(doc, "focusin", onFocusin, true));
    cleanups.add(parentWin.addEventListener("focusin", onFocusin, true));
    cleanups.add(frames.addEventListener("focusin", onFocusin, true));
  }
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(trackInteractOutsideImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function fireCustomEvent(el, type, init) {
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}

// node_modules/@zag-js/dismissable/dist/index.mjs
function trackEscapeKeydown(node, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn?.(event);
  };
  return addDomEvent(getDocument(node), "keydown", handleKeyDown, { capture: true });
}
var LAYER_REQUEST_DISMISS_EVENT = "layer:request-dismiss";
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node) {
    const index = this.indexOf(node);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf(this.topMostPointerBlockingLayer()?.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node) {
    const layer = this.layers[this.count() - 1];
    return layer?.node === node;
  },
  getNestedLayers(node) {
    return Array.from(this.layers).slice(this.indexOf(node) + 1);
  },
  getLayersByType(type) {
    return this.layers.filter((layer) => layer.type === type);
  },
  getNestedLayersByType(node, type) {
    const index = this.indexOf(node);
    if (index === -1) return [];
    return this.layers.slice(index + 1).filter((layer) => layer.type === type);
  },
  getParentLayerOfType(node, type) {
    const index = this.indexOf(node);
    if (index <= 0) return void 0;
    return this.layers.slice(0, index).reverse().find((layer) => layer.type === type);
  },
  countNestedLayersOfType(node, type) {
    return this.getNestedLayersByType(node, type).length;
  },
  isInNestedLayer(node, target) {
    return this.getNestedLayers(node).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    this.layers.push(layer);
    this.syncLayers();
  },
  addBranch(node) {
    this.branches.push(node);
  },
  remove(node) {
    const index = this.indexOf(node);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node);
      _layers.forEach((layer) => layerStack.dismiss(layer.node, node));
    }
    this.layers.splice(index, 1);
    this.syncLayers();
  },
  removeBranch(node) {
    const index = this.branches.indexOf(node);
    if (index >= 0) this.branches.splice(index, 1);
  },
  syncLayers() {
    this.layers.forEach((layer, index) => {
      layer.node.style.setProperty("--layer-index", `${index}`);
      layer.node.removeAttribute("data-nested");
      layer.node.removeAttribute("data-has-nested");
      const parentOfSameType = this.getParentLayerOfType(layer.node, layer.type);
      if (parentOfSameType) {
        layer.node.setAttribute("data-nested", layer.type);
      }
      const nestedCount = this.countNestedLayersOfType(layer.node, layer.type);
      if (nestedCount > 0) {
        layer.node.setAttribute("data-has-nested", layer.type);
      }
      layer.node.style.setProperty("--nested-layer-count", `${nestedCount}`);
    });
  },
  indexOf(node) {
    return this.layers.findIndex((layer) => layer.node === node);
  },
  dismiss(node, parent) {
    const index = this.indexOf(node);
    if (index === -1) return;
    const layer = this.layers[index];
    addListenerOnce(node, LAYER_REQUEST_DISMISS_EVENT, (event) => {
      layer.requestDismiss?.(event);
      if (!event.defaultPrevented) {
        layer?.dismiss();
      }
    });
    fireCustomEvent2(node, LAYER_REQUEST_DISMISS_EVENT, {
      originalLayer: node,
      targetLayer: parent,
      originalIndex: index,
      targetIndex: parent ? this.indexOf(parent) : -1
    });
    this.syncLayers();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
function fireCustomEvent2(el, type, detail) {
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, { cancelable: true, bubbles: true, detail });
  return el.dispatchEvent(event);
}
function addListenerOnce(el, type, callback) {
  el.addEventListener(type, callback, { once: true });
}
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node }) => {
    node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? "none" : "auto";
  });
}
function clearPointerEvent(node) {
  node.style.pointerEvents = "";
}
function disablePointerEventsOutside(node, persistentElements) {
  const doc = getDocument(node);
  const cleanups = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  persistentElements?.forEach((el) => {
    const [promise, abort] = waitForElement(
      () => {
        const node2 = el();
        return isHTMLElement(node2) ? node2 : null;
      },
      { timeout: 1e3 }
    );
    promise.then((el2) => cleanups.push(setStyle(el2, { pointerEvents: "auto" })));
    cleanups.push(abort);
  });
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node, options) {
  const { warnOnMissingNode = true } = options;
  if (warnOnMissingNode && !node) {
    warn("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  if (!node) {
    return;
  }
  const { onDismiss, onRequestDismiss, pointerBlocking, exclude: excludeContainers, debug, type = "dialog" } = options;
  const layer = { dismiss: onDismiss, node, type, pointerBlocking, requestDismiss: onRequestDismiss };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node) || layerStack.isInBranch(target)) return;
    options.onPointerDownOutside?.(event);
    options.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onFocusOutside(event) {
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    options.onFocusOutside?.(event);
    options.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onEscapeKeyDown(event) {
    if (!layerStack.isTopMost(node)) return;
    options.onEscapeKeyDown?.(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    if (!node) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = options.persistentElements?.map((fn) => fn()).filter(isHTMLElement);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node2) => contains(node2, target)) || layerStack.isInNestedLayer(node, target);
  }
  const cleanups = [
    pointerBlocking ? disablePointerEventsOutside(node, options.persistentElements) : void 0,
    trackEscapeKeydown(node, onEscapeKeyDown),
    trackInteractOutside(node, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node);
    assignPointerEventToLayers();
    clearPointerEvent(node);
    cleanups.forEach((fn) => fn?.());
  };
}
function trackDismissableElement(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups.push(trackDismissableElementImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node) {
        warn("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node);
      cleanups.push(() => {
        layerStack.removeBranch(node);
      });
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}

// node_modules/@zag-js/combobox/dist/index.mjs
var anatomy5 = createAnatomy("combobox").parts(
  "root",
  "clearTrigger",
  "content",
  "control",
  "input",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "label",
  "list",
  "positioner",
  "trigger"
);
var parts5 = anatomy5.build();
var collection = (options) => {
  return new ListCollection(options);
};
collection.empty = () => {
  return new ListCollection({ items: [] });
};
var getRootId5 = (ctx) => ctx.ids?.root ?? `combobox:${ctx.id}`;
var getLabelId = (ctx) => ctx.ids?.label ?? `combobox:${ctx.id}:label`;
var getControlId = (ctx) => ctx.ids?.control ?? `combobox:${ctx.id}:control`;
var getInputId = (ctx) => ctx.ids?.input ?? `combobox:${ctx.id}:input`;
var getContentId2 = (ctx) => ctx.ids?.content ?? `combobox:${ctx.id}:content`;
var getPositionerId = (ctx) => ctx.ids?.positioner ?? `combobox:${ctx.id}:popper`;
var getTriggerId2 = (ctx) => ctx.ids?.trigger ?? `combobox:${ctx.id}:toggle-btn`;
var getClearTriggerId = (ctx) => ctx.ids?.clearTrigger ?? `combobox:${ctx.id}:clear-btn`;
var getItemGroupId2 = (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `combobox:${ctx.id}:optgroup:${id}`;
var getItemGroupLabelId = (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `combobox:${ctx.id}:optgroup-label:${id}`;
var getItemId3 = (ctx, id) => ctx.ids?.item?.(id) ?? `combobox:${ctx.id}:option:${id}`;
var getContentEl2 = (ctx) => ctx.getById(getContentId2(ctx));
var getInputEl = (ctx) => ctx.getById(getInputId(ctx));
var getPositionerEl = (ctx) => ctx.getById(getPositionerId(ctx));
var getControlEl = (ctx) => ctx.getById(getControlId(ctx));
var getTriggerEl = (ctx) => ctx.getById(getTriggerId2(ctx));
var getClearTriggerEl = (ctx) => ctx.getById(getClearTriggerId(ctx));
var getItemEl = (ctx, value) => {
  if (value == null) return null;
  const selector = `[role=option][data-value="${CSS.escape(value)}"]`;
  return query(getContentEl2(ctx), selector);
};
var focusInputEl = (ctx) => {
  const inputEl = getInputEl(ctx);
  if (ctx.isActiveElement(inputEl)) return;
  inputEl?.focus({ preventScroll: true });
};
var focusTriggerEl = (ctx) => {
  const triggerEl = getTriggerEl(ctx);
  if (ctx.isActiveElement(triggerEl)) return;
  triggerEl?.focus({ preventScroll: true });
};
function connect5(service, normalize2) {
  const { context, prop, state: state3, send, scope, computed, event } = service;
  const translations = prop("translations");
  const collection22 = prop("collection");
  const disabled = !!prop("disabled");
  const interactive = computed("isInteractive");
  const invalid = !!prop("invalid");
  const required = !!prop("required");
  const readOnly = !!prop("readOnly");
  const open = state3.hasTag("open");
  const focused = state3.hasTag("focused");
  const composite = prop("composite");
  const highlightedValue = context.get("highlightedValue");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: context.get("currentPlacement")
  });
  function getItemState(props25) {
    const disabled2 = collection22.getItemDisabled(props25.item);
    const value = collection22.getItemValue(props25.item);
    ensure(value, () => `[zag-js] No value found for item ${JSON.stringify(props25.item)}`);
    return {
      value,
      disabled: Boolean(disabled2 || disabled2),
      highlighted: highlightedValue === value,
      selected: context.get("value").includes(value)
    };
  }
  return {
    focused,
    open,
    inputValue: context.get("inputValue"),
    highlightedValue,
    highlightedItem: context.get("highlightedItem"),
    value: context.get("value"),
    valueAsString: computed("valueAsString"),
    hasSelectedItems: computed("hasSelectedItems"),
    selectedItems: context.get("selectedItems"),
    collection: prop("collection"),
    multiple: !!prop("multiple"),
    disabled: !!disabled,
    syncSelectedItems() {
      send({ type: "SELECTED_ITEMS.SYNC" });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    setHighlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearHighlightValue() {
      send({ type: "HIGHLIGHTED_VALUE.CLEAR" });
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    setInputValue(value, reason = "script") {
      send({ type: "INPUT_VALUE.SET", value, src: reason });
    },
    clearValue(value) {
      if (value != null) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    focus() {
      getInputEl(scope)?.focus();
    },
    setOpen(nextOpen, reason = "script") {
      const open2 = state3.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE", src: reason });
    },
    getRootProps() {
      return normalize2.element({
        ...parts5.root.attrs,
        dir: prop("dir"),
        id: getRootId5(scope),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts5.label.attrs,
        dir: prop("dir"),
        htmlFor: getInputId(scope),
        id: getLabelId(scope),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-required": dataAttr(required),
        "data-focus": dataAttr(focused),
        onClick(event2) {
          if (composite) return;
          event2.preventDefault();
          getTriggerEl(scope)?.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts5.control.attrs,
        dir: prop("dir"),
        id: getControlId(scope),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts5.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId(scope),
        style: popperStyles.floating
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts5.input.attrs,
        dir: prop("dir"),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "data-autofocus": dataAttr(prop("autoFocus")),
        name: prop("name"),
        form: prop("form"),
        disabled,
        required: prop("required"),
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "none",
        spellCheck: "false",
        readOnly,
        placeholder: prop("placeholder"),
        id: getInputId(scope),
        type: "text",
        role: "combobox",
        defaultValue: context.get("inputValue"),
        "aria-autocomplete": computed("autoComplete") ? "both" : "list",
        "aria-controls": getContentId2(scope),
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-activedescendant": highlightedValue ? getItemId3(scope, highlightedValue) : void 0,
        onClick(event2) {
          if (event2.defaultPrevented) return;
          if (!prop("openOnClick")) return;
          if (!interactive) return;
          send({ type: "INPUT.CLICK", src: "input-click" });
        },
        onFocus() {
          if (disabled) return;
          send({ type: "INPUT.FOCUS" });
        },
        onBlur() {
          if (disabled) return;
          send({ type: "INPUT.BLUR" });
        },
        onChange(event2) {
          send({ type: "INPUT.CHANGE", value: event2.currentTarget.value, src: "input-change" });
        },
        onKeyDown(event2) {
          if (event2.defaultPrevented) return;
          if (!interactive) return;
          if (event2.ctrlKey || event2.shiftKey || isComposingEvent(event2)) return;
          const openOnKeyPress = prop("openOnKeyPress");
          const isModifierKey2 = event2.ctrlKey || event2.metaKey || event2.shiftKey;
          const keypress = true;
          const keymap = {
            ArrowDown(event3) {
              if (!openOnKeyPress && !open) return;
              send({ type: event3.altKey ? "OPEN" : "INPUT.ARROW_DOWN", keypress, src: "arrow-key" });
              event3.preventDefault();
            },
            ArrowUp() {
              if (!openOnKeyPress && !open) return;
              send({ type: event2.altKey ? "CLOSE" : "INPUT.ARROW_UP", keypress, src: "arrow-key" });
              event2.preventDefault();
            },
            Home(event3) {
              if (isModifierKey2) return;
              send({ type: "INPUT.HOME", keypress });
              if (open) {
                event3.preventDefault();
              }
            },
            End(event3) {
              if (isModifierKey2) return;
              send({ type: "INPUT.END", keypress });
              if (open) {
                event3.preventDefault();
              }
            },
            Enter(event3) {
              send({ type: "INPUT.ENTER", keypress, src: "item-select" });
              const submittable = computed("isCustomValue") && prop("allowCustomValue");
              const hasHighlight = highlightedValue != null;
              const alwaysSubmit = prop("alwaysSubmitOnEnter");
              if (open && !submittable && !alwaysSubmit && hasHighlight) {
                event3.preventDefault();
              }
              if (highlightedValue == null) return;
              const itemEl = getItemEl(scope, highlightedValue);
              if (isAnchorElement(itemEl)) {
                prop("navigate")?.({ value: highlightedValue, node: itemEl, href: itemEl.href });
              }
            },
            Escape() {
              send({ type: "INPUT.ESCAPE", keypress, src: "escape-key" });
              event2.preventDefault();
            }
          };
          const key = getEventKey(event2, { dir: prop("dir") });
          const exec = keymap[key];
          exec?.(event2);
        }
      });
    },
    getTriggerProps(props25 = {}) {
      return normalize2.button({
        ...parts5.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId2(scope),
        "aria-haspopup": composite ? "listbox" : "dialog",
        type: "button",
        tabIndex: props25.focusable ? void 0 : -1,
        "aria-label": translations.triggerLabel,
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": open ? getContentId2(scope) : void 0,
        disabled,
        "data-invalid": dataAttr(invalid),
        "data-focusable": dataAttr(props25.focusable),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        onFocus() {
          if (!props25.focusable) return;
          send({ type: "INPUT.FOCUS", src: "trigger" });
        },
        onClick(event2) {
          if (event2.defaultPrevented) return;
          if (!interactive) return;
          if (!isLeftClick(event2)) return;
          send({ type: "TRIGGER.CLICK", src: "trigger-click" });
        },
        onPointerDown(event2) {
          if (!interactive) return;
          if (event2.pointerType === "touch") return;
          if (!isLeftClick(event2)) return;
          event2.preventDefault();
          queueMicrotask(() => {
            getInputEl(scope)?.focus({ preventScroll: true });
          });
        },
        onKeyDown(event2) {
          if (event2.defaultPrevented) return;
          if (composite) return;
          const keyMap2 = {
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", src: "arrow-key" });
            },
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", src: "arrow-key" });
            }
          };
          const key = getEventKey(event2, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event2);
            event2.preventDefault();
          }
        }
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts5.content.attrs,
        dir: prop("dir"),
        id: getContentId2(scope),
        role: !composite ? "dialog" : "listbox",
        tabIndex: -1,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-placement": context.get("currentPlacement"),
        "aria-labelledby": getLabelId(scope),
        "aria-multiselectable": prop("multiple") && composite ? true : void 0,
        "data-empty": dataAttr(collection22.size === 0),
        onPointerDown(event2) {
          if (!isLeftClick(event2)) return;
          event2.preventDefault();
        }
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts5.list.attrs,
        role: !composite ? "listbox" : void 0,
        "data-empty": dataAttr(collection22.size === 0),
        "aria-labelledby": getLabelId(scope),
        "aria-multiselectable": prop("multiple") && !composite ? true : void 0
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts5.clearTrigger.attrs,
        dir: prop("dir"),
        id: getClearTriggerId(scope),
        type: "button",
        tabIndex: -1,
        disabled,
        "data-invalid": dataAttr(invalid),
        "aria-label": translations.clearTriggerLabel,
        "aria-controls": getInputId(scope),
        hidden: !context.get("value").length,
        onPointerDown(event2) {
          if (!isLeftClick(event2)) return;
          event2.preventDefault();
        },
        onClick(event2) {
          if (event2.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "VALUE.CLEAR", src: "clear-trigger" });
        }
      });
    },
    getItemState,
    getItemProps(props25) {
      const itemState = getItemState(props25);
      const value = itemState.value;
      return normalize2.element({
        ...parts5.item.attrs,
        dir: prop("dir"),
        id: getItemId3(scope, value),
        role: "option",
        tabIndex: -1,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.selected ? "checked" : "unchecked",
        "aria-selected": ariaAttr(itemState.highlighted),
        "aria-disabled": ariaAttr(itemState.disabled),
        "data-disabled": dataAttr(itemState.disabled),
        "data-value": itemState.value,
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.highlighted) return;
          send({ type: "ITEM.POINTER_MOVE", value });
        },
        onPointerLeave() {
          if (props25.persistFocus) return;
          if (itemState.disabled) return;
          const prev2 = event.previous();
          const mouseMoved = prev2?.type.includes("POINTER");
          if (!mouseMoved) return;
          send({ type: "ITEM.POINTER_LEAVE", value });
        },
        onClick(event2) {
          if (isDownloadingEvent(event2)) return;
          if (isOpeningInNewTab(event2)) return;
          if (isContextMenuEvent(event2)) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "item-select", value });
        }
      });
    },
    getItemTextProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts5.itemText.attrs,
        dir: prop("dir"),
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        "aria-hidden": true,
        ...parts5.itemIndicator.attrs,
        dir: prop("dir"),
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupProps(props25) {
      const { id } = props25;
      return normalize2.element({
        ...parts5.itemGroup.attrs,
        dir: prop("dir"),
        id: getItemGroupId2(scope, id),
        "aria-labelledby": getItemGroupLabelId(scope, id),
        "data-empty": dataAttr(collection22.size === 0),
        role: "group"
      });
    },
    getItemGroupLabelProps(props25) {
      const { htmlFor } = props25;
      return normalize2.element({
        ...parts5.itemGroupLabel.attrs,
        dir: prop("dir"),
        id: getItemGroupLabelId(scope, htmlFor),
        role: "presentation"
      });
    }
  };
}
var { guards, createMachine: createMachine2, choose } = setup();
var { and: and2, not: not2 } = guards;
var machine5 = createMachine2({
  props({ props: props25 }) {
    return {
      loopFocus: true,
      openOnClick: false,
      defaultValue: [],
      defaultInputValue: "",
      closeOnSelect: !props25.multiple,
      allowCustomValue: false,
      alwaysSubmitOnEnter: false,
      inputBehavior: "none",
      selectionBehavior: props25.multiple ? "clear" : "replace",
      openOnKeyPress: true,
      openOnChange: true,
      composite: true,
      navigate({ node }) {
        clickIfLink(node);
      },
      collection: collection.empty(),
      ...props25,
      positioning: {
        placement: "bottom",
        sameWidth: true,
        ...props25.positioning
      },
      translations: {
        triggerLabel: "Toggle suggestions",
        clearTriggerLabel: "Clear value",
        ...props25.translations
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "suggesting" : "idle";
  },
  context({ prop, bindable: bindable2, getContext: getContext2, getEvent }) {
    return {
      currentPlacement: bindable2(() => ({
        defaultValue: void 0
      })),
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        hash(value) {
          return value.join(",");
        },
        onChange(value) {
          const context = getContext2();
          const prevSelectedItems = context.get("selectedItems");
          const collection22 = prop("collection");
          const nextItems = value.map((v) => {
            const item = prevSelectedItems.find((item2) => collection22.getItemValue(item2) === v);
            return item || collection22.find(v);
          });
          context.set("selectedItems", nextItems);
          prop("onValueChange")?.({ value, items: nextItems });
        }
      })),
      highlightedValue: bindable2(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          const item = prop("collection").find(value);
          prop("onHighlightChange")?.({ highlightedValue: value, highlightedItem: item });
        }
      })),
      inputValue: bindable2(() => {
        let inputValue = prop("inputValue") || prop("defaultInputValue");
        const value = prop("value") || prop("defaultValue");
        if (!inputValue.trim() && !prop("multiple")) {
          const valueAsString = prop("collection").stringifyMany(value);
          inputValue = match(prop("selectionBehavior"), {
            preserve: inputValue || valueAsString,
            replace: valueAsString,
            clear: ""
          });
        }
        return {
          defaultValue: inputValue,
          value: prop("inputValue"),
          onChange(value2) {
            const event = getEvent();
            const reason = (event.previousEvent || event).src;
            prop("onInputValueChange")?.({ inputValue: value2, reason });
          }
        };
      }),
      highlightedItem: bindable2(() => {
        const highlightedValue = prop("highlightedValue");
        const highlightedItem = prop("collection").find(highlightedValue);
        return { defaultValue: highlightedItem };
      }),
      selectedItems: bindable2(() => {
        const value = prop("value") || prop("defaultValue") || [];
        const selectedItems = prop("collection").findMany(value);
        return { defaultValue: selectedItems };
      })
    };
  },
  computed: {
    isInputValueEmpty: ({ context }) => context.get("inputValue").length === 0,
    isInteractive: ({ prop }) => !(prop("readOnly") || prop("disabled")),
    autoComplete: ({ prop }) => prop("inputBehavior") === "autocomplete",
    autoHighlight: ({ prop }) => prop("inputBehavior") === "autohighlight",
    hasSelectedItems: ({ context }) => context.get("value").length > 0,
    valueAsString: ({ context, prop }) => prop("collection").stringifyItems(context.get("selectedItems")),
    isCustomValue: ({ context, computed }) => context.get("inputValue") !== computed("valueAsString")
  },
  watch({ context, prop, track: track2, action, send }) {
    track2([() => context.hash("value")], () => {
      action(["syncSelectedItems"]);
    });
    track2([() => context.get("inputValue")], () => {
      action(["syncInputValue"]);
    });
    track2([() => context.get("highlightedValue")], () => {
      action(["syncHighlightedItem", "autofillInputValue"]);
    });
    track2([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
    track2([() => prop("collection").toString()], () => {
      send({ type: "CHILDREN_CHANGE" });
    });
  },
  on: {
    "SELECTED_ITEMS.SYNC": {
      actions: ["syncSelectedItems"]
    },
    "HIGHLIGHTED_VALUE.SET": {
      actions: ["setHighlightedValue"]
    },
    "HIGHLIGHTED_VALUE.CLEAR": {
      actions: ["clearHighlightedValue"]
    },
    "ITEM.SELECT": {
      actions: ["selectItem"]
    },
    "ITEM.CLEAR": {
      actions: ["clearItem"]
    },
    "VALUE.SET": {
      actions: ["setValue"]
    },
    "INPUT_VALUE.SET": {
      actions: ["setInputValue"]
    },
    "POSITIONING.SET": {
      actions: ["reposition"]
    }
  },
  entry: choose([
    {
      guard: "autoFocus",
      actions: ["setInitialFocus"]
    }
  ]),
  states: {
    idle: {
      tags: ["idle", "closed"],
      entry: ["scrollContentToTop", "clearHighlightedValue"],
      on: {
        "CONTROLLED.OPEN": {
          target: "interacting"
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
          }
        ],
        "INPUT.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
          }
        ],
        "INPUT.FOCUS": {
          target: "focused"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["invokeOnOpen"]
          }
        ],
        "VALUE.CLEAR": {
          target: "focused",
          actions: ["clearInputValue", "clearSelectedItems", "setInitialFocus"]
        }
      }
    },
    focused: {
      tags: ["focused", "closed"],
      entry: ["scrollContentToTop", "clearHighlightedValue"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: "isChangeEvent",
            target: "suggesting"
          },
          {
            target: "interacting"
          }
        ],
        "INPUT.CHANGE": [
          {
            guard: and2("isOpenControlled", "openOnChange"),
            actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
          },
          {
            guard: "openOnChange",
            target: "suggesting",
            actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
          },
          {
            actions: ["setInputValue"]
          }
        ],
        "LAYER.INTERACT_OUTSIDE": {
          target: "idle"
        },
        "INPUT.ESCAPE": {
          guard: and2("isCustomValue", not2("allowCustomValue")),
          actions: ["revertInputValue"]
        },
        "INPUT.BLUR": {
          target: "idle"
        },
        "INPUT.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
          }
        ],
        "INPUT.ARROW_DOWN": [
          // == group 1 ==
          {
            guard: and2("isOpenControlled", "autoComplete"),
            actions: ["invokeOnOpen"]
          },
          {
            guard: "autoComplete",
            target: "interacting",
            actions: ["invokeOnOpen"]
          },
          // == group 2 ==
          {
            guard: "isOpenControlled",
            actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
          }
        ],
        "INPUT.ARROW_UP": [
          // == group 1 ==
          {
            guard: "autoComplete",
            target: "interacting",
            actions: ["invokeOnOpen"]
          },
          {
            guard: "autoComplete",
            target: "interacting",
            actions: ["invokeOnOpen"]
          },
          // == group 2 ==
          {
            target: "interacting",
            actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "interacting",
            actions: ["invokeOnOpen"]
          }
        ],
        "VALUE.CLEAR": {
          actions: ["clearInputValue", "clearSelectedItems"]
        }
      }
    },
    interacting: {
      tags: ["open", "focused"],
      entry: ["setInitialFocus"],
      effects: ["scrollToHighlightedItem", "trackDismissableLayer", "trackPlacement"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "restoreFocus",
            target: "focused",
            actions: ["setFinalFocus"]
          },
          {
            target: "idle"
          }
        ],
        CHILDREN_CHANGE: [
          {
            guard: "isHighlightedItemRemoved",
            actions: ["clearHighlightedValue"]
          },
          {
            actions: ["scrollToHighlightedItem"]
          }
        ],
        "INPUT.HOME": {
          actions: ["highlightFirstItem"]
        },
        "INPUT.END": {
          actions: ["highlightLastItem"]
        },
        "INPUT.ARROW_DOWN": [
          {
            guard: and2("autoComplete", "isLastItemHighlighted"),
            actions: ["clearHighlightedValue", "scrollContentToTop"]
          },
          {
            actions: ["highlightNextItem"]
          }
        ],
        "INPUT.ARROW_UP": [
          {
            guard: and2("autoComplete", "isFirstItemHighlighted"),
            actions: ["clearHighlightedValue"]
          },
          {
            actions: ["highlightPrevItem"]
          }
        ],
        "INPUT.ENTER": [
          // == group 1 ==
          {
            guard: and2("isOpenControlled", "isCustomValue", not2("hasHighlightedItem"), not2("allowCustomValue")),
            actions: ["revertInputValue", "invokeOnClose"]
          },
          {
            guard: and2("isCustomValue", not2("hasHighlightedItem"), not2("allowCustomValue")),
            target: "focused",
            actions: ["revertInputValue", "invokeOnClose"]
          },
          // == group 2 ==
          {
            guard: and2("isOpenControlled", "closeOnSelect"),
            actions: ["selectHighlightedItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
          },
          {
            actions: ["selectHighlightedItem"]
          }
        ],
        "INPUT.CHANGE": [
          {
            guard: "autoComplete",
            target: "suggesting",
            actions: ["setInputValue"]
          },
          {
            target: "suggesting",
            actions: ["clearHighlightedValue", "setInputValue"]
          }
        ],
        "ITEM.POINTER_MOVE": {
          actions: ["setHighlightedValue"]
        },
        "ITEM.POINTER_LEAVE": {
          actions: ["clearHighlightedValue"]
        },
        "ITEM.CLICK": [
          {
            guard: and2("isOpenControlled", "closeOnSelect"),
            actions: ["selectItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
          },
          {
            actions: ["selectItem"]
          }
        ],
        "LAYER.ESCAPE": [
          {
            guard: and2("isOpenControlled", "autoComplete"),
            actions: ["syncInputValue", "invokeOnClose"]
          },
          {
            guard: "autoComplete",
            target: "focused",
            actions: ["syncInputValue", "invokeOnClose"]
          },
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "setFinalFocus"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose"]
          }
        ],
        "LAYER.INTERACT_OUTSIDE": [
          // == group 1 ==
          {
            guard: and2("isOpenControlled", "isCustomValue", not2("allowCustomValue")),
            actions: ["revertInputValue", "invokeOnClose"]
          },
          {
            guard: and2("isCustomValue", not2("allowCustomValue")),
            target: "idle",
            actions: ["revertInputValue", "invokeOnClose"]
          },
          // == group 2 ==
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "setFinalFocus"]
          }
        ],
        "VALUE.CLEAR": [
          {
            guard: "isOpenControlled",
            actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
          }
        ]
      }
    },
    suggesting: {
      tags: ["open", "focused"],
      effects: ["trackDismissableLayer", "scrollToHighlightedItem", "trackPlacement"],
      entry: ["setInitialFocus"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "restoreFocus",
            target: "focused",
            actions: ["setFinalFocus"]
          },
          {
            target: "idle"
          }
        ],
        CHILDREN_CHANGE: [
          {
            guard: and2("isHighlightedItemRemoved", "hasCollectionItems", "autoHighlight"),
            actions: ["clearHighlightedValue", "highlightFirstItem"]
          },
          {
            guard: "isHighlightedItemRemoved",
            actions: ["clearHighlightedValue"]
          },
          {
            guard: "autoHighlight",
            actions: ["highlightFirstItem"]
          }
        ],
        "INPUT.ARROW_DOWN": {
          target: "interacting",
          actions: ["highlightNextItem"]
        },
        "INPUT.ARROW_UP": {
          target: "interacting",
          actions: ["highlightPrevItem"]
        },
        "INPUT.HOME": {
          target: "interacting",
          actions: ["highlightFirstItem"]
        },
        "INPUT.END": {
          target: "interacting",
          actions: ["highlightLastItem"]
        },
        "INPUT.ENTER": [
          // == group 1 ==
          {
            guard: and2("isOpenControlled", "isCustomValue", not2("hasHighlightedItem"), not2("allowCustomValue")),
            actions: ["revertInputValue", "invokeOnClose"]
          },
          {
            guard: and2("isCustomValue", not2("hasHighlightedItem"), not2("allowCustomValue")),
            target: "focused",
            actions: ["revertInputValue", "invokeOnClose"]
          },
          // == group 2 ==
          {
            guard: and2("isOpenControlled", "closeOnSelect"),
            actions: ["selectHighlightedItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
          },
          {
            actions: ["selectHighlightedItem"]
          }
        ],
        "INPUT.CHANGE": {
          actions: ["setInputValue"]
        },
        "LAYER.ESCAPE": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose"]
          }
        ],
        "ITEM.POINTER_MOVE": {
          target: "interacting",
          actions: ["setHighlightedValue"]
        },
        "ITEM.POINTER_LEAVE": {
          actions: ["clearHighlightedValue"]
        },
        "LAYER.INTERACT_OUTSIDE": [
          // == group 1 ==
          {
            guard: and2("isOpenControlled", "isCustomValue", not2("allowCustomValue")),
            actions: ["revertInputValue", "invokeOnClose"]
          },
          {
            guard: and2("isCustomValue", not2("allowCustomValue")),
            target: "idle",
            actions: ["revertInputValue", "invokeOnClose"]
          },
          // == group 2 ==
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose"]
          }
        ],
        "ITEM.CLICK": [
          {
            guard: and2("isOpenControlled", "closeOnSelect"),
            actions: ["selectItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
          },
          {
            actions: ["selectItem"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "setFinalFocus"]
          }
        ],
        "VALUE.CLEAR": [
          {
            guard: "isOpenControlled",
            actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isInputValueEmpty: ({ computed }) => computed("isInputValueEmpty"),
      autoComplete: ({ computed, prop }) => computed("autoComplete") && !prop("multiple"),
      autoHighlight: ({ computed }) => computed("autoHighlight"),
      isFirstItemHighlighted: ({ prop, context }) => prop("collection").firstValue === context.get("highlightedValue"),
      isLastItemHighlighted: ({ prop, context }) => prop("collection").lastValue === context.get("highlightedValue"),
      isCustomValue: ({ computed }) => computed("isCustomValue"),
      allowCustomValue: ({ prop }) => !!prop("allowCustomValue"),
      hasHighlightedItem: ({ context }) => context.get("highlightedValue") != null,
      closeOnSelect: ({ prop }) => !!prop("closeOnSelect"),
      isOpenControlled: ({ prop }) => prop("open") != null,
      openOnChange: ({ prop, context }) => {
        const openOnChange = prop("openOnChange");
        if (isBoolean(openOnChange)) return openOnChange;
        return !!openOnChange?.({ inputValue: context.get("inputValue") });
      },
      restoreFocus: ({ event }) => {
        const restoreFocus = event.restoreFocus ?? event.previousEvent?.restoreFocus;
        return restoreFocus == null ? true : !!restoreFocus;
      },
      isChangeEvent: ({ event }) => event.previousEvent?.type === "INPUT.CHANGE",
      autoFocus: ({ prop }) => !!prop("autoFocus"),
      isHighlightedItemRemoved: ({ prop, context }) => !prop("collection").has(context.get("highlightedValue")),
      hasCollectionItems: ({ prop }) => prop("collection").size > 0
    },
    effects: {
      trackDismissableLayer({ send, prop, scope }) {
        if (prop("disableLayer")) return;
        const contentEl = () => getContentEl2(scope);
        return trackDismissableElement(contentEl, {
          type: "listbox",
          defer: true,
          exclude: () => [getInputEl(scope), getTriggerEl(scope), getClearTriggerEl(scope)],
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onInteractOutside: prop("onInteractOutside"),
          onEscapeKeyDown(event) {
            event.preventDefault();
            event.stopPropagation();
            send({ type: "LAYER.ESCAPE", src: "escape-key" });
          },
          onDismiss() {
            send({ type: "LAYER.INTERACT_OUTSIDE", src: "interact-outside", restoreFocus: false });
          }
        });
      },
      trackPlacement({ context, prop, scope }) {
        const anchorEl = () => getControlEl(scope) || getTriggerEl(scope);
        const positionerEl = () => getPositionerEl(scope);
        context.set("currentPlacement", prop("positioning").placement);
        return getPlacement(anchorEl, positionerEl, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      scrollToHighlightedItem({ context, prop, scope, event }) {
        const inputEl = getInputEl(scope);
        let cleanups = [];
        const exec = (immediate) => {
          const pointer = event.current().type.includes("POINTER");
          const highlightedValue = context.get("highlightedValue");
          if (pointer || !highlightedValue) return;
          const contentEl = getContentEl2(scope);
          const scrollToIndexFn = prop("scrollToIndexFn");
          if (scrollToIndexFn) {
            const highlightedIndex = prop("collection").indexOf(highlightedValue);
            scrollToIndexFn({
              index: highlightedIndex,
              immediate,
              getElement: () => getItemEl(scope, highlightedValue)
            });
            return;
          }
          const itemEl = getItemEl(scope, highlightedValue);
          const raf_cleanup = raf(() => {
            scrollIntoView(itemEl, { rootEl: contentEl, block: "nearest" });
          });
          cleanups.push(raf_cleanup);
        };
        const rafCleanup = raf(() => exec(true));
        cleanups.push(rafCleanup);
        const observerCleanup = observeAttributes(inputEl, {
          attributes: ["aria-activedescendant"],
          callback: () => exec(false)
        });
        cleanups.push(observerCleanup);
        return () => {
          cleanups.forEach((cleanup) => cleanup());
        };
      }
    },
    actions: {
      reposition({ context, prop, scope, event }) {
        const controlEl = () => getControlEl(scope);
        const positionerEl = () => getPositionerEl(scope);
        getPlacement(controlEl, positionerEl, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      setHighlightedValue({ context, event }) {
        if (event.value == null) return;
        context.set("highlightedValue", event.value);
      },
      clearHighlightedValue({ context }) {
        context.set("highlightedValue", null);
      },
      selectHighlightedItem(params) {
        const { context, prop } = params;
        const collection22 = prop("collection");
        const highlightedValue = context.get("highlightedValue");
        if (!highlightedValue || !collection22.has(highlightedValue)) return;
        const nextValue = prop("multiple") ? addOrRemove(context.get("value"), highlightedValue) : [highlightedValue];
        prop("onSelect")?.({ value: nextValue, itemValue: highlightedValue });
        context.set("value", nextValue);
        const inputValue = match(prop("selectionBehavior"), {
          preserve: context.get("inputValue"),
          replace: collection22.stringifyMany(nextValue),
          clear: ""
        });
        context.set("inputValue", inputValue);
      },
      scrollToHighlightedItem({ context, prop, scope }) {
        nextTick(() => {
          const highlightedValue = context.get("highlightedValue");
          if (highlightedValue == null) return;
          const itemEl = getItemEl(scope, highlightedValue);
          const contentEl = getContentEl2(scope);
          const scrollToIndexFn = prop("scrollToIndexFn");
          if (scrollToIndexFn) {
            const highlightedIndex = prop("collection").indexOf(highlightedValue);
            scrollToIndexFn({
              index: highlightedIndex,
              immediate: true,
              getElement: () => getItemEl(scope, highlightedValue)
            });
            return;
          }
          scrollIntoView(itemEl, { rootEl: contentEl, block: "nearest" });
        });
      },
      selectItem(params) {
        const { context, event, flush: flush2, prop } = params;
        if (event.value == null) return;
        flush2(() => {
          const nextValue = prop("multiple") ? addOrRemove(context.get("value"), event.value) : [event.value];
          prop("onSelect")?.({ value: nextValue, itemValue: event.value });
          context.set("value", nextValue);
          const inputValue = match(prop("selectionBehavior"), {
            preserve: context.get("inputValue"),
            replace: prop("collection").stringifyMany(nextValue),
            clear: ""
          });
          context.set("inputValue", inputValue);
        });
      },
      clearItem(params) {
        const { context, event, flush: flush2, prop } = params;
        if (event.value == null) return;
        flush2(() => {
          const nextValue = remove(context.get("value"), event.value);
          context.set("value", nextValue);
          const inputValue = match(prop("selectionBehavior"), {
            preserve: context.get("inputValue"),
            replace: prop("collection").stringifyMany(nextValue),
            clear: ""
          });
          context.set("inputValue", inputValue);
        });
      },
      setInitialFocus({ scope }) {
        raf(() => {
          focusInputEl(scope);
        });
      },
      setFinalFocus({ scope }) {
        raf(() => {
          const triggerEl = getTriggerEl(scope);
          if (triggerEl?.dataset.focusable == null) {
            focusInputEl(scope);
          } else {
            focusTriggerEl(scope);
          }
        });
      },
      syncInputValue({ context, scope, event }) {
        const inputEl = getInputEl(scope);
        if (!inputEl) return;
        inputEl.value = context.get("inputValue");
        queueMicrotask(() => {
          if (event.current().type === "INPUT.CHANGE") return;
          setCaretToEnd(inputEl);
        });
      },
      setInputValue({ context, event }) {
        context.set("inputValue", event.value);
      },
      clearInputValue({ context }) {
        context.set("inputValue", "");
      },
      revertInputValue({ context, prop, computed }) {
        const selectionBehavior = prop("selectionBehavior");
        const inputValue = match(selectionBehavior, {
          replace: computed("hasSelectedItems") ? computed("valueAsString") : "",
          preserve: context.get("inputValue"),
          clear: ""
        });
        context.set("inputValue", inputValue);
      },
      setValue(params) {
        const { context, flush: flush2, event, prop } = params;
        flush2(() => {
          context.set("value", event.value);
          const inputValue = match(prop("selectionBehavior"), {
            preserve: context.get("inputValue"),
            replace: prop("collection").stringifyMany(event.value),
            clear: ""
          });
          context.set("inputValue", inputValue);
        });
      },
      clearSelectedItems(params) {
        const { context, flush: flush2, prop } = params;
        flush2(() => {
          context.set("value", []);
          const inputValue = match(prop("selectionBehavior"), {
            preserve: context.get("inputValue"),
            replace: prop("collection").stringifyMany([]),
            clear: ""
          });
          context.set("inputValue", inputValue);
        });
      },
      scrollContentToTop({ prop, scope }) {
        const scrollToIndexFn = prop("scrollToIndexFn");
        if (scrollToIndexFn) {
          const firstValue = prop("collection").firstValue;
          scrollToIndexFn({
            index: 0,
            immediate: true,
            getElement: () => getItemEl(scope, firstValue)
          });
        } else {
          const contentEl = getContentEl2(scope);
          if (!contentEl) return;
          contentEl.scrollTop = 0;
        }
      },
      invokeOnOpen({ prop, event, context }) {
        const reason = getOpenChangeReason(event);
        prop("onOpenChange")?.({ open: true, reason, value: context.get("value") });
      },
      invokeOnClose({ prop, event, context }) {
        const reason = getOpenChangeReason(event);
        prop("onOpenChange")?.({ open: false, reason, value: context.get("value") });
      },
      highlightFirstItem({ context, prop, scope }) {
        const exec = getContentEl2(scope) ? queueMicrotask : raf;
        exec(() => {
          const value = prop("collection").firstValue;
          if (value) context.set("highlightedValue", value);
        });
      },
      highlightFirstItemIfNeeded({ computed, action }) {
        if (!computed("autoHighlight")) return;
        action(["highlightFirstItem"]);
      },
      highlightLastItem({ context, prop, scope }) {
        const exec = getContentEl2(scope) ? queueMicrotask : raf;
        exec(() => {
          const value = prop("collection").lastValue;
          if (value) context.set("highlightedValue", value);
        });
      },
      highlightNextItem({ context, prop }) {
        let value = null;
        const highlightedValue = context.get("highlightedValue");
        const collection22 = prop("collection");
        if (highlightedValue) {
          value = collection22.getNextValue(highlightedValue);
          if (!value && prop("loopFocus")) value = collection22.firstValue;
        } else {
          value = collection22.firstValue;
        }
        if (value) context.set("highlightedValue", value);
      },
      highlightPrevItem({ context, prop }) {
        let value = null;
        const highlightedValue = context.get("highlightedValue");
        const collection22 = prop("collection");
        if (highlightedValue) {
          value = collection22.getPreviousValue(highlightedValue);
          if (!value && prop("loopFocus")) value = collection22.lastValue;
        } else {
          value = collection22.lastValue;
        }
        if (value) context.set("highlightedValue", value);
      },
      highlightFirstSelectedItem({ context, prop }) {
        raf(() => {
          const [value] = prop("collection").sort(context.get("value"));
          if (value) context.set("highlightedValue", value);
        });
      },
      highlightFirstOrSelectedItem({ context, prop, computed }) {
        raf(() => {
          let value = null;
          if (computed("hasSelectedItems")) {
            value = prop("collection").sort(context.get("value"))[0];
          } else {
            value = prop("collection").firstValue;
          }
          if (value) context.set("highlightedValue", value);
        });
      },
      highlightLastOrSelectedItem({ context, prop, computed }) {
        raf(() => {
          const collection22 = prop("collection");
          let value = null;
          if (computed("hasSelectedItems")) {
            value = collection22.sort(context.get("value"))[0];
          } else {
            value = collection22.lastValue;
          }
          if (value) context.set("highlightedValue", value);
        });
      },
      autofillInputValue({ context, computed, prop, event, scope }) {
        const inputEl = getInputEl(scope);
        const collection22 = prop("collection");
        if (!computed("autoComplete") || !inputEl || !event.keypress) return;
        const valueText = collection22.stringify(context.get("highlightedValue"));
        raf(() => {
          inputEl.value = valueText || context.get("inputValue");
        });
      },
      syncSelectedItems(params) {
        queueMicrotask(() => {
          const { context, prop } = params;
          const collection22 = prop("collection");
          const value = context.get("value");
          const selectedItems = value.map((v) => {
            const item = context.get("selectedItems").find((item2) => collection22.getItemValue(item2) === v);
            return item || collection22.find(v);
          });
          context.set("selectedItems", selectedItems);
          const inputValue = match(prop("selectionBehavior"), {
            preserve: context.get("inputValue"),
            replace: collection22.stringifyMany(value),
            clear: ""
          });
          context.set("inputValue", inputValue);
        });
      },
      syncHighlightedItem({ context, prop }) {
        const item = prop("collection").find(context.get("highlightedValue"));
        context.set("highlightedItem", item);
      },
      toggleVisibility({ event, send, prop }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
function getOpenChangeReason(event) {
  return (event.previousEvent || event).src;
}
var props5 = createProps()([
  "allowCustomValue",
  "autoFocus",
  "closeOnSelect",
  "collection",
  "composite",
  "defaultHighlightedValue",
  "defaultInputValue",
  "defaultOpen",
  "defaultValue",
  "dir",
  "disabled",
  "disableLayer",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "inputBehavior",
  "inputValue",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "navigate",
  "onFocusOutside",
  "onHighlightChange",
  "onInputValueChange",
  "onInteractOutside",
  "onOpenChange",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "onValueChange",
  "open",
  "openOnChange",
  "openOnClick",
  "openOnKeyPress",
  "placeholder",
  "positioning",
  "readOnly",
  "required",
  "scrollToIndexFn",
  "selectionBehavior",
  "translations",
  "value",
  "alwaysSubmitOnEnter"
]);
var splitProps6 = createSplitProps(props5);
var itemGroupLabelProps = createProps()(["htmlFor"]);
var splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);
var itemGroupProps = createProps()(["id"]);
var splitItemGroupProps = createSplitProps(itemGroupProps);
var itemProps3 = createProps()(["item", "persistFocus"]);
var splitItemProps3 = createSplitProps(itemProps3);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item-group-label.svelte
Item_group_label[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item-group-label.svelte";
var root_236 = add_locations(from_html(`<div><!></div>`), Item_group_label[FILENAME], [[34, 1]]);
function Item_group_label($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_group_label);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const itemGroupProps4 = ItemGroupContext.consume();
  const $$d = user_derived(() => splitItemGroupLabelProps({ htmlFor: itemGroupProps4().id, ...props25 })), $$array = tag(user_derived(() => to_array(get($$d), 1)), "[$derived iterable]"), itemGroupLabelProps4 = tag(user_derived(() => get($$array)[0]), "itemGroupLabelProps");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getItemGroupLabelProps(get(itemGroupLabelProps4)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_group_label, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_236();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_group_label, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_group_label,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_group_label = hmr(Item_group_label);
  import.meta.hot.accept((module) => {
    Item_group_label[HMR].update(module.default);
  });
}
var item_group_label_default = Item_group_label;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item-group.svelte
Item_group2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item-group.svelte";
var root_237 = add_locations(from_html(`<div><!></div>`), Item_group2[FILENAME], [[36, 1]]);
function Item_group2($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Item_group2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const $$d = user_derived(() => splitItemGroupProps({ id, ...props25 })), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemGroupProps4 = tag(user_derived(() => get($$array)[0]), "itemGroupProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getItemGroupProps(get(itemGroupProps4)), get(rest))), "attributes");
  ItemGroupContext.provide(() => get(itemGroupProps4));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_group2, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_237();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_group2, 37, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_group2,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_group2 = hmr(Item_group2);
  import.meta.hot.accept((module) => {
    Item_group2[HMR].update(module.default);
  });
}
var item_group_default2 = Item_group2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/check.svelte
Check[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/check.svelte";
var root = add_locations(from_svg(`<svg><path d="M20 6 9 17l-5-5"></path></svg>`), Check[FILENAME], [[31, 0, [[32, 1]]]]);
function Check($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Check);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const rest = tag(user_derived(() => exclude_from_object(props25, [])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var svg = root();
  attribute_effect(svg, () => ({ ...get(attributes) }));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Check = hmr(Check);
  import.meta.hot.accept((module) => {
    Check[HMR].update(module.default);
  });
}
var check_default = Check;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/modules/item-context.js
var ItemContext2 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item-indicator.svelte
Item_indicator2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item-indicator.svelte";
var check = wrap_snippet(Item_indicator2, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => check_default(node, { class: "size-4" }), "component", Item_indicator2, 25, 1, { componentTag: "Check" });
  append($$anchor, fragment);
});
var root_3 = add_locations(from_html(`<div><!></div>`), Item_indicator2[FILENAME], [[31, 1]]);
function Item_indicator2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_indicator2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const itemProps13 = ItemContext2.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, check)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getItemIndicatorProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node_1 = first_child(fragment_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_2, () => get(element2), () => get(attributes)), "render", Item_indicator2, 29, 1);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var div = root_3();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_3 = child(div);
      add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Item_indicator2, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_indicator2,
      28,
      0
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_indicator2 = hmr(Item_indicator2);
  import.meta.hot.accept((module) => {
    Item_indicator2[HMR].update(module.default);
  });
}
var item_indicator_default2 = Item_indicator2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item-text.svelte
Item_text[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item-text.svelte";
var root_238 = add_locations(from_html(`<span><!></span>`), Item_text[FILENAME], [[26, 1]]);
function Item_text($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_text);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const itemProps13 = ItemContext2.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getItemTextProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_text, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_238();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_text, 27, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_text,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_text = hmr(Item_text);
  import.meta.hot.accept((module) => {
    Item_text[HMR].update(module.default);
  });
}
var item_text_default = Item_text;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item.svelte
Item3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/item.svelte";
var root_239 = add_locations(from_html(`<li><!></li>`), Item3[FILENAME], [[30, 1]]);
function Item3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const $$d = user_derived(() => splitItemProps3(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getItemProps(get(itemProps13)), get(rest))), "attributes");
  ItemContext2.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item3, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var li = root_239();
      attribute_effect(li, () => ({ ...get(attributes) }));
      var node_2 = child(li);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item3, 31, 2);
      reset(li);
      append($$anchor2, li);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item3,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item3 = hmr(Item3);
  import.meta.hot.accept((module) => {
    Item3[HMR].update(module.default);
  });
}
var item_default3 = Item3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/label.svelte
Label[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/label.svelte";
var root_240 = add_locations(from_html(`<label><!></label>`), Label[FILENAME], [[24, 1]]);
function Label($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_240();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label, 25, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label = hmr(Label);
  import.meta.hot.accept((module) => {
    Label[HMR].update(module.default);
  });
}
var label_default = Label;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/positioner.svelte
Positioner[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/positioner.svelte";
var root_241 = add_locations(from_html(`<div><!></div>`), Positioner[FILENAME], [[24, 1]]);
function Positioner($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Positioner);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getPositionerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Positioner, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_241();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Positioner, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Positioner,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Positioner = hmr(Positioner);
  import.meta.hot.accept((module) => {
    Positioner[HMR].update(module.default);
  });
}
var positioner_default = Positioner;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/root-context.svelte
Root_context5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/root-context.svelte";
function Root_context5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => combobox), "render", Root_context5, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context5 = hmr(Root_context5);
  import.meta.hot.accept((module) => {
    Root_context5[HMR].update(module.default);
  });
}
var root_context_default5 = Root_context5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/root-provider.svelte
Root_provider5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/root-provider.svelte";
var root_242 = add_locations(from_html(`<div><!></div>`), Root_provider5[FILENAME], [[27, 1]]);
function Root_provider5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), combobox = tag(user_derived(() => $$props.value), "combobox"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(combobox)().getRootProps(), get(rest))), "attributes");
  RootContext5.provide(() => get(combobox)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider5, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_242();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider5, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider5,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider5 = hmr(Root_provider5);
  import.meta.hot.accept((module) => {
    Root_provider5[HMR].update(module.default);
  });
}
var root_provider_default5 = Root_provider5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/modules/provider.svelte.js
function useCombobox(props25) {
  const service = useMachine(machine5, props25);
  const combobox = tag(user_derived(() => connect5(service, normalizeProps)), "combobox");
  return () => get(combobox);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/root.svelte
Root6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/root.svelte";
var root_243 = add_locations(from_html(`<div><!></div>`), Root6[FILENAME], [[34, 1]]);
function Root6($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps6(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), comboboxProps = tag(user_derived(() => get($$array)[0]), "comboboxProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const combobox = useCombobox(() => ({ ...get(comboboxProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(combobox().getRootProps(), get(rest))), "attributes");
  RootContext5.provide(() => combobox());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root6, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_243();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root6, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root6,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root6 = hmr(Root6);
  import.meta.hot.accept((module) => {
    Root6[HMR].update(module.default);
  });
}
var root_default6 = Root6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/chevron-down.svelte
Chevron_down[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/chevron-down.svelte";
var root2 = add_locations(from_svg(`<svg><path d="m6 9 6 6 6-6"></path></svg>`), Chevron_down[FILENAME], [[31, 0, [[32, 1]]]]);
function Chevron_down($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Chevron_down);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const rest = tag(user_derived(() => exclude_from_object(props25, [])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var svg = root2();
  attribute_effect(svg, () => ({ ...get(attributes) }));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Chevron_down = hmr(Chevron_down);
  import.meta.hot.accept((module) => {
    Chevron_down[HMR].update(module.default);
  });
}
var chevron_down_default = Chevron_down;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/trigger.svelte
Trigger2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/anatomy/trigger.svelte";
var chevronDown = wrap_snippet(Trigger2, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => chevron_down_default(node, {}), "component", Trigger2, 23, 1, { componentTag: "ChevronDownIcon" });
  append($$anchor, fragment);
});
var root_32 = add_locations(from_html(`<button><!></button>`), Trigger2[FILENAME], [[29, 1]]);
function Trigger2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const combobox = RootContext5.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, chevronDown)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(combobox().getTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node_1 = first_child(fragment_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_2, () => get(element2), () => get(attributes)), "render", Trigger2, 27, 1);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var button = root_32();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_3 = child(button);
      add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Trigger2, 30, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger2,
      26,
      0
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger2 = hmr(Trigger2);
  import.meta.hot.accept((module) => {
    Trigger2[HMR].update(module.default);
  });
}
var trigger_default2 = Trigger2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/combobox/modules/anatomy.js
var Combobox = Object.assign(root_default6, {
  Provider: root_provider_default5,
  Context: root_context_default5,
  Label: label_default,
  Control: control_default2,
  Input: input_default,
  Trigger: trigger_default2,
  ClearTrigger: clear_trigger_default,
  Positioner: positioner_default,
  Content: content_default2,
  ItemGroup: item_group_default2,
  ItemGroupLabel: item_group_label_default,
  Item: item_default3,
  ItemText: item_text_default,
  ItemIndicator: item_indicator_default2
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/modules/root-context.js
var RootContext6 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/content.svelte
Content3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/content.svelte";
var root_244 = add_locations(from_html(`<div><!></div>`), Content3[FILENAME], [[24, 1]]);
function Content3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getContentProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_244();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content3, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content3 = hmr(Content3);
  import.meta.hot.accept((module) => {
    Content3[HMR].update(module.default);
  });
}
var content_default3 = Content3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/control.svelte
Control3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/control.svelte";
var root_245 = add_locations(from_html(`<div><!></div>`), Control3[FILENAME], [[24, 1]]);
function Control3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getControlProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Control3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_245();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Control3, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Control3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Control3 = hmr(Control3);
  import.meta.hot.accept((module) => {
    Control3[HMR].update(module.default);
  });
}
var control_default3 = Control3;

// node_modules/@internationalized/date/dist/utils.mjs
function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
  return amount - numerator * Math.floor(amount / numerator);
}

// node_modules/@internationalized/date/dist/GregorianCalendar.mjs
var $3b62074eb05584b2$var$EPOCH = 1721426;
function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
  year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
  let y1 = year - 1;
  let monthOffset = -2;
  if (month <= 2) monthOffset = 0;
  else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;
  return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
  return era === "BC" ? 1 - year : year;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
  let era = "AD";
  if (year <= 0) {
    era = "BC";
    year = 1 - year;
  }
  return [
    era,
    year
  ];
}
var $3b62074eb05584b2$var$daysInMonth = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
var $3b62074eb05584b2$export$80ee6245ec4f29ec = class {
  fromJulianDay(jd) {
    let jd0 = jd;
    let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
    let quadricent = Math.floor(depoch / 146097);
    let dqc = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);
    let cent = Math.floor(dqc / 36524);
    let dcent = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);
    let quad = Math.floor(dcent / 1461);
    let dquad = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);
    let yindex = Math.floor(dquad / 365);
    let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
    let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
    let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
    let leapAdj = 2;
    if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;
    let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
    let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);
  }
  toJulianDay(date) {
    return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
  }
  getDaysInMonth(date) {
    return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(date) {
    return 12;
  }
  getDaysInYear(date) {
    return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(date) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(date) {
    return date.era === "BC";
  }
  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === "BC" ? "AD" : "BC";
      date.year = 1 - date.year;
    }
  }
  constructor() {
    this.identifier = "gregory";
  }
};

// node_modules/@internationalized/date/dist/weekStartData.mjs
var $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};

// node_modules/@internationalized/date/dist/queries.mjs
function $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b) {
  b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);
  return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a, b) {
  b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);
  a = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a);
  b = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b);
  return a.era === b.era && a.year === b.year && a.month === b.month;
}
function $14e0f24ef4ac5c92$export$5841f9eb9773f25f(a, b) {
  b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);
  a = $14e0f24ef4ac5c92$export$f91e89d3d0406102(a);
  b = $14e0f24ef4ac5c92$export$f91e89d3d0406102(b);
  return a.era === b.era && a.year === b.year;
}
function $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a, b) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a.calendar, b.calendar) && $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b);
}
function $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(a, b) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a.calendar, b.calendar) && $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a, b);
}
function $14e0f24ef4ac5c92$export$ea840f5a6dda8147(a, b) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a.calendar, b.calendar) && $14e0f24ef4ac5c92$export$5841f9eb9773f25f(a, b);
}
function $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a, b) {
  var _a_isEqual, _b_isEqual;
  var _a_isEqual1, _ref;
  return (_ref = (_a_isEqual1 = (_a_isEqual = a.isEqual) === null || _a_isEqual === void 0 ? void 0 : _a_isEqual.call(a, b)) !== null && _a_isEqual1 !== void 0 ? _a_isEqual1 : (_b_isEqual = b.isEqual) === null || _b_isEqual === void 0 ? void 0 : _b_isEqual.call(b, a)) !== null && _ref !== void 0 ? _ref : a.identifier === b.identifier;
}
function $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
}
var $14e0f24ef4ac5c92$var$DAY_MAP = {
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6
};
function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek) {
  let julian = date.calendar.toJulianDay(date);
  let weekStart = firstDayOfWeek ? $14e0f24ef4ac5c92$var$DAY_MAP[firstDayOfWeek] : $14e0f24ef4ac5c92$var$getWeekStart(locale);
  let dayOfWeek = Math.ceil(julian + 1 - weekStart) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  return dayOfWeek;
}
function $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {
  return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(Date.now(), timeZone);
}
function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {
  return (0, $11d87f3f76e88657$export$93522d1a439f3617)($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a, b) {
  return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a, b) {
  return $14e0f24ef4ac5c92$var$timeToMs(a) - $14e0f24ef4ac5c92$var$timeToMs(b);
}
function $14e0f24ef4ac5c92$var$timeToMs(a) {
  return a.hour * 36e5 + a.minute * 6e4 + a.second * 1e3 + a.millisecond;
}
var $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
  if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  return $14e0f24ef4ac5c92$var$localTimeZone;
}
function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {
  return date.subtract({
    days: date.day - 1
  });
}
function $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {
  return date.add({
    days: date.calendar.getDaysInMonth(date) - date.day
  });
}
function $14e0f24ef4ac5c92$export$f91e89d3d0406102(date) {
  return $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date.subtract({
    months: date.month - 1
  }));
}
function $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(date) {
  return $14e0f24ef4ac5c92$export$a2258d9c4118825c(date.add({
    months: date.calendar.getMonthsInYear(date) - date.month
  }));
}
function $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDayOfWeek) {
  let dayOfWeek = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek);
  return date.subtract({
    days: dayOfWeek
  });
}
function $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(date, locale, firstDayOfWeek) {
  return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDayOfWeek).add({
    days: 6
  });
}
var $14e0f24ef4ac5c92$var$cachedRegions = /* @__PURE__ */ new Map();
var $14e0f24ef4ac5c92$var$cachedWeekInfo = /* @__PURE__ */ new Map();
function $14e0f24ef4ac5c92$var$getRegion(locale) {
  if (Intl.Locale) {
    let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);
    if (!region) {
      region = new Intl.Locale(locale).maximize().region;
      if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);
    }
    return region;
  }
  let part = locale.split("-")[1];
  return part === "u" ? void 0 : part;
}
function $14e0f24ef4ac5c92$var$getWeekStart(locale) {
  let weekInfo = $14e0f24ef4ac5c92$var$cachedWeekInfo.get(locale);
  if (!weekInfo) {
    if (Intl.Locale) {
      let localeInst = new Intl.Locale(locale);
      if ("getWeekInfo" in localeInst) {
        weekInfo = localeInst.getWeekInfo();
        if (weekInfo) {
          $14e0f24ef4ac5c92$var$cachedWeekInfo.set(locale, weekInfo);
          return weekInfo.firstDay;
        }
      }
    }
    let region = $14e0f24ef4ac5c92$var$getRegion(locale);
    if (locale.includes("-fw-")) {
      let day = locale.split("-fw-")[1].split("-")[0];
      if (day === "mon") weekInfo = {
        firstDay: 1
      };
      else if (day === "tue") weekInfo = {
        firstDay: 2
      };
      else if (day === "wed") weekInfo = {
        firstDay: 3
      };
      else if (day === "thu") weekInfo = {
        firstDay: 4
      };
      else if (day === "fri") weekInfo = {
        firstDay: 5
      };
      else if (day === "sat") weekInfo = {
        firstDay: 6
      };
      else weekInfo = {
        firstDay: 0
      };
    } else if (locale.includes("-ca-iso8601")) weekInfo = {
      firstDay: 1
    };
    else weekInfo = {
      firstDay: region ? (0, $2fe286d2fb449abb$export$7a5acbd77d414bd9)[region] || 0 : 0
    };
    $14e0f24ef4ac5c92$var$cachedWeekInfo.set(locale, weekInfo);
  }
  return weekInfo.firstDay;
}
function $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(date, locale, firstDayOfWeek) {
  let days = date.calendar.getDaysInMonth(date);
  return Math.ceil(($14e0f24ef4ac5c92$export$2061056d06d7cdf7($14e0f24ef4ac5c92$export$a5a3b454ada2268e(date), locale, firstDayOfWeek) + days) / 7);
}
function $14e0f24ef4ac5c92$export$5c333a116e949cdd(a, b) {
  if (a && b) return a.compare(b) <= 0 ? a : b;
  return a || b;
}
function $14e0f24ef4ac5c92$export$a75f2bff57811055(a, b) {
  if (a && b) return a.compare(b) >= 0 ? a : b;
  return a || b;
}
var $14e0f24ef4ac5c92$var$WEEKEND_DATA = {
  AF: [
    4,
    5
  ],
  AE: [
    5,
    6
  ],
  BH: [
    5,
    6
  ],
  DZ: [
    5,
    6
  ],
  EG: [
    5,
    6
  ],
  IL: [
    5,
    6
  ],
  IQ: [
    5,
    6
  ],
  IR: [
    5,
    5
  ],
  JO: [
    5,
    6
  ],
  KW: [
    5,
    6
  ],
  LY: [
    5,
    6
  ],
  OM: [
    5,
    6
  ],
  QA: [
    5,
    6
  ],
  SA: [
    5,
    6
  ],
  SD: [
    5,
    6
  ],
  SY: [
    5,
    6
  ],
  YE: [
    5,
    6
  ]
};
function $14e0f24ef4ac5c92$export$618d60ea299da42(date, locale) {
  let julian = date.calendar.toJulianDay(date);
  let dayOfWeek = Math.ceil(julian + 1) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  let [start, end] = $14e0f24ef4ac5c92$var$WEEKEND_DATA[region] || [
    6,
    0
  ];
  return dayOfWeek === start || dayOfWeek === end;
}

// node_modules/@internationalized/date/dist/conversion.mjs
function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
  date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
  return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
  let date = /* @__PURE__ */ new Date();
  date.setUTCHours(hour, minute, second, millisecond);
  date.setUTCFullYear(year, month - 1, day);
  return date.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {
  if (timeZone === "UTC") return 0;
  if (ms > 0 && timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -6e4;
  let { year, month, day, hour, minute, second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);
  let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
  return utc - Math.floor(ms / 1e3) * 1e3;
}
var $11d87f3f76e88657$var$formattersByTimeZone = /* @__PURE__ */ new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {
  let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat("en-US", {
      timeZone,
      hour12: false,
      era: "short",
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
  }
  let parts26 = formatter.formatToParts(new Date(ms));
  let namedParts = {};
  for (let part of parts26) if (part.type !== "literal") namedParts[part.type] = part.value;
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
    month: +namedParts.month,
    day: +namedParts.day,
    hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
    minute: +namedParts.minute,
    second: +namedParts.second
  };
}
var $11d87f3f76e88657$var$DAYMILLIS = 864e5;
function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
  let found = earlier === later ? [
    earlier
  ] : [
    earlier,
    later
  ];
  return found.filter((absolute) => $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
}
function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
  let parts26 = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
  return date.year === parts26.year && date.month === parts26.month && date.day === parts26.day && date.hour === parts26.hour && date.minute === parts26.minute && date.second === parts26.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
  let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
  if (timeZone === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  if (timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
    dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
    let date2 = /* @__PURE__ */ new Date();
    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
    date2.setFullYear(year, dateTime.month - 1, dateTime.day);
    date2.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
    return date2.getTime();
  }
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
  if (valid.length === 1) return valid[0];
  if (valid.length > 1) switch (disambiguation) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return valid[0];
    case "later":
      return valid[valid.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (disambiguation) {
    case "earlier":
      return Math.min(ms - offsetBefore, ms - offsetAfter);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(ms - offsetBefore, ms - offsetAfter);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
  return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {
  let offset2 = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);
  let date = new Date(ms + offset2);
  let year = date.getUTCFullYear();
  let month = date.getUTCMonth() + 1;
  let day = date.getUTCDate();
  let hour = date.getUTCHours();
  let minute = date.getUTCMinutes();
  let second = date.getUTCSeconds();
  let millisecond = date.getUTCMilliseconds();
  return new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(year < 1 ? "BC" : "AD", year < 1 ? -year + 1 : year, month, day, timeZone, offset2, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
  let hour = 0, minute = 0, second = 0, millisecond = 0;
  if ("timeZone" in date) ({ hour, minute, second, millisecond } = date);
  else if ("hour" in date && !time) return date;
  if (time) ({ hour, minute, second, millisecond } = time);
  return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
  if ((0, $14e0f24ef4ac5c92$export$dbc69fd56b53d5e)(date.calendar, calendar)) return date;
  let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
  let copy = date.copy();
  copy.calendar = calendar;
  copy.era = calendarDate.era;
  copy.year = calendarDate.year;
  copy.month = calendarDate.month;
  copy.day = calendarDate.day;
  (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(copy);
  return copy;
}
function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
  if (date instanceof (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)) {
    if (date.timeZone === timeZone) return date;
    return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
  }
  let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
  return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return new Date(ms);
}
function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}

// node_modules/@internationalized/date/dist/manipulation.mjs
var $735220c2d4774dd3$var$ONE_HOUR = 36e5;
function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
  let mutableDate = date.copy();
  let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
  $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
  if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
  mutableDate.month += duration.months || 0;
  $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
  $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
  mutableDate.day += (duration.weeks || 0) * 7;
  mutableDate.day += duration.days || 0;
  mutableDate.day += days;
  $735220c2d4774dd3$var$balanceDay(mutableDate);
  if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
  if (mutableDate.year < 1) {
    mutableDate.year = 1;
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
  if (mutableDate.year > maxYear) {
    var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
    let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
    mutableDate.year = maxYear;
    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  if (mutableDate.month < 1) {
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
  if (mutableDate.month > maxMonth) {
    mutableDate.month = maxMonth;
    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
  return mutableDate;
}
function $735220c2d4774dd3$var$addYears(date, years) {
  var _date_calendar_isInverseEra, _date_calendar;
  if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
  date.year += years;
}
function $735220c2d4774dd3$var$balanceYearMonth(date) {
  while (date.month < 1) {
    $735220c2d4774dd3$var$addYears(date, -1);
    date.month += date.calendar.getMonthsInYear(date);
  }
  let monthsInYear = 0;
  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {
    date.month -= monthsInYear;
    $735220c2d4774dd3$var$addYears(date, 1);
  }
}
function $735220c2d4774dd3$var$balanceDay(date) {
  while (date.day < 1) {
    date.month--;
    $735220c2d4774dd3$var$balanceYearMonth(date);
    date.day += date.calendar.getDaysInMonth(date);
  }
  while (date.day > date.calendar.getDaysInMonth(date)) {
    date.day -= date.calendar.getDaysInMonth(date);
    date.month++;
    $735220c2d4774dd3$var$balanceYearMonth(date);
  }
}
function $735220c2d4774dd3$var$constrainMonthDay(date) {
  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
  if (date.calendar.constrainDate) date.calendar.constrainDate(date);
  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
  $735220c2d4774dd3$var$constrainMonthDay(date);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
  let inverseDuration = {};
  for (let key in duration) if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
  return inverseDuration;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
  return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
  let mutableDate = date.copy();
  if (fields.era != null) mutableDate.era = fields.era;
  if (fields.year != null) mutableDate.year = fields.year;
  if (fields.month != null) mutableDate.month = fields.month;
  if (fields.day != null) mutableDate.day = fields.day;
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
  return mutableDate;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
  let mutableValue = value.copy();
  if (fields.hour != null) mutableValue.hour = fields.hour;
  if (fields.minute != null) mutableValue.minute = fields.minute;
  if (fields.second != null) mutableValue.second = fields.second;
  if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
  $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
  return mutableValue;
}
function $735220c2d4774dd3$var$balanceTime(time) {
  time.second += Math.floor(time.millisecond / 1e3);
  time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1e3);
  time.minute += Math.floor(time.second / 60);
  time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
  time.hour += Math.floor(time.minute / 60);
  time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
  let days = Math.floor(time.hour / 24);
  time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
  return days;
}
function $735220c2d4774dd3$export$7555de1e070510cb(time) {
  time.millisecond = Math.max(0, Math.min(time.millisecond, 1e3));
  time.second = Math.max(0, Math.min(time.second, 59));
  time.minute = Math.max(0, Math.min(time.minute, 59));
  time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(a, b) {
  let result = a % b;
  if (result < 0) result += b;
  return result;
}
function $735220c2d4774dd3$var$addTimeFields(time, duration) {
  time.hour += duration.hours || 0;
  time.minute += duration.minutes || 0;
  time.second += duration.seconds || 0;
  time.millisecond += duration.milliseconds || 0;
  return $735220c2d4774dd3$var$balanceTime(time);
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "era": {
      let eras = value.calendar.getEras();
      let eraIndex = eras.indexOf(value.era);
      if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
      eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
      mutable.era = eras[eraIndex];
      $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
      break;
    }
    case "year":
      var _mutable_calendar_isInverseEra, _mutable_calendar;
      if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
      mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
      if (mutable.year === -Infinity) mutable.year = 1;
      if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
      break;
    case "month":
      mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    case "day":
      mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
  return mutable;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "hour": {
      let hours = value.hour;
      let min3 = 0;
      let max3 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = hours >= 12;
        min3 = isPM ? 12 : 0;
        max3 = isPM ? 23 : 11;
      }
      mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min3, max3, options === null || options === void 0 ? void 0 : options.round);
      break;
    }
    case "minute":
      mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "second":
      mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "millisecond":
      mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  return mutable;
}
function $735220c2d4774dd3$var$cycleValue(value, amount, min3, max3, round2 = false) {
  if (round2) {
    value += Math.sign(amount);
    if (value < min3) value = max3;
    let div = Math.abs(amount);
    if (amount > 0) value = Math.ceil(value / div) * div;
    else value = Math.floor(value / div) * div;
    if (value > max3) value = min3;
  } else {
    value += amount;
    if (value < min3) value = max3 - (min3 - value - 1);
    else if (value > max3) value = min3 + (value - max3 - 1);
  }
  return value;
}
function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
  let ms;
  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
    let res2 = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {
      years: duration.years,
      months: duration.months,
      weeks: duration.weeks,
      days: duration.days
    });
    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res2, dateTime.timeZone);
  } else
    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
  ms += duration.milliseconds || 0;
  ms += (duration.seconds || 0) * 1e3;
  ms += (duration.minutes || 0) * 6e4;
  ms += (duration.hours || 0) * 36e5;
  let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
  return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
  switch (field) {
    case "hour": {
      let min3 = 0;
      let max3 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = dateTime.hour >= 12;
        min3 = isPM ? 12 : 0;
        max3 = isPM ? 23 : 11;
      }
      let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
      let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: min3
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let minAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === minDate.day)[0];
      let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: max3
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let maxAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === maxDate.day).pop();
      let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
      let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);
      let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;
      ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
    case "era":
    case "year":
    case "month":
    case "day": {
      let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);
      let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    default:
      throw new Error("Unsupported field " + field);
  }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
  let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
  if (res.compare(plainDateTime) === 0) return dateTime;
  let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
}

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$DATE_RE = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})$/;
var $fae977aafc393c5c$var$ABSOLUTE_RE = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::?(\d{2}))?)|Z)$/;
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
function $fae977aafc393c5c$export$6b862160d295c8e(value) {
  let m = value.match($fae977aafc393c5c$var$DATE_RE);
  if (!m) {
    if ($fae977aafc393c5c$var$ABSOLUTE_RE.test(value)) throw new Error(`Invalid ISO 8601 date string: ${value}. Use parseAbsolute() instead.`);
    throw new Error("Invalid ISO 8601 date string: " + value);
  }
  let date = new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)($fae977aafc393c5c$var$parseNumber(m[1], 0, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1);
  date.day = $fae977aafc393c5c$var$parseNumber(m[3], 1, date.calendar.getDaysInMonth(date));
  return date;
}
function $fae977aafc393c5c$var$parseNumber(value, min3, max3) {
  let val = Number(value);
  if (val < min3 || val > max3) throw new RangeError(`Value out of range: ${min3} <= ${val} <= ${max3}`);
  return val;
}
function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
  return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1e3).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
  let gregorianDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year;
  if (gregorianDate.era === "BC") year = gregorianDate.year === 1 ? "0000" : "-" + String(Math.abs(1 - gregorianDate.year)).padStart(6, "00");
  else year = String(gregorianDate.year).padStart(4, "0");
  return `${year}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(date) {
  return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
}
function $fae977aafc393c5c$var$offsetToString(offset2) {
  let sign3 = Math.sign(offset2) < 0 ? "-" : "+";
  offset2 = Math.abs(offset2);
  let offsetHours = Math.floor(offset2 / 36e5);
  let offsetMinutes = Math.floor(offset2 % 36e5 / 6e4);
  let offsetSeconds = Math.floor(offset2 % 36e5 % 6e4 / 1e3);
  let stringOffset = `${sign3}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
  if (offsetSeconds !== 0) stringOffset += `:${String(offsetSeconds).padStart(2, "0")}`;
  return stringOffset;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
  return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@internationalized/date/dist/CalendarDate.mjs
function $35ea8db9cb2ccb90$var$shiftArgs(args) {
  let calendar = typeof args[0] === "object" ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();
  let era;
  if (typeof args[0] === "string") era = args.shift();
  else {
    let eras = calendar.getEras();
    era = eras[eras.length - 1];
  }
  let year = args.shift();
  let month = args.shift();
  let day = args.shift();
  return [
    calendar,
    era,
    year,
    month,
    day
  ];
}
var $35ea8db9cb2ccb90$var$_type = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$99faa760c7908e4f = class _$35ea8db9cb2ccb90$export$99faa760c7908e4f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
    else return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(timeZone) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type2 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$ca871e8dbb80966f = class _$35ea8db9cb2ccb90$export$ca871e8dbb80966f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    switch (field) {
      case "era":
      case "year":
      case "month":
      case "day":
        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
      default:
        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(timeZone, disambiguation) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
    if (res === 0) return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b));
    return res;
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type2, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type3 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$d3b7288e7994edea = class _$35ea8db9cb2ccb90$export$d3b7288e7994edea {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields, disambiguation) {
    return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type3, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    let timeZone = args.shift();
    let offset2 = args.shift();
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.timeZone = timeZone;
    this.offset = offset2;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/@internationalized/date/dist/DateFormatter.mjs
var $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
var $fb18d541ea1ad717$export$ad991b66133851cf = class {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(value) {
    return this.formatter.format(value);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(value) {
    return this.formatter.formatToParts(value);
  }
  /** Formats a date range as a string. */
  formatRange(start, end) {
    if (typeof this.formatter.formatRange === "function")
      return this.formatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(start)}  ${this.formatter.format(end)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.formatter.formatRangeToParts === "function")
      return this.formatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.formatter.formatToParts(start);
    let endParts = this.formatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let resolvedOptions = this.formatter.resolvedOptions();
    if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
      if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
      resolvedOptions.hourCycle = this.resolvedHourCycle;
      resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
    }
    if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
    return resolvedOptions;
  }
  constructor(locale, options = {}) {
    this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
    this.options = options;
  }
};
var $fb18d541ea1ad717$var$hour12Preferences = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
  if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
    options = {
      ...options
    };
    let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
    let defaultHourCycle = options.hour12 ? "h12" : "h23";
    options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
    delete options.hour12;
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.DateTimeFormat(locale, options);
  $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
var $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
  if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: false
  }).format(new Date(2020, 2, 3, 0)) === "24";
  return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
var $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
  if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: false
  }).resolvedOptions().hourCycle === "h12";
  return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
  if (!options.timeStyle && !options.hour) return void 0;
  locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
  locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
  let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
    ...options,
    timeZone: void 0
    // use local timezone
  });
  let min3 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p) => p.type === "hour").value, 10);
  let max3 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p) => p.type === "hour").value, 10);
  if (min3 === 0 && max3 === 23) return "h23";
  if (min3 === 24 && max3 === 23) return "h24";
  if (min3 === 0 && max3 === 11) return "h11";
  if (min3 === 12 && max3 === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}

// node_modules/@zag-js/date-utils/dist/index.mjs
function alignCenter(date, duration, locale, min3, max3) {
  const halfDuration = {};
  for (let prop in duration) {
    const key = prop;
    const value = duration[key];
    if (value == null) continue;
    halfDuration[key] = Math.floor(value / 2);
    if (halfDuration[key] > 0 && value % 2 === 0) {
      halfDuration[key]--;
    }
  }
  const aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min3, max3);
}
function alignStart(date, duration, locale, min3, max3) {
  let aligned = date;
  if (duration.years) {
    aligned = $14e0f24ef4ac5c92$export$f91e89d3d0406102(date);
  } else if (duration.months) {
    aligned = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date);
  } else if (duration.weeks) {
    aligned = $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, min3, max3);
}
function alignEnd(date, duration, locale, min3, max3) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  let aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min3, max3);
}
function constrainStart(date, aligned, duration, locale, min3, max3) {
  if (min3 && date.compare(min3) >= 0) {
    aligned = $14e0f24ef4ac5c92$export$a75f2bff57811055(aligned, alignStart($11d87f3f76e88657$export$93522d1a439f3617(min3), duration, locale));
  }
  if (max3 && date.compare(max3) <= 0) {
    aligned = $14e0f24ef4ac5c92$export$5c333a116e949cdd(aligned, alignEnd($11d87f3f76e88657$export$93522d1a439f3617(max3), duration, locale));
  }
  return aligned;
}
function constrainValue(date, minValue, maxValue) {
  let constrainedDate = $11d87f3f76e88657$export$93522d1a439f3617(date);
  if (minValue) {
    constrainedDate = $14e0f24ef4ac5c92$export$a75f2bff57811055(constrainedDate, $11d87f3f76e88657$export$93522d1a439f3617(minValue));
  }
  if (maxValue) {
    constrainedDate = $14e0f24ef4ac5c92$export$5c333a116e949cdd(constrainedDate, $11d87f3f76e88657$export$93522d1a439f3617(maxValue));
  }
  return constrainedDate;
}
function alignDate(date, alignment, duration, locale, min3, max3) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min3, max3);
    case "end":
      return alignEnd(date, duration, locale, min3, max3);
    case "center":
    default:
      return alignCenter(date, duration, locale, min3, max3);
  }
}
function isDateEqual(dateA, dateB) {
  if (dateA == null || dateB == null) return dateA === dateB;
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(dateA, dateB);
}
function isDateUnavailable(date, isUnavailable, locale, minValue, maxValue) {
  if (!date) return false;
  if (isUnavailable?.(date, locale)) return true;
  return isDateOutsideRange(date, minValue, maxValue);
}
function isDateOutsideRange(date, startDate, endDate) {
  return startDate != null && date.compare(startDate) < 0 || endDate != null && date.compare(endDate) > 0;
}
function isPreviousRangeInvalid(startDate, minValue, maxValue) {
  const prevDate = startDate.subtract({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevDate, startDate) || isDateOutsideRange(prevDate, minValue, maxValue);
}
function isNextRangeInvalid(endDate, minValue, maxValue) {
  const nextDate = endDate.add({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(nextDate, endDate) || isDateOutsideRange(nextDate, minValue, maxValue);
}
function getUnitDuration(duration) {
  let clone = { ...duration };
  for (let key in clone) clone[key] = 1;
  return clone;
}
function getEndDate(startDate, duration) {
  let clone = { ...duration };
  if (clone.days) clone.days--;
  else clone.days = -1;
  return startDate.add(clone);
}
function getEraFormat(date) {
  return date?.calendar.identifier === "gregory" && date.era === "BC" ? "short" : void 0;
}
function getDayFormatter(locale, timeZone) {
  const date = $11d87f3f76e88657$export$b21e0b124e224484($14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(date),
    timeZone
  });
}
function getMonthFormatter(locale, timeZone) {
  const date = $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone);
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    month: "long",
    year: "numeric",
    era: getEraFormat(date),
    calendar: date?.calendar.identifier,
    timeZone
  });
}
function formatRange(startDate, endDate, formatter, toString, timeZone) {
  let parts26 = formatter.formatRangeToParts(startDate.toDate(timeZone), endDate.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts26.length; i++) {
    let part = parts26[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let start = "";
  let end = "";
  for (let i = 0; i < parts26.length; i++) {
    if (i < separatorIndex) {
      start += parts26[i].value;
    } else if (i > separatorIndex) {
      end += parts26[i].value;
    }
  }
  return toString(start, end);
}
function formatSelectedDate(startDate, endDate, locale, timeZone) {
  if (!startDate) return "";
  let start = startDate;
  let end = endDate ?? startDate;
  let formatter = getDayFormatter(locale, timeZone);
  if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) {
    return formatter.format(start.toDate(timeZone));
  }
  return formatRange(start, end, formatter, (start2, end2) => `${start2}  ${end2}`, timeZone);
}
var daysOfTheWeek = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function normalizeFirstDayOfWeek(firstDayOfWeek) {
  return firstDayOfWeek != null ? daysOfTheWeek[firstDayOfWeek] : void 0;
}
function getStartOfWeek(date, locale, firstDayOfWeek) {
  const firstDay = normalizeFirstDayOfWeek(firstDayOfWeek);
  return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDay);
}
function getDaysInWeek(weekIndex, from, locale, firstDayOfWeek) {
  const weekDate = from.add({ weeks: weekIndex });
  const dates = [];
  let date = getStartOfWeek(weekDate, locale, firstDayOfWeek);
  while (dates.length < 7) {
    dates.push(date);
    let nextDate = date.add({ days: 1 });
    if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(date, nextDate)) break;
    date = nextDate;
  }
  return dates;
}
function getMonthDays(from, locale, numOfWeeks, firstDayOfWeek) {
  const firstDay = normalizeFirstDayOfWeek(firstDayOfWeek);
  const monthWeeks = numOfWeeks ?? $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(from, locale, firstDay);
  const weeks = [...new Array(monthWeeks).keys()];
  return weeks.map((week) => getDaysInWeek(week, from, locale, firstDayOfWeek));
}
function getWeekdayFormats(locale, timeZone) {
  const longFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "long", timeZone });
  const shortFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "short", timeZone });
  const narrowFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "narrow", timeZone });
  return (value) => {
    const date = value instanceof Date ? value : value.toDate(timeZone);
    return {
      value,
      short: shortFormat.format(date),
      long: longFormat.format(date),
      narrow: narrowFormat.format(date)
    };
  };
}
function getWeekDays(date, startOfWeekProp, timeZone, locale) {
  const firstDayOfWeek = getStartOfWeek(date, locale, startOfWeekProp);
  const weeks = [...new Array(7).keys()];
  const format = getWeekdayFormats(locale, timeZone);
  return weeks.map((index) => format(firstDayOfWeek.add({ days: index })));
}
function getMonthNames(locale, format = "long") {
  const date = new Date(2021, 0, 1);
  const monthNames = [];
  for (let i = 0; i < 12; i++) {
    monthNames.push(date.toLocaleString(locale, { month: format }));
    date.setMonth(date.getMonth() + 1);
  }
  return monthNames;
}
function getYearsRange(range2) {
  const years = [];
  for (let year = range2.from; year <= range2.to; year += 1) years.push(year);
  return years;
}
var FUTURE_YEAR_COERCION = 10;
function normalizeYear(year) {
  if (!year) return;
  if (year.length === 3) return year.padEnd(4, "0");
  if (year.length === 2) {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const currentCentury = Math.floor(currentYear / 100) * 100;
    const twoDigitYear = parseInt(year.slice(-2), 10);
    const fullYear = currentCentury + twoDigitYear;
    return fullYear > currentYear + FUTURE_YEAR_COERCION ? (fullYear - 100).toString() : fullYear.toString();
  }
  return year;
}
function getDecadeRange(year, opts) {
  const chunkSize = opts?.strict ? 10 : 12;
  const computedYear = year - year % 10;
  const years = [];
  for (let i = 0; i < chunkSize; i += 1) {
    const value = computedYear + i;
    years.push(value);
  }
  return years;
}
function getTodayDate(timeZone) {
  return $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone ?? $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
}
function getAdjustedDateFn(visibleDuration, locale, minValue, maxValue) {
  return function getDate(options) {
    const { startDate, focusedDate } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateOutsideRange(focusedDate, minValue, maxValue)) {
      return {
        startDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue),
        endDate
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue),
        focusedDate: constrainValue(focusedDate, minValue, maxValue),
        endDate
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, minValue, maxValue),
        endDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, minValue, maxValue)
    };
  };
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  const start = startDate.add(visibleDuration);
  return adjust({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  let start = startDate.subtract(visibleDuration);
  return adjust({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.add({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({ years: 1 }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.subtract({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({ years: 1 }),
      startDate
    });
  }
}
var isValidYear = (year) => year != null && year.length === 4;
var isValidMonth = (month) => month != null && parseFloat(month) <= 12;
var isValidDay = (day) => day != null && parseFloat(day) <= 31;
function parseDateString(date, locale, timeZone) {
  const regex = createRegex(locale, timeZone);
  let { year, month, day } = extract(regex, date) ?? {};
  const hasMatch = year != null || month != null || day != null;
  if (hasMatch) {
    const curr = /* @__PURE__ */ new Date();
    year || (year = curr.getFullYear().toString());
    month || (month = (curr.getMonth() + 1).toString());
    day || (day = curr.getDate().toString());
  }
  if (!isValidYear(year)) {
    year = normalizeYear(year);
  }
  if (isValidYear(year) && isValidMonth(month) && isValidDay(day)) {
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(+year, +month, +day);
  }
  const time = Date.parse(date);
  if (!isNaN(time)) {
    const date2 = new Date(time);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(date2.getFullYear(), date2.getMonth() + 1, date2.getDate());
  }
}
function createRegex(locale, timeZone) {
  const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { day: "numeric", month: "numeric", year: "numeric", timeZone });
  const parts26 = formatter.formatToParts(new Date(2e3, 11, 25));
  return parts26.map(({ type, value }) => type === "literal" ? `${value}?` : `((?!=<${type}>)\\d+)?`).join("");
}
function extract(pattern, str) {
  const matches = str.match(pattern);
  return pattern.toString().match(/<(.+?)>/g)?.map((group2) => {
    const groupMatches = group2.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return group2.match(/<(.+)>/)?.[1];
  }).reduce((acc, curr, index) => {
    if (!curr) return acc;
    if (matches && matches.length > index) {
      acc[curr] = matches[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}
function getDateRangePreset(preset, locale, timeZone) {
  const today3 = $11d87f3f76e88657$export$93522d1a439f3617($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
  switch (preset) {
    case "thisWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today3, locale), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today3, locale)];
    case "thisMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3), today3];
    case "thisQuarter":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3).add({ months: -((today3.month - 1) % 3) }), today3];
    case "thisYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today3), today3];
    case "last3Days":
      return [today3.add({ days: -2 }), today3];
    case "last7Days":
      return [today3.add({ days: -6 }), today3];
    case "last14Days":
      return [today3.add({ days: -13 }), today3];
    case "last30Days":
      return [today3.add({ days: -29 }), today3];
    case "last90Days":
      return [today3.add({ days: -89 }), today3];
    case "lastMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3.add({ months: -1 })), $14e0f24ef4ac5c92$export$a2258d9c4118825c(today3.add({ months: -1 }))];
    case "lastQuarter":
      return [
        $14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3.add({ months: -((today3.month - 1) % 3) - 3 })),
        $14e0f24ef4ac5c92$export$a2258d9c4118825c(today3.add({ months: -((today3.month - 1) % 3) - 1 }))
      ];
    case "lastWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today3, locale).add({ weeks: -1 }), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today3, locale).add({ weeks: -1 })];
    case "lastYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today3.add({ years: -1 })), $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(today3.add({ years: -1 }))];
    default:
      throw new Error(`Invalid date range preset: ${preset}`);
  }
}

// node_modules/@zag-js/live-region/dist/index.mjs
var ID = "__live-region__";
function createLiveRegion(opts = {}) {
  const { level = "polite", document: doc = document, root: root10, delay: _delay = 0 } = opts;
  const win = doc.defaultView ?? window;
  const parent = root10 ?? doc.body;
  function announce(message, delay2) {
    const oldRegion = doc.getElementById(ID);
    oldRegion?.remove();
    delay2 = delay2 ?? _delay;
    const region = doc.createElement("span");
    region.id = ID;
    region.dataset.liveAnnouncer = "true";
    const role = level !== "assertive" ? "status" : "alert";
    region.setAttribute("aria-live", level);
    region.setAttribute("role", role);
    Object.assign(region.style, {
      border: "0",
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0",
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap",
      wordWrap: "normal"
    });
    parent.appendChild(region);
    win.setTimeout(() => {
      region.textContent = message;
    }, delay2);
  }
  function destroy() {
    const oldRegion = doc.getElementById(ID);
    oldRegion?.remove();
  }
  return {
    announce,
    destroy,
    toJSON() {
      return ID;
    }
  };
}

// node_modules/@zag-js/date-picker/dist/index.mjs
var anatomy6 = createAnatomy("date-picker").parts(
  "clearTrigger",
  "content",
  "control",
  "input",
  "label",
  "monthSelect",
  "nextTrigger",
  "positioner",
  "presetTrigger",
  "prevTrigger",
  "rangeText",
  "root",
  "table",
  "tableBody",
  "tableCell",
  "tableCellTrigger",
  "tableHead",
  "tableHeader",
  "tableRow",
  "trigger",
  "view",
  "viewControl",
  "viewTrigger",
  "yearSelect"
);
var parts6 = anatomy6.build();
var getLabelId2 = (ctx, index) => ctx.ids?.label?.(index) ?? `datepicker:${ctx.id}:label:${index}`;
var getRootId6 = (ctx) => ctx.ids?.root ?? `datepicker:${ctx.id}`;
var getTableId = (ctx, id) => ctx.ids?.table?.(id) ?? `datepicker:${ctx.id}:table:${id}`;
var getContentId3 = (ctx) => ctx.ids?.content ?? `datepicker:${ctx.id}:content`;
var getCellTriggerId = (ctx, id) => ctx.ids?.cellTrigger?.(id) ?? `datepicker:${ctx.id}:cell-trigger:${id}`;
var getPrevTriggerId2 = (ctx, view) => ctx.ids?.prevTrigger?.(view) ?? `datepicker:${ctx.id}:prev:${view}`;
var getNextTriggerId2 = (ctx, view) => ctx.ids?.nextTrigger?.(view) ?? `datepicker:${ctx.id}:next:${view}`;
var getViewTriggerId = (ctx, view) => ctx.ids?.viewTrigger?.(view) ?? `datepicker:${ctx.id}:view:${view}`;
var getClearTriggerId2 = (ctx) => ctx.ids?.clearTrigger ?? `datepicker:${ctx.id}:clear`;
var getControlId2 = (ctx) => ctx.ids?.control ?? `datepicker:${ctx.id}:control`;
var getInputId2 = (ctx, index) => ctx.ids?.input?.(index) ?? `datepicker:${ctx.id}:input:${index}`;
var getTriggerId3 = (ctx) => ctx.ids?.trigger ?? `datepicker:${ctx.id}:trigger`;
var getPositionerId2 = (ctx) => ctx.ids?.positioner ?? `datepicker:${ctx.id}:positioner`;
var getMonthSelectId = (ctx) => ctx.ids?.monthSelect ?? `datepicker:${ctx.id}:month-select`;
var getYearSelectId = (ctx) => ctx.ids?.yearSelect ?? `datepicker:${ctx.id}:year-select`;
var getFocusedCell = (ctx, view) => query(getContentEl3(ctx), `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`);
var getTriggerEl2 = (ctx) => ctx.getById(getTriggerId3(ctx));
var getContentEl3 = (ctx) => ctx.getById(getContentId3(ctx));
var getInputEls = (ctx) => queryAll(getControlEl2(ctx), `[data-part=input]`);
var getYearSelectEl = (ctx) => ctx.getById(getYearSelectId(ctx));
var getMonthSelectEl = (ctx) => ctx.getById(getMonthSelectId(ctx));
var getClearTriggerEl2 = (ctx) => ctx.getById(getClearTriggerId2(ctx));
var getPositionerEl2 = (ctx) => ctx.getById(getPositionerId2(ctx));
var getControlEl2 = (ctx) => ctx.getById(getControlId2(ctx));
function adjustStartAndEndDate(value) {
  const [startDate, endDate] = value;
  let result;
  if (!startDate || !endDate) result = value;
  else result = startDate.compare(endDate) <= 0 ? value : [endDate, startDate];
  return result;
}
function isDateWithinRange(date, value) {
  const [startDate, endDate] = value;
  if (!startDate || !endDate) return false;
  return startDate.compare(date) <= 0 && endDate.compare(date) >= 0;
}
function sortDates(values) {
  return values.slice().filter((date) => date != null).sort((a, b) => a.compare(b));
}
function getRoleDescription(view) {
  return match(view, {
    year: "calendar decade",
    month: "calendar year",
    day: "calendar month"
  });
}
var PLACEHOLDERS = {
  day: "dd",
  month: "mm",
  year: "yyyy"
};
function getInputPlaceholder(locale) {
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale).formatToParts(/* @__PURE__ */ new Date()).map((item) => PLACEHOLDERS[item.type] ?? item.value).join("");
}
var isValidCharacter = (char, separator) => {
  if (!char) return true;
  return /\d/.test(char) || char === separator || char.length !== 1;
};
var isValidDate = (value) => {
  return !Number.isNaN(value.day) && !Number.isNaN(value.month) && !Number.isNaN(value.year);
};
var ensureValidCharacters = (value, separator) => {
  return value.split("").filter((char) => isValidCharacter(char, separator)).join("");
};
function getLocaleSeparator(locale) {
  const dateFormatter = new Intl.DateTimeFormat(locale);
  const parts26 = dateFormatter.formatToParts(/* @__PURE__ */ new Date());
  const literalPart = parts26.find((part) => part.type === "literal");
  return literalPart ? literalPart.value : "/";
}
var defaultTranslations = {
  dayCell(state3) {
    if (state3.unavailable) return `Not available. ${state3.formattedDate}`;
    if (state3.selected) return `Selected date. ${state3.formattedDate}`;
    return `Choose ${state3.formattedDate}`;
  },
  trigger(open) {
    return open ? "Close calendar" : "Open calendar";
  },
  viewTrigger(view) {
    return match(view, {
      year: "Switch to month view",
      month: "Switch to day view",
      day: "Switch to year view"
    });
  },
  presetTrigger(value) {
    const [start = "", end = ""] = value;
    return `select ${start} to ${end}`;
  },
  prevTrigger(view) {
    return match(view, {
      year: "Switch to previous decade",
      month: "Switch to previous year",
      day: "Switch to previous month"
    });
  },
  nextTrigger(view) {
    return match(view, {
      year: "Switch to next decade",
      month: "Switch to next year",
      day: "Switch to next month"
    });
  },
  // TODO: Revisit this
  placeholder() {
    return { day: "dd", month: "mm", year: "yyyy" };
  },
  content: "calendar",
  monthSelect: "Select month",
  yearSelect: "Select year",
  clearTrigger: "Clear selected dates"
};
function viewToNumber(view, fallback3) {
  if (!view) return fallback3 || 0;
  return view === "day" ? 0 : view === "month" ? 1 : 2;
}
function viewNumberToView(viewNumber) {
  return viewNumber === 0 ? "day" : viewNumber === 1 ? "month" : "year";
}
function clampView(view, minView, maxView) {
  return viewNumberToView(
    clampValue(viewToNumber(view, 0), viewToNumber(minView, 0), viewToNumber(maxView, 2))
  );
}
function isAboveMinView(view, minView) {
  return viewToNumber(view, 0) > viewToNumber(minView, 0);
}
function isBelowMinView(view, minView) {
  return viewToNumber(view, 0) < viewToNumber(minView, 0);
}
function getNextView(view, minView, maxView) {
  const nextViewNumber = viewToNumber(view, 0) + 1;
  return clampView(viewNumberToView(nextViewNumber), minView, maxView);
}
function getPreviousView(view, minView, maxView) {
  const prevViewNumber = viewToNumber(view, 0) - 1;
  return clampView(viewNumberToView(prevViewNumber), minView, maxView);
}
var views = ["day", "month", "year"];
function eachView(cb) {
  views.forEach((view) => cb(view));
}
function connect6(service, normalize2) {
  const { state: state3, context, prop, send, computed, scope } = service;
  const startValue = context.get("startValue");
  const endValue = computed("endValue");
  const selectedValue = context.get("value");
  const focusedValue = context.get("focusedValue");
  const hoveredValue = context.get("hoveredValue");
  const hoveredRangeValue = hoveredValue ? adjustStartAndEndDate([selectedValue[0], hoveredValue]) : [];
  const disabled = Boolean(prop("disabled"));
  const readOnly = Boolean(prop("readOnly"));
  const invalid = Boolean(prop("invalid"));
  const interactive = computed("isInteractive");
  const min3 = prop("min");
  const max3 = prop("max");
  const locale = prop("locale");
  const timeZone = prop("timeZone");
  const startOfWeek = prop("startOfWeek");
  const focused = state3.matches("focused");
  const open = state3.matches("open");
  const isRangePicker = prop("selectionMode") === "range";
  const isDateUnavailableFn = prop("isDateUnavailable");
  const currentPlacement = context.get("currentPlacement");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: currentPlacement
  });
  const separator = getLocaleSeparator(locale);
  const translations = { ...defaultTranslations, ...prop("translations") };
  function getMonthWeeks(from = startValue) {
    const numOfWeeks = prop("fixedWeeks") ? 6 : void 0;
    return getMonthDays(from, locale, numOfWeeks, startOfWeek);
  }
  function getMonths(props25 = {}) {
    const { format } = props25;
    return getMonthNames(locale, format).map((label, index) => {
      const value = index + 1;
      const dateValue = focusedValue.set({ month: value });
      const disabled2 = isDateOutsideRange(dateValue, min3, max3);
      return { label, value, disabled: disabled2 };
    });
  }
  function getYears() {
    const range2 = getYearsRange({ from: min3?.year ?? 1900, to: max3?.year ?? 2100 });
    return range2.map((year) => ({
      label: year.toString(),
      value: year,
      disabled: !isValueWithinRange(year, min3?.year, max3?.year)
    }));
  }
  function getDecadeYears(year) {
    const range2 = getDecadeRange(startValue.year);
    return range2.map((year2) => ({
      label: year2.toString(),
      value: year2,
      disabled: !isValueWithinRange(year2, min3?.year, max3?.year)
    }));
  }
  function isUnavailable(date) {
    return isDateUnavailable(date, isDateUnavailableFn, locale, min3, max3);
  }
  function focusMonth(month) {
    const date = startValue ?? getTodayDate(timeZone);
    send({ type: "FOCUS.SET", value: date.set({ month }) });
  }
  function focusYear(year) {
    const date = startValue ?? getTodayDate(timeZone);
    send({ type: "FOCUS.SET", value: date.set({ year }) });
  }
  function getYearTableCellState(props25) {
    const { value, disabled: disabled2 } = props25;
    const dateValue = focusedValue.set({ year: value });
    const decadeYears = getDecadeRange(startValue.year, { strict: true });
    const isOutsideVisibleRange = !decadeYears.includes(value);
    const isOutsideRange = isValueWithinRange(value, min3?.year, max3?.year);
    const cellState = {
      focused: focusedValue.year === props25.value,
      selectable: isOutsideVisibleRange || isOutsideRange,
      outsideRange: isOutsideVisibleRange,
      selected: !!selectedValue.find((date) => date && date.year === value),
      valueText: value.toString(),
      inRange: isRangePicker && (isDateWithinRange(dateValue, selectedValue) || isDateWithinRange(dateValue, hoveredRangeValue)),
      value: dateValue,
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  function getMonthTableCellState(props25) {
    const { value, disabled: disabled2 } = props25;
    const dateValue = focusedValue.set({ month: value });
    const formatter = getMonthFormatter(locale, timeZone);
    const cellState = {
      focused: focusedValue.month === props25.value,
      selectable: !isDateOutsideRange(dateValue, min3, max3),
      selected: !!selectedValue.find((date) => date && date.month === value && date.year === focusedValue.year),
      valueText: formatter.format(dateValue.toDate(timeZone)),
      inRange: isRangePicker && (isDateWithinRange(dateValue, selectedValue) || isDateWithinRange(dateValue, hoveredRangeValue)),
      value: dateValue,
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  function getDayTableCellState(props25) {
    const { value, disabled: disabled2, visibleRange = computed("visibleRange") } = props25;
    const formatter = getDayFormatter(locale, timeZone);
    const unitDuration = getUnitDuration(computed("visibleDuration"));
    const outsideDaySelectable = prop("outsideDaySelectable");
    const end = visibleRange.start.add(unitDuration).subtract({ days: 1 });
    const isOutsideRange = isDateOutsideRange(value, visibleRange.start, end);
    const isInSelectedRange = isRangePicker && isDateWithinRange(value, selectedValue);
    const isFirstInSelectedRange = isRangePicker && isDateEqual(value, selectedValue[0]);
    const isLastInSelectedRange = isRangePicker && isDateEqual(value, selectedValue[1]);
    const hasHoveredRange = isRangePicker && hoveredRangeValue.length > 0;
    const isInHoveredRange = hasHoveredRange && isDateWithinRange(value, hoveredRangeValue);
    const isFirstInHoveredRange = hasHoveredRange && isDateEqual(value, hoveredRangeValue[0]);
    const isLastInHoveredRange = hasHoveredRange && isDateEqual(value, hoveredRangeValue[1]);
    const cellState = {
      invalid: isDateOutsideRange(value, min3, max3),
      disabled: disabled2 || !outsideDaySelectable && isOutsideRange || isDateOutsideRange(value, min3, max3),
      selected: selectedValue.some((date) => isDateEqual(value, date)),
      unavailable: isDateUnavailable(value, isDateUnavailableFn, locale, min3, max3) && !disabled2,
      outsideRange: isOutsideRange,
      today: $14e0f24ef4ac5c92$export$629b0a497aa65267(value, timeZone),
      weekend: $14e0f24ef4ac5c92$export$618d60ea299da42(value, locale),
      formattedDate: formatter.format(value.toDate(timeZone)),
      get focused() {
        return isDateEqual(value, focusedValue) && (!cellState.outsideRange || outsideDaySelectable);
      },
      get ariaLabel() {
        return translations.dayCell(cellState);
      },
      get selectable() {
        return !cellState.disabled && !cellState.unavailable;
      },
      // Range states
      inRange: isInSelectedRange || isInHoveredRange,
      firstInRange: isFirstInSelectedRange,
      lastInRange: isLastInSelectedRange,
      // Preview range states
      inHoveredRange: isInHoveredRange,
      firstInHoveredRange: isFirstInHoveredRange,
      lastInHoveredRange: isLastInHoveredRange
    };
    return cellState;
  }
  function getTableId2(props25) {
    const { view = "day", id } = props25;
    return [view, id].filter(Boolean).join(" ");
  }
  return {
    focused,
    open,
    disabled,
    invalid,
    inline: !!prop("inline"),
    view: context.get("view"),
    getRangePresetValue(preset) {
      return getDateRangePreset(preset, locale, timeZone);
    },
    getDaysInWeek(week, from = startValue) {
      return getDaysInWeek(week, from, locale, startOfWeek);
    },
    getOffset(duration) {
      const from = startValue.add(duration);
      const end = endValue.add(duration);
      const formatter = getMonthFormatter(locale, timeZone);
      return {
        visibleRange: { start: from, end },
        weeks: getMonthWeeks(from),
        visibleRangeText: {
          start: formatter.format(from.toDate(timeZone)),
          end: formatter.format(end.toDate(timeZone))
        }
      };
    },
    getMonthWeeks,
    isUnavailable,
    weeks: getMonthWeeks(),
    weekDays: getWeekDays(getTodayDate(timeZone), startOfWeek, timeZone, locale),
    visibleRangeText: computed("visibleRangeText"),
    value: selectedValue,
    valueAsDate: selectedValue.filter((date) => date != null).map((date) => date.toDate(timeZone)),
    valueAsString: computed("valueAsString"),
    focusedValue,
    focusedValueAsDate: focusedValue?.toDate(timeZone),
    focusedValueAsString: prop("format")(focusedValue, { locale, timeZone }),
    visibleRange: computed("visibleRange"),
    selectToday() {
      const value = constrainValue(getTodayDate(timeZone), min3, max3);
      send({ type: "VALUE.SET", value });
    },
    setValue(values) {
      const computedValue = values.map((date) => constrainValue(date, min3, max3));
      send({ type: "VALUE.SET", value: computedValue });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    setFocusedValue(value) {
      send({ type: "FOCUS.SET", value });
    },
    setOpen(nextOpen) {
      if (prop("inline")) return;
      const open2 = state3.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    focusMonth,
    focusYear,
    getYears,
    getMonths,
    getYearsGrid(props25 = {}) {
      const { columns = 1 } = props25;
      return chunk(getDecadeYears(), columns);
    },
    getDecade() {
      const years = getDecadeRange(focusedValue.year);
      return { start: years.at(0), end: years.at(-1) };
    },
    getMonthsGrid(props25 = {}) {
      const { columns = 1, format } = props25;
      return chunk(getMonths({ format }), columns);
    },
    format(value, opts = { month: "long", year: "numeric" }) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, opts).format(value.toDate(timeZone));
    },
    setView(view) {
      send({ type: "VIEW.SET", view });
    },
    goToNext() {
      send({ type: "GOTO.NEXT", view: context.get("view") });
    },
    goToPrev() {
      send({ type: "GOTO.PREV", view: context.get("view") });
    },
    getRootProps() {
      return normalize2.element({
        ...parts6.root.attrs,
        dir: prop("dir"),
        id: getRootId6(scope),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps(props25 = {}) {
      const { index = 0 } = props25;
      return normalize2.label({
        ...parts6.label.attrs,
        id: getLabelId2(scope, index),
        dir: prop("dir"),
        htmlFor: getInputId2(scope, index),
        "data-state": open ? "open" : "closed",
        "data-index": index,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts6.control.attrs,
        dir: prop("dir"),
        id: getControlId2(scope),
        "data-disabled": dataAttr(disabled)
      });
    },
    getRangeTextProps() {
      return normalize2.element({
        ...parts6.rangeText.attrs,
        dir: prop("dir")
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts6.content.attrs,
        hidden: !open,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        "data-inline": dataAttr(prop("inline")),
        id: getContentId3(scope),
        tabIndex: -1,
        role: "application",
        "aria-roledescription": "datepicker",
        "aria-label": translations.content
      });
    },
    getTableProps(props25 = {}) {
      const { view = "day", columns = view === "day" ? 7 : 4 } = props25;
      const uid = getTableId2(props25);
      return normalize2.element({
        ...parts6.table.attrs,
        role: "grid",
        "data-columns": columns,
        "aria-roledescription": getRoleDescription(view),
        id: getTableId(scope, uid),
        "aria-readonly": ariaAttr(readOnly),
        "aria-disabled": ariaAttr(disabled),
        "aria-multiselectable": ariaAttr(prop("selectionMode") !== "single"),
        "data-view": view,
        dir: prop("dir"),
        tabIndex: -1,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            Enter() {
              if (view === "day" && isUnavailable(focusedValue)) return;
              if (view === "month") {
                const cellState = getMonthTableCellState({ value: focusedValue.month });
                if (!cellState.selectable) return;
              }
              if (view === "year") {
                const cellState = getYearTableCellState({ value: focusedValue.year });
                if (!cellState.selectable) return;
              }
              send({ type: "TABLE.ENTER", view, columns, focus: true });
            },
            ArrowLeft() {
              send({ type: "TABLE.ARROW_LEFT", view, columns, focus: true });
            },
            ArrowRight() {
              send({ type: "TABLE.ARROW_RIGHT", view, columns, focus: true });
            },
            ArrowUp() {
              send({ type: "TABLE.ARROW_UP", view, columns, focus: true });
            },
            ArrowDown() {
              send({ type: "TABLE.ARROW_DOWN", view, columns, focus: true });
            },
            PageUp(event2) {
              send({ type: "TABLE.PAGE_UP", larger: event2.shiftKey, view, columns, focus: true });
            },
            PageDown(event2) {
              send({ type: "TABLE.PAGE_DOWN", larger: event2.shiftKey, view, columns, focus: true });
            },
            Home() {
              send({ type: "TABLE.HOME", view, columns, focus: true });
            },
            End() {
              send({ type: "TABLE.END", view, columns, focus: true });
            }
          };
          const exec = keyMap2[getEventKey(event, {
            dir: prop("dir")
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
            event.stopPropagation();
          }
        },
        onPointerLeave() {
          send({ type: "TABLE.POINTER_LEAVE" });
        },
        onPointerDown() {
          send({ type: "TABLE.POINTER_DOWN", view });
        },
        onPointerUp() {
          send({ type: "TABLE.POINTER_UP", view });
        }
      });
    },
    getTableHeadProps(props25 = {}) {
      const { view = "day" } = props25;
      return normalize2.element({
        ...parts6.tableHead.attrs,
        "aria-hidden": true,
        dir: prop("dir"),
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableHeaderProps(props25 = {}) {
      const { view = "day" } = props25;
      return normalize2.element({
        ...parts6.tableHeader.attrs,
        dir: prop("dir"),
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableBodyProps(props25 = {}) {
      const { view = "day" } = props25;
      return normalize2.element({
        ...parts6.tableBody.attrs,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableRowProps(props25 = {}) {
      const { view = "day" } = props25;
      return normalize2.element({
        ...parts6.tableRow.attrs,
        "aria-disabled": ariaAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "data-view": view
      });
    },
    getDayTableCellState,
    getDayTableCellProps(props25) {
      const { value } = props25;
      const cellState = getDayTableCellState(props25);
      return normalize2.element({
        ...parts6.tableCell.attrs,
        role: "gridcell",
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-selected": cellState.selected || cellState.inRange,
        "aria-invalid": ariaAttr(cellState.invalid),
        "aria-current": cellState.today ? "date" : void 0,
        "data-value": value.toString()
      });
    },
    getDayTableCellTriggerProps(props25) {
      const { value } = props25;
      const cellState = getDayTableCellState(props25);
      return normalize2.element({
        ...parts6.tableCellTrigger.attrs,
        id: getCellTriggerId(scope, value.toString()),
        role: "button",
        dir: prop("dir"),
        tabIndex: cellState.focused ? 0 : -1,
        "aria-label": cellState.ariaLabel,
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-invalid": ariaAttr(cellState.invalid),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-selected": dataAttr(cellState.selected),
        "data-value": value.toString(),
        "data-view": "day",
        "data-today": dataAttr(cellState.today),
        "data-focus": dataAttr(cellState.focused),
        "data-unavailable": dataAttr(cellState.unavailable),
        "data-range-start": dataAttr(cellState.firstInRange),
        "data-range-end": dataAttr(cellState.lastInRange),
        "data-in-range": dataAttr(cellState.inRange),
        "data-outside-range": dataAttr(cellState.outsideRange),
        "data-weekend": dataAttr(cellState.weekend),
        "data-in-hover-range": dataAttr(cellState.inHoveredRange),
        "data-hover-range-start": dataAttr(cellState.firstInHoveredRange),
        "data-hover-range-end": dataAttr(cellState.lastInHoveredRange),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "day", value });
        },
        onPointerMove: isRangePicker ? (event) => {
          if (event.pointerType === "touch") return;
          if (!cellState.selectable) return;
          const focus = !scope.isActiveElement(event.currentTarget);
          if (hoveredValue && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value, hoveredValue)) return;
          send({ type: "CELL.POINTER_MOVE", cell: "day", value, focus });
        } : void 0
      });
    },
    getMonthTableCellState,
    getMonthTableCellProps(props25) {
      const { value, columns } = props25;
      const cellState = getMonthTableCellState(props25);
      return normalize2.element({
        ...parts6.tableCell.attrs,
        dir: prop("dir"),
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected || cellState.inRange),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getMonthTableCellTriggerProps(props25) {
      const { value } = props25;
      const cellState = getMonthTableCellState(props25);
      return normalize2.element({
        ...parts6.tableCellTrigger.attrs,
        dir: prop("dir"),
        role: "button",
        id: getCellTriggerId(scope, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-focus": dataAttr(cellState.focused),
        "data-in-range": dataAttr(cellState.inRange),
        "data-outside-range": dataAttr(cellState.outsideRange),
        "aria-label": cellState.valueText,
        "data-view": "month",
        "data-value": value,
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "month", value });
        },
        onPointerMove: isRangePicker ? (event) => {
          if (event.pointerType === "touch") return;
          if (!cellState.selectable) return;
          const focus = !scope.isActiveElement(event.currentTarget);
          if (hoveredValue && cellState.value && $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(cellState.value, hoveredValue)) return;
          send({ type: "CELL.POINTER_MOVE", cell: "month", value: cellState.value, focus });
        } : void 0
      });
    },
    getYearTableCellState,
    getYearTableCellProps(props25) {
      const { value, columns } = props25;
      const cellState = getYearTableCellState(props25);
      return normalize2.element({
        ...parts6.tableCell.attrs,
        dir: prop("dir"),
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getYearTableCellTriggerProps(props25) {
      const { value } = props25;
      const cellState = getYearTableCellState(props25);
      return normalize2.element({
        ...parts6.tableCellTrigger.attrs,
        dir: prop("dir"),
        role: "button",
        id: getCellTriggerId(scope, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "data-focus": dataAttr(cellState.focused),
        "data-in-range": dataAttr(cellState.inRange),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "aria-label": cellState.valueText,
        "data-outside-range": dataAttr(cellState.outsideRange),
        "data-value": value,
        "data-view": "year",
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "year", value });
        },
        onPointerMove: isRangePicker ? (event) => {
          if (event.pointerType === "touch") return;
          if (!cellState.selectable) return;
          const focus = !scope.isActiveElement(event.currentTarget);
          if (hoveredValue && cellState.value && $14e0f24ef4ac5c92$export$ea840f5a6dda8147(cellState.value, hoveredValue)) return;
          send({ type: "CELL.POINTER_MOVE", cell: "year", value: cellState.value, focus });
        } : void 0
      });
    },
    getNextTriggerProps(props25 = {}) {
      const { view = "day" } = props25;
      const isDisabled = disabled || !computed("isNextVisibleRangeValid");
      return normalize2.button({
        ...parts6.nextTrigger.attrs,
        dir: prop("dir"),
        id: getNextTriggerId2(scope, view),
        type: "button",
        "aria-label": translations.nextTrigger(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "GOTO.NEXT", view });
        }
      });
    },
    getPrevTriggerProps(props25 = {}) {
      const { view = "day" } = props25;
      const isDisabled = disabled || !computed("isPrevVisibleRangeValid");
      return normalize2.button({
        ...parts6.prevTrigger.attrs,
        dir: prop("dir"),
        id: getPrevTriggerId2(scope, view),
        type: "button",
        "aria-label": translations.prevTrigger(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "GOTO.PREV", view });
        }
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts6.clearTrigger.attrs,
        id: getClearTriggerId2(scope),
        dir: prop("dir"),
        type: "button",
        "aria-label": translations.clearTrigger,
        hidden: !selectedValue.length,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "VALUE.CLEAR" });
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts6.trigger.attrs,
        id: getTriggerId3(scope),
        dir: prop("dir"),
        type: "button",
        "data-placement": currentPlacement,
        "aria-label": translations.trigger(open),
        "aria-controls": getContentId3(scope),
        "data-state": open ? "open" : "closed",
        "aria-haspopup": "grid",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "TRIGGER.CLICK" });
        }
      });
    },
    getViewProps(props25 = {}) {
      const { view = "day" } = props25;
      return normalize2.element({
        ...parts6.view.attrs,
        "data-view": view,
        hidden: context.get("view") !== view
      });
    },
    getViewTriggerProps(props25 = {}) {
      const { view = "day" } = props25;
      return normalize2.button({
        ...parts6.viewTrigger.attrs,
        "data-view": view,
        dir: prop("dir"),
        id: getViewTriggerId(scope, view),
        type: "button",
        disabled,
        "aria-label": translations.viewTrigger(view),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "VIEW.TOGGLE", src: "viewTrigger" });
        }
      });
    },
    getViewControlProps(props25 = {}) {
      const { view = "day" } = props25;
      return normalize2.element({
        ...parts6.viewControl.attrs,
        "data-view": view,
        dir: prop("dir")
      });
    },
    getInputProps(props25 = {}) {
      const { index = 0, fixOnBlur = true } = props25;
      return normalize2.input({
        ...parts6.input.attrs,
        id: getInputId2(scope, index),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        dir: prop("dir"),
        name: prop("name"),
        "data-index": index,
        "data-state": open ? "open" : "closed",
        readOnly,
        disabled,
        required: prop("required"),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        placeholder: prop("placeholder") || getInputPlaceholder(locale),
        defaultValue: computed("valueAsString")[index],
        onBeforeInput(event) {
          const { data } = getNativeEvent(event);
          if (!isValidCharacter(data, separator)) {
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur(event) {
          const value = event.currentTarget.value.trim();
          send({ type: "INPUT.BLUR", value, index, fixOnBlur });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            Enter(event2) {
              if (isComposingEvent(event2)) return;
              if (isUnavailable(focusedValue)) return;
              if (event2.currentTarget.value.trim() === "") return;
              send({ type: "INPUT.ENTER", value: event2.currentTarget.value, index });
            }
          };
          const exec = keyMap2[event.key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        },
        onInput(event) {
          const value = event.currentTarget.value;
          send({ type: "INPUT.CHANGE", value: ensureValidCharacters(value, separator), index });
        }
      });
    },
    getMonthSelectProps() {
      return normalize2.select({
        ...parts6.monthSelect.attrs,
        id: getMonthSelectId(scope),
        "aria-label": translations.monthSelect,
        disabled,
        dir: prop("dir"),
        defaultValue: startValue.month,
        onChange(event) {
          focusMonth(Number(event.currentTarget.value));
        }
      });
    },
    getYearSelectProps() {
      return normalize2.select({
        ...parts6.yearSelect.attrs,
        id: getYearSelectId(scope),
        disabled,
        "aria-label": translations.yearSelect,
        dir: prop("dir"),
        defaultValue: startValue.year,
        onChange(event) {
          focusYear(Number(event.currentTarget.value));
        }
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: getPositionerId2(scope),
        ...parts6.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getPresetTriggerProps(props25) {
      const value = Array.isArray(props25.value) ? props25.value : getDateRangePreset(props25.value, locale, timeZone);
      const valueAsString = value.filter((item) => item != null).map((item) => item.toDate(timeZone).toDateString());
      return normalize2.button({
        ...parts6.presetTrigger.attrs,
        "aria-label": translations.presetTrigger(valueAsString),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PRESET.CLICK", value });
        }
      });
    }
  };
}
var { and: and3 } = createGuards();
function isDateArrayEqual(a, b) {
  if (a?.length !== b?.length) return false;
  const len = Math.max(a.length, b.length);
  for (let i = 0; i < len; i++) {
    if (!isDateEqual(a[i], b[i])) return false;
  }
  return true;
}
function getValueAsString(value, prop) {
  return value.map((date) => {
    if (date == null) return "";
    return prop("format")(date, { locale: prop("locale"), timeZone: prop("timeZone") });
  });
}
var machine6 = createMachine({
  props({ props: props25 }) {
    const locale = props25.locale || "en-US";
    const timeZone = props25.timeZone || "UTC";
    const selectionMode = props25.selectionMode || "single";
    const numOfMonths = props25.numOfMonths || 1;
    const defaultValue = props25.defaultValue ? sortDates(props25.defaultValue).map((date) => constrainValue(date, props25.min, props25.max)) : void 0;
    const value = props25.value ? sortDates(props25.value).map((date) => constrainValue(date, props25.min, props25.max)) : void 0;
    let focusedValue = props25.focusedValue || props25.defaultFocusedValue || value?.[0] || defaultValue?.[0] || getTodayDate(timeZone);
    focusedValue = constrainValue(focusedValue, props25.min, props25.max);
    const minView = "day";
    const maxView = "year";
    const defaultView = clampView(props25.view || minView, minView, maxView);
    return {
      locale,
      numOfMonths,
      timeZone,
      selectionMode,
      defaultView,
      minView,
      maxView,
      outsideDaySelectable: false,
      closeOnSelect: true,
      format(date, { locale: locale2, timeZone: timeZone2 }) {
        const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale2, { timeZone: timeZone2, day: "2-digit", month: "2-digit", year: "numeric" });
        return formatter.format(date.toDate(timeZone2));
      },
      parse(value2, { locale: locale2, timeZone: timeZone2 }) {
        return parseDateString(value2, locale2, timeZone2);
      },
      ...props25,
      focusedValue: typeof props25.focusedValue === "undefined" ? void 0 : focusedValue,
      defaultFocusedValue: focusedValue,
      value,
      defaultValue: defaultValue ?? [],
      positioning: {
        placement: "bottom",
        ...props25.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen") || prop("inline");
    return open ? "open" : "idle";
  },
  refs() {
    return {
      announcer: void 0
    };
  },
  context({ prop, bindable: bindable2, getContext: getContext2 }) {
    return {
      focusedValue: bindable2(() => ({
        defaultValue: prop("defaultFocusedValue"),
        value: prop("focusedValue"),
        isEqual: isDateEqual,
        hash: (v) => v.toString(),
        sync: true,
        onChange(focusedValue) {
          const context = getContext2();
          const view = context.get("view");
          const value = context.get("value");
          const valueAsString = getValueAsString(value, prop);
          prop("onFocusChange")?.({ value, valueAsString, view, focusedValue });
        }
      })),
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual: isDateArrayEqual,
        hash: (v) => v.map((date) => date?.toString() ?? "").join(","),
        onChange(value) {
          const context = getContext2();
          const valueAsString = getValueAsString(value, prop);
          prop("onValueChange")?.({ value, valueAsString, view: context.get("view") });
        }
      })),
      inputValue: bindable2(() => ({
        defaultValue: ""
      })),
      activeIndex: bindable2(() => ({
        defaultValue: 0,
        sync: true
      })),
      hoveredValue: bindable2(() => ({
        defaultValue: null,
        isEqual: isDateEqual
      })),
      view: bindable2(() => ({
        defaultValue: prop("defaultView"),
        value: prop("view"),
        onChange(value) {
          prop("onViewChange")?.({ view: value });
        }
      })),
      startValue: bindable2(() => {
        const focusedValue = prop("focusedValue") || prop("defaultFocusedValue");
        return {
          defaultValue: alignDate(focusedValue, "start", { months: prop("numOfMonths") }, prop("locale")),
          isEqual: isDateEqual,
          hash: (v) => v.toString()
        };
      }),
      currentPlacement: bindable2(() => ({
        defaultValue: void 0
      })),
      restoreFocus: bindable2(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    isInteractive: ({ prop }) => !prop("disabled") && !prop("readOnly"),
    visibleDuration: ({ prop }) => ({ months: prop("numOfMonths") }),
    endValue: ({ context, computed }) => getEndDate(context.get("startValue"), computed("visibleDuration")),
    visibleRange: ({ context, computed }) => ({ start: context.get("startValue"), end: computed("endValue") }),
    visibleRangeText({ context, prop, computed }) {
      const timeZone = prop("timeZone");
      const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(prop("locale"), { month: "long", year: "numeric", timeZone });
      const start = formatter.format(context.get("startValue").toDate(timeZone));
      const end = formatter.format(computed("endValue").toDate(timeZone));
      const formatted = prop("selectionMode") === "range" ? `${start} - ${end}` : start;
      return { start, end, formatted };
    },
    isPrevVisibleRangeValid: ({ context, prop }) => !isPreviousRangeInvalid(context.get("startValue"), prop("min"), prop("max")),
    isNextVisibleRangeValid: ({ prop, computed }) => !isNextRangeInvalid(computed("endValue"), prop("min"), prop("max")),
    valueAsString: ({ context, prop }) => getValueAsString(context.get("value"), prop)
  },
  effects: ["setupLiveRegion"],
  watch({ track: track2, prop, context, action, computed }) {
    track2([() => prop("locale")], () => {
      action(["setStartValue", "syncInputElement"]);
    });
    track2([() => context.hash("focusedValue")], () => {
      action(["setStartValue", "focusActiveCellIfNeeded", "setHoveredValueIfKeyboard"]);
    });
    track2([() => context.hash("startValue")], () => {
      action(["syncMonthSelectElement", "syncYearSelectElement", "invokeOnVisibleRangeChange"]);
    });
    track2([() => context.get("inputValue")], () => {
      action(["syncInputValue"]);
    });
    track2([() => context.hash("value")], () => {
      action(["syncInputElement"]);
    });
    track2([() => computed("valueAsString").toString()], () => {
      action(["announceValueText"]);
    });
    track2([() => context.get("view")], () => {
      action(["focusActiveCell"]);
    });
    track2([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "VALUE.SET": {
      actions: ["setDateValue", "setFocusedDate"]
    },
    "VIEW.SET": {
      actions: ["setView"]
    },
    "FOCUS.SET": {
      actions: ["setFocusedDate"]
    },
    "VALUE.CLEAR": {
      actions: ["clearDateValue", "clearFocusedDate", "focusFirstInputElement"]
    },
    "INPUT.CHANGE": [
      {
        guard: "isInputValueEmpty",
        actions: ["setInputValue", "clearDateValue", "clearFocusedDate"]
      },
      {
        actions: ["setInputValue", "focusParsedDate"]
      }
    ],
    "INPUT.ENTER": {
      actions: ["focusParsedDate", "selectFocusedDate"]
    },
    "INPUT.FOCUS": {
      actions: ["setActiveIndex"]
    },
    "INPUT.BLUR": [
      {
        guard: "shouldFixOnBlur",
        actions: ["setActiveIndexToStart", "selectParsedDate"]
      },
      {
        actions: ["setActiveIndexToStart"]
      }
    ],
    "PRESET.CLICK": [
      {
        guard: "isOpenControlled",
        actions: ["setDateValue", "setFocusedDate", "invokeOnClose"]
      },
      {
        target: "focused",
        actions: ["setDateValue", "setFocusedDate", "focusInputElement"]
      }
    ],
    "GOTO.NEXT": [
      {
        guard: "isYearView",
        actions: ["focusNextDecade", "announceVisibleRange"]
      },
      {
        guard: "isMonthView",
        actions: ["focusNextYear", "announceVisibleRange"]
      },
      {
        actions: ["focusNextPage"]
      }
    ],
    "GOTO.PREV": [
      {
        guard: "isYearView",
        actions: ["focusPreviousDecade", "announceVisibleRange"]
      },
      {
        guard: "isMonthView",
        actions: ["focusPreviousYear", "announceVisibleRange"]
      },
      {
        actions: ["focusPreviousPage"]
      }
    ]
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["focusFirstSelectedDate", "focusActiveCell"]
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
          }
        ]
      }
    },
    focused: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["focusFirstSelectedDate", "focusActiveCell"]
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackDismissableElement", "trackPositioning"],
      exit: ["clearHoveredDate", "resetView"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: and3("shouldRestoreFocus", "isInteractOutsideEvent"),
            target: "focused",
            actions: ["focusTriggerElement"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["focusInputElement"]
          },
          {
            target: "idle"
          }
        ],
        "CELL.CLICK": [
          {
            guard: "isAboveMinView",
            actions: ["setFocusedValueForView", "setPreviousView"]
          },
          {
            guard: and3("isRangePicker", "hasSelectedRange"),
            actions: ["setActiveIndexToStart", "resetSelection", "setActiveIndexToEnd"]
          },
          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
          {
            guard: and3("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
            actions: [
              "setFocusedDate",
              "setSelectedDate",
              "setActiveIndexToStart",
              "clearHoveredDate",
              "invokeOnClose",
              "setRestoreFocus"
            ]
          },
          {
            guard: and3("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
            target: "focused",
            actions: [
              "setFocusedDate",
              "setSelectedDate",
              "setActiveIndexToStart",
              "clearHoveredDate",
              "invokeOnClose",
              "focusInputElement"
            ]
          },
          {
            guard: and3("isRangePicker", "isSelectingEndDate"),
            actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToStart", "clearHoveredDate"]
          },
          // ===
          {
            guard: "isRangePicker",
            actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToEnd"]
          },
          {
            guard: "isMultiPicker",
            actions: ["setFocusedDate", "toggleSelectedDate"]
          },
          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
          {
            guard: and3("closeOnSelect", "isOpenControlled"),
            actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose", "focusInputElement"]
          },
          {
            actions: ["setFocusedDate", "setSelectedDate"]
          }
          // ===
        ],
        "CELL.POINTER_MOVE": {
          guard: and3("isRangePicker", "isSelectingEndDate"),
          actions: ["setHoveredDate", "setFocusedDate"]
        },
        "TABLE.POINTER_LEAVE": {
          guard: "isRangePicker",
          actions: ["clearHoveredDate"]
        },
        "TABLE.POINTER_DOWN": {
          actions: ["disableTextSelection"]
        },
        "TABLE.POINTER_UP": {
          actions: ["enableTextSelection"]
        },
        "TABLE.ESCAPE": [
          {
            guard: "isOpenControlled",
            actions: ["focusFirstSelectedDate", "invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["focusFirstSelectedDate", "invokeOnClose", "focusTriggerElement"]
          }
        ],
        "TABLE.ENTER": [
          {
            guard: "isAboveMinView",
            actions: ["setPreviousView"]
          },
          {
            guard: and3("isRangePicker", "hasSelectedRange"),
            actions: ["setActiveIndexToStart", "clearDateValue", "setSelectedDate", "setActiveIndexToEnd"]
          },
          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
          {
            guard: and3("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
            actions: ["setSelectedDate", "setActiveIndexToStart", "clearHoveredDate", "invokeOnClose"]
          },
          {
            guard: and3("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
            target: "focused",
            actions: [
              "setSelectedDate",
              "setActiveIndexToStart",
              "clearHoveredDate",
              "invokeOnClose",
              "focusInputElement"
            ]
          },
          {
            guard: and3("isRangePicker", "isSelectingEndDate"),
            actions: ["setSelectedDate", "setActiveIndexToStart", "clearHoveredDate"]
          },
          // ===
          {
            guard: "isRangePicker",
            actions: ["setSelectedDate", "setActiveIndexToEnd", "focusNextDay"]
          },
          {
            guard: "isMultiPicker",
            actions: ["toggleSelectedDate"]
          },
          // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
          {
            guard: and3("closeOnSelect", "isOpenControlled"),
            actions: ["selectFocusedDate", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectFocusedDate", "invokeOnClose", "focusInputElement"]
          },
          {
            actions: ["selectFocusedDate"]
          }
          // ===
        ],
        "TABLE.ARROW_RIGHT": [
          {
            guard: "isMonthView",
            actions: ["focusNextMonth"]
          },
          {
            guard: "isYearView",
            actions: ["focusNextYear"]
          },
          {
            actions: ["focusNextDay", "setHoveredDate"]
          }
        ],
        "TABLE.ARROW_LEFT": [
          {
            guard: "isMonthView",
            actions: ["focusPreviousMonth"]
          },
          {
            guard: "isYearView",
            actions: ["focusPreviousYear"]
          },
          {
            actions: ["focusPreviousDay"]
          }
        ],
        "TABLE.ARROW_UP": [
          {
            guard: "isMonthView",
            actions: ["focusPreviousMonthColumn"]
          },
          {
            guard: "isYearView",
            actions: ["focusPreviousYearColumn"]
          },
          {
            actions: ["focusPreviousWeek"]
          }
        ],
        "TABLE.ARROW_DOWN": [
          {
            guard: "isMonthView",
            actions: ["focusNextMonthColumn"]
          },
          {
            guard: "isYearView",
            actions: ["focusNextYearColumn"]
          },
          {
            actions: ["focusNextWeek"]
          }
        ],
        "TABLE.PAGE_UP": {
          actions: ["focusPreviousSection"]
        },
        "TABLE.PAGE_DOWN": {
          actions: ["focusNextSection"]
        },
        "TABLE.HOME": [
          {
            guard: "isMonthView",
            actions: ["focusFirstMonth"]
          },
          {
            guard: "isYearView",
            actions: ["focusFirstYear"]
          },
          {
            actions: ["focusSectionStart"]
          }
        ],
        "TABLE.END": [
          {
            guard: "isMonthView",
            actions: ["focusLastMonth"]
          },
          {
            guard: "isYearView",
            actions: ["focusLastYear"]
          },
          {
            actions: ["focusSectionEnd"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose"]
          }
        ],
        "VIEW.TOGGLE": {
          actions: ["setNextView"]
        },
        INTERACT_OUTSIDE: [
          {
            guard: "isOpenControlled",
            actions: ["setActiveIndexToStart", "invokeOnClose"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["setActiveIndexToStart", "invokeOnClose", "focusTriggerElement"]
          },
          {
            target: "idle",
            actions: ["setActiveIndexToStart", "invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["setActiveIndexToStart", "invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["setActiveIndexToStart", "invokeOnClose"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isAboveMinView: ({ context, prop }) => isAboveMinView(context.get("view"), prop("minView")),
      isDayView: ({ context, event }) => (event.view || context.get("view")) === "day",
      isMonthView: ({ context, event }) => (event.view || context.get("view")) === "month",
      isYearView: ({ context, event }) => (event.view || context.get("view")) === "year",
      isRangePicker: ({ prop }) => prop("selectionMode") === "range",
      hasSelectedRange: ({ context }) => context.get("value").length === 2,
      isMultiPicker: ({ prop }) => prop("selectionMode") === "multiple",
      shouldRestoreFocus: ({ context }) => !!context.get("restoreFocus"),
      isSelectingEndDate: ({ context }) => context.get("activeIndex") === 1,
      closeOnSelect: ({ prop }) => !!prop("closeOnSelect"),
      isOpenControlled: ({ prop }) => prop("open") != void 0 || !!prop("inline"),
      isInteractOutsideEvent: ({ event }) => event.previousEvent?.type === "INTERACT_OUTSIDE",
      isInputValueEmpty: ({ event }) => event.value.trim() === "",
      shouldFixOnBlur: ({ event }) => !!event.fixOnBlur
    },
    effects: {
      trackPositioning({ context, prop, scope }) {
        if (prop("inline")) return;
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", prop("positioning").placement);
        }
        const anchorEl = getControlEl2(scope);
        const getPositionerEl22 = () => getPositionerEl2(scope);
        return getPlacement(anchorEl, getPositionerEl22, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      setupLiveRegion({ scope, refs }) {
        const doc = scope.getDoc();
        refs.set("announcer", createLiveRegion({ level: "assertive", document: doc }));
        return () => refs.get("announcer")?.destroy?.();
      },
      trackDismissableElement({ scope, send, context, prop }) {
        if (prop("inline")) return;
        const getContentEl22 = () => getContentEl3(scope);
        return trackDismissableElement(getContentEl22, {
          type: "popover",
          defer: true,
          exclude: [...getInputEls(scope), getTriggerEl2(scope), getClearTriggerEl2(scope)],
          onInteractOutside(event) {
            context.set("restoreFocus", !event.detail.focusable);
          },
          onDismiss() {
            send({ type: "INTERACT_OUTSIDE" });
          },
          onEscapeKeyDown(event) {
            event.preventDefault();
            send({ type: "TABLE.ESCAPE", src: "dismissable" });
          }
        });
      }
    },
    actions: {
      setNextView({ context, prop }) {
        const nextView = getNextView(context.get("view"), prop("minView"), prop("maxView"));
        context.set("view", nextView);
      },
      setPreviousView({ context, prop }) {
        const prevView = getPreviousView(context.get("view"), prop("minView"), prop("maxView"));
        context.set("view", prevView);
      },
      setView({ context, event }) {
        context.set("view", event.view);
      },
      setRestoreFocus({ context }) {
        context.set("restoreFocus", true);
      },
      announceValueText({ context, prop, refs }) {
        const value = context.get("value");
        const locale = prop("locale");
        const timeZone = prop("timeZone");
        let announceText;
        if (prop("selectionMode") === "range") {
          const [startDate, endDate] = value;
          if (startDate && endDate) {
            announceText = formatSelectedDate(startDate, endDate, locale, timeZone);
          } else if (startDate) {
            announceText = formatSelectedDate(startDate, null, locale, timeZone);
          } else if (endDate) {
            announceText = formatSelectedDate(endDate, null, locale, timeZone);
          } else {
            announceText = "";
          }
        } else {
          announceText = value.map((date) => formatSelectedDate(date, null, locale, timeZone)).filter(Boolean).join(",");
        }
        refs.get("announcer")?.announce(announceText, 3e3);
      },
      announceVisibleRange({ computed, refs }) {
        const { formatted } = computed("visibleRangeText");
        refs.get("announcer")?.announce(formatted);
      },
      disableTextSelection({ scope }) {
        disableTextSelection({ target: getContentEl3(scope), doc: scope.getDoc() });
      },
      enableTextSelection({ scope }) {
        restoreTextSelection({ doc: scope.getDoc(), target: getContentEl3(scope) });
      },
      focusFirstSelectedDate(params) {
        const { context } = params;
        if (!context.get("value").length) return;
        setFocusedValue(params, context.get("value")[0]);
      },
      syncInputElement({ scope, computed }) {
        raf(() => {
          const inputEls = getInputEls(scope);
          inputEls.forEach((inputEl, index) => {
            setElementValue(inputEl, computed("valueAsString")[index] || "");
          });
        });
      },
      setFocusedDate(params) {
        const { event } = params;
        const value = Array.isArray(event.value) ? event.value[0] : event.value;
        setFocusedValue(params, value);
      },
      setFocusedValueForView(params) {
        const { context, event } = params;
        setFocusedValue(params, context.get("focusedValue").set({ [context.get("view")]: event.value }));
      },
      focusNextMonth(params) {
        const { context } = params;
        setFocusedValue(params, context.get("focusedValue").add({ months: 1 }));
      },
      focusPreviousMonth(params) {
        const { context } = params;
        setFocusedValue(params, context.get("focusedValue").subtract({ months: 1 }));
      },
      setDateValue({ context, event, prop }) {
        if (!Array.isArray(event.value)) return;
        const value = event.value.map((date) => constrainValue(date, prop("min"), prop("max")));
        context.set("value", value);
      },
      clearDateValue({ context }) {
        context.set("value", []);
      },
      setSelectedDate(params) {
        const { context, event } = params;
        const values = Array.from(context.get("value"));
        values[context.get("activeIndex")] = normalizeValue(params, event.value ?? context.get("focusedValue"));
        context.set("value", adjustStartAndEndDate(values));
      },
      resetSelection(params) {
        const { context, event } = params;
        const value = normalizeValue(params, event.value ?? context.get("focusedValue"));
        context.set("value", [value]);
      },
      toggleSelectedDate(params) {
        const { context, event } = params;
        const currentValue = normalizeValue(params, event.value ?? context.get("focusedValue"));
        const index = context.get("value").findIndex((date) => isDateEqual(date, currentValue));
        if (index === -1) {
          const values = [...context.get("value"), currentValue];
          context.set("value", sortDates(values));
        } else {
          const values = Array.from(context.get("value"));
          values.splice(index, 1);
          context.set("value", sortDates(values));
        }
      },
      setHoveredDate({ context, event }) {
        context.set("hoveredValue", event.value);
      },
      clearHoveredDate({ context }) {
        context.set("hoveredValue", null);
      },
      selectFocusedDate({ context, computed }) {
        const values = Array.from(context.get("value"));
        const activeIndex = context.get("activeIndex");
        values[activeIndex] = context.get("focusedValue").copy();
        context.set("value", adjustStartAndEndDate(values));
        const valueAsString = computed("valueAsString");
        context.set("inputValue", valueAsString[activeIndex]);
      },
      focusPreviousDay(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").subtract({ days: 1 });
        setFocusedValue(params, nextValue);
      },
      focusNextDay(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").add({ days: 1 });
        setFocusedValue(params, nextValue);
      },
      focusPreviousWeek(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").subtract({ weeks: 1 });
        setFocusedValue(params, nextValue);
      },
      focusNextWeek(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").add({ weeks: 1 });
        setFocusedValue(params, nextValue);
      },
      focusNextPage(params) {
        const { context, computed, prop } = params;
        const nextPage = getNextPage(
          context.get("focusedValue"),
          context.get("startValue"),
          computed("visibleDuration"),
          prop("locale"),
          prop("min"),
          prop("max")
        );
        setAdjustedValue(params, nextPage);
      },
      focusPreviousPage(params) {
        const { context, computed, prop } = params;
        const previousPage = getPreviousPage(
          context.get("focusedValue"),
          context.get("startValue"),
          computed("visibleDuration"),
          prop("locale"),
          prop("min"),
          prop("max")
        );
        setAdjustedValue(params, previousPage);
      },
      focusSectionStart(params) {
        const { context } = params;
        setFocusedValue(params, context.get("startValue").copy());
      },
      focusSectionEnd(params) {
        const { computed } = params;
        setFocusedValue(params, computed("endValue").copy());
      },
      focusNextSection(params) {
        const { context, event, computed, prop } = params;
        const nextSection = getNextSection(
          context.get("focusedValue"),
          context.get("startValue"),
          event.larger,
          computed("visibleDuration"),
          prop("locale"),
          prop("min"),
          prop("max")
        );
        if (!nextSection) return;
        setAdjustedValue(params, nextSection);
      },
      focusPreviousSection(params) {
        const { context, event, computed, prop } = params;
        const previousSection = getPreviousSection(
          context.get("focusedValue"),
          context.get("startValue"),
          event.larger,
          computed("visibleDuration"),
          prop("locale"),
          prop("min"),
          prop("max")
        );
        if (!previousSection) return;
        setAdjustedValue(params, previousSection);
      },
      focusNextYear(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").add({ years: 1 });
        setFocusedValue(params, nextValue);
      },
      focusPreviousYear(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").subtract({ years: 1 });
        setFocusedValue(params, nextValue);
      },
      focusNextDecade(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").add({ years: 10 });
        setFocusedValue(params, nextValue);
      },
      focusPreviousDecade(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").subtract({ years: 10 });
        setFocusedValue(params, nextValue);
      },
      clearFocusedDate(params) {
        const { prop } = params;
        setFocusedValue(params, getTodayDate(prop("timeZone")));
      },
      focusPreviousMonthColumn(params) {
        const { context, event } = params;
        const nextValue = context.get("focusedValue").subtract({ months: event.columns });
        setFocusedValue(params, nextValue);
      },
      focusNextMonthColumn(params) {
        const { context, event } = params;
        const nextValue = context.get("focusedValue").add({ months: event.columns });
        setFocusedValue(params, nextValue);
      },
      focusPreviousYearColumn(params) {
        const { context, event } = params;
        const nextValue = context.get("focusedValue").subtract({ years: event.columns });
        setFocusedValue(params, nextValue);
      },
      focusNextYearColumn(params) {
        const { context, event } = params;
        const nextValue = context.get("focusedValue").add({ years: event.columns });
        setFocusedValue(params, nextValue);
      },
      focusFirstMonth(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").set({ month: 1 });
        setFocusedValue(params, nextValue);
      },
      focusLastMonth(params) {
        const { context } = params;
        const nextValue = context.get("focusedValue").set({ month: 12 });
        setFocusedValue(params, nextValue);
      },
      focusFirstYear(params) {
        const { context } = params;
        const range2 = getDecadeRange(context.get("focusedValue").year);
        const nextValue = context.get("focusedValue").set({ year: range2[0] });
        setFocusedValue(params, nextValue);
      },
      focusLastYear(params) {
        const { context } = params;
        const range2 = getDecadeRange(context.get("focusedValue").year);
        const nextValue = context.get("focusedValue").set({ year: range2[range2.length - 1] });
        setFocusedValue(params, nextValue);
      },
      setActiveIndex({ context, event }) {
        context.set("activeIndex", event.index);
      },
      setActiveIndexToEnd({ context }) {
        context.set("activeIndex", 1);
      },
      setActiveIndexToStart({ context }) {
        context.set("activeIndex", 0);
      },
      focusActiveCell({ scope, context }) {
        raf(() => {
          const view = context.get("view");
          getFocusedCell(scope, view)?.focus({ preventScroll: true });
        });
      },
      focusActiveCellIfNeeded({ scope, context, event }) {
        if (!event.focus) return;
        raf(() => {
          const view = context.get("view");
          getFocusedCell(scope, view)?.focus({ preventScroll: true });
        });
      },
      setHoveredValueIfKeyboard({ context, event, prop }) {
        if (!event.type.startsWith("TABLE.ARROW") || prop("selectionMode") !== "range" || context.get("activeIndex") === 0)
          return;
        context.set("hoveredValue", context.get("focusedValue").copy());
      },
      focusTriggerElement({ scope }) {
        raf(() => {
          getTriggerEl2(scope)?.focus({ preventScroll: true });
        });
      },
      focusFirstInputElement({ scope }) {
        raf(() => {
          const [inputEl] = getInputEls(scope);
          inputEl?.focus({ preventScroll: true });
        });
      },
      focusInputElement({ scope }) {
        raf(() => {
          const inputEls = getInputEls(scope);
          const lastIndexWithValue = inputEls.findLastIndex((inputEl2) => inputEl2.value !== "");
          const indexToFocus = Math.max(lastIndexWithValue, 0);
          const inputEl = inputEls[indexToFocus];
          inputEl?.focus({ preventScroll: true });
          inputEl?.setSelectionRange(inputEl.value.length, inputEl.value.length);
        });
      },
      syncMonthSelectElement({ scope, context }) {
        const monthSelectEl = getMonthSelectEl(scope);
        setElementValue(monthSelectEl, context.get("startValue").month.toString());
      },
      syncYearSelectElement({ scope, context }) {
        const yearSelectEl = getYearSelectEl(scope);
        setElementValue(yearSelectEl, context.get("startValue").year.toString());
      },
      setInputValue({ context, event }) {
        if (context.get("activeIndex") !== event.index) return;
        context.set("inputValue", event.value);
      },
      syncInputValue({ scope, context, event }) {
        queueMicrotask(() => {
          const inputEls = getInputEls(scope);
          const idx = event.index ?? context.get("activeIndex");
          setElementValue(inputEls[idx], context.get("inputValue"));
        });
      },
      focusParsedDate(params) {
        const { event, prop } = params;
        if (event.index == null) return;
        const parse2 = prop("parse");
        const date = parse2(event.value, { locale: prop("locale"), timeZone: prop("timeZone") });
        if (!date || !isValidDate(date)) return;
        setFocusedValue(params, date);
      },
      selectParsedDate({ context, event, prop }) {
        if (event.index == null) return;
        const parse2 = prop("parse");
        let date = parse2(event.value, { locale: prop("locale"), timeZone: prop("timeZone") });
        if (!date || !isValidDate(date)) {
          if (event.value) {
            date = context.get("focusedValue").copy();
          }
        }
        if (!date) return;
        date = constrainValue(date, prop("min"), prop("max"));
        const values = Array.from(context.get("value"));
        values[event.index] = date;
        context.set("value", values);
        const valueAsString = getValueAsString(values, prop);
        context.set("inputValue", valueAsString[event.index]);
      },
      resetView({ context }) {
        context.set("view", context.initial("view"));
      },
      setStartValue({ context, computed, prop }) {
        const focusedValue = context.get("focusedValue");
        const outside = isDateOutsideRange(focusedValue, context.get("startValue"), computed("endValue"));
        if (!outside) return;
        const startValue = alignDate(focusedValue, "start", { months: prop("numOfMonths") }, prop("locale"));
        context.set("startValue", startValue);
      },
      invokeOnOpen({ prop, context }) {
        if (prop("inline")) return;
        prop("onOpenChange")?.({ open: true, value: context.get("value") });
      },
      invokeOnClose({ prop, context }) {
        if (prop("inline")) return;
        prop("onOpenChange")?.({ open: false, value: context.get("value") });
      },
      invokeOnVisibleRangeChange({ prop, context, computed }) {
        prop("onVisibleRangeChange")?.({
          view: context.get("view"),
          visibleRange: computed("visibleRange")
        });
      },
      toggleVisibility({ event, send, prop }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
var normalizeValue = (ctx, value) => {
  const { context, prop } = ctx;
  const view = context.get("view");
  let dateValue = typeof value === "number" ? context.get("focusedValue").set({ [view]: value }) : value;
  eachView((view2) => {
    if (isBelowMinView(view2, prop("minView"))) {
      dateValue = dateValue.set({ [view2]: view2 === "day" ? 1 : 0 });
    }
  });
  return dateValue;
};
function setFocusedValue(ctx, mixedValue) {
  const { context, prop, computed } = ctx;
  if (!mixedValue) return;
  const value = normalizeValue(ctx, mixedValue);
  if (isDateEqual(context.get("focusedValue"), value)) return;
  const adjustFn = getAdjustedDateFn(computed("visibleDuration"), prop("locale"), prop("min"), prop("max"));
  const adjustedValue = adjustFn({
    focusedDate: value,
    startDate: context.get("startValue")
  });
  context.set("startValue", adjustedValue.startDate);
  context.set("focusedValue", adjustedValue.focusedDate);
}
function setAdjustedValue(ctx, value) {
  const { context } = ctx;
  context.set("startValue", value.startDate);
  const focusedValue = context.get("focusedValue");
  if (isDateEqual(focusedValue, value.focusedDate)) return;
  context.set("focusedValue", value.focusedDate);
}
function parse(value) {
  if (Array.isArray(value)) {
    return value.map((v) => parse(v));
  }
  if (value instanceof Date) {
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(value.getFullYear(), value.getMonth() + 1, value.getDate());
  }
  return $fae977aafc393c5c$export$6b862160d295c8e(value);
}
var props6 = createProps()([
  "closeOnSelect",
  "dir",
  "disabled",
  "fixedWeeks",
  "focusedValue",
  "format",
  "parse",
  "placeholder",
  "getRootNode",
  "id",
  "ids",
  "inline",
  "invalid",
  "isDateUnavailable",
  "locale",
  "max",
  "min",
  "name",
  "numOfMonths",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "onViewChange",
  "onVisibleRangeChange",
  "open",
  "defaultOpen",
  "positioning",
  "readOnly",
  "required",
  "selectionMode",
  "startOfWeek",
  "timeZone",
  "translations",
  "value",
  "defaultView",
  "defaultValue",
  "view",
  "defaultFocusedValue",
  "outsideDaySelectable",
  "minView",
  "maxView"
]);
var splitProps7 = createSplitProps(props6);
var inputProps = createProps()(["index", "fixOnBlur"]);
var splitInputProps = createSplitProps(inputProps);
var presetTriggerProps = createProps()(["value"]);
var splitPresetTriggerProps = createSplitProps(presetTriggerProps);
var tableProps = createProps()(["columns", "id", "view"]);
var splitTableProps = createSplitProps(tableProps);
var tableCellProps = createProps()(["disabled", "value", "columns"]);
var splitTableCellProps = createSplitProps(tableCellProps);
var viewProps = createProps()(["view"]);
var splitViewProps = createSplitProps(viewProps);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/input.svelte
Input2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/input.svelte";
var root_246 = add_locations(from_html(`<input/>`), Input2[FILENAME], [[27, 1]]);
function Input2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Input2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const $$d = user_derived(() => splitInputProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), inputProps2 = tag(user_derived(() => get($$array)[0]), "inputProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getInputProps(get(inputProps2)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Input2, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_246();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Input2,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Input2 = hmr(Input2);
  import.meta.hot.accept((module) => {
    Input2[HMR].update(module.default);
  });
}
var input_default2 = Input2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/label.svelte
Label2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/label.svelte";
var root_247 = add_locations(from_html(`<label><!></label>`), Label2[FILENAME], [[24, 1]]);
function Label2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_247();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label2, 25, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label2 = hmr(Label2);
  import.meta.hot.accept((module) => {
    Label2[HMR].update(module.default);
  });
}
var label_default2 = Label2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/month-select.svelte
Month_select[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/month-select.svelte";
var root_33 = add_locations(from_html(`<option> </option>`), Month_select[FILENAME], [[26, 3]]);
var root_248 = add_locations(from_html(`<select></select>`), Month_select[FILENAME], [[24, 1]]);
function Month_select($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Month_select);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getMonthSelectProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Month_select, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var select = root_248();
      attribute_effect(select, () => ({ ...get(attributes) }));
      validate_each_keys(() => datePicker().getMonths(), (month) => month.value);
      add_svelte_meta(
        () => each(select, 21, () => datePicker().getMonths(), (month) => month.value, ($$anchor3, month) => {
          var option = root_33();
          var text2 = child(option, true);
          reset(option);
          var option_value = {};
          template_effect(() => {
            set_text(text2, get(month).label);
            if (option_value !== (option_value = get(month).value)) {
              option.value = (option.__value = get(month).value) ?? "";
            }
          });
          append($$anchor3, option);
        }),
        "each",
        Month_select,
        25,
        2
      );
      reset(select);
      append($$anchor2, select);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Month_select,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Month_select = hmr(Month_select);
  import.meta.hot.accept((module) => {
    Month_select[HMR].update(module.default);
  });
}
var month_select_default = Month_select;

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/chevron-right.svelte
Chevron_right[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/chevron-right.svelte";
var root3 = add_locations(from_svg(`<svg><path d="m9 18 6-6-6-6"></path></svg>`), Chevron_right[FILENAME], [[32, 0, [[33, 1]]]]);
function Chevron_right($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Chevron_right);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const rest = tag(user_derived(() => exclude_from_object(props25, [])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var svg = root3();
  attribute_effect(svg, () => ({ ...get(attributes) }));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Chevron_right = hmr(Chevron_right);
  import.meta.hot.accept((module) => {
    Chevron_right[HMR].update(module.default);
  });
}
var chevron_right_default = Chevron_right;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/modules/view-context.js
var ViewContext = createContext(() => ({ view: "day" }));

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/next-trigger.svelte
Next_trigger2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/next-trigger.svelte";
var chevronRight = wrap_snippet(Next_trigger2, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => chevron_right_default(node, {}), "component", Next_trigger2, 25, 1, { componentTag: "ChevronRightIcon" });
  append($$anchor, fragment);
});
var root_34 = add_locations(from_html(`<button><!></button>`), Next_trigger2[FILENAME], [[31, 1]]);
function Next_trigger2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Next_trigger2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, chevronRight)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getNextTriggerProps(viewProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node_1 = first_child(fragment_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_2, () => get(element2), () => get(attributes)), "render", Next_trigger2, 29, 1);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var button = root_34();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_3 = child(button);
      add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Next_trigger2, 32, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Next_trigger2,
      28,
      0
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  Next_trigger2 = hmr(Next_trigger2);
  import.meta.hot.accept((module) => {
    Next_trigger2[HMR].update(module.default);
  });
}
var next_trigger_default2 = Next_trigger2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/positioner.svelte
Positioner2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/positioner.svelte";
var root_249 = add_locations(from_html(`<div><!></div>`), Positioner2[FILENAME], [[24, 1]]);
function Positioner2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Positioner2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getPositionerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Positioner2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_249();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Positioner2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Positioner2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Positioner2 = hmr(Positioner2);
  import.meta.hot.accept((module) => {
    Positioner2[HMR].update(module.default);
  });
}
var positioner_default2 = Positioner2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/preset-trigger.svelte
Preset_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/preset-trigger.svelte";
var root_250 = add_locations(from_html(`<button><!></button>`), Preset_trigger[FILENAME], [[27, 1]]);
function Preset_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Preset_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const $$d = user_derived(() => splitPresetTriggerProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), presetTriggerProps2 = tag(user_derived(() => get($$array)[0]), "presetTriggerProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getPresetTriggerProps(get(presetTriggerProps2)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Preset_trigger, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_250();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Preset_trigger, 28, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Preset_trigger,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Preset_trigger = hmr(Preset_trigger);
  import.meta.hot.accept((module) => {
    Preset_trigger[HMR].update(module.default);
  });
}
var preset_trigger_default = Preset_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/chevron-left.svelte
Chevron_left[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/chevron-left.svelte";
var root4 = add_locations(from_svg(`<svg><path d="m15 18-6-6 6-6"></path></svg>`), Chevron_left[FILENAME], [[32, 0, [[33, 1]]]]);
function Chevron_left($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Chevron_left);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const rest = tag(user_derived(() => exclude_from_object(props25, [])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var svg = root4();
  attribute_effect(svg, () => ({ ...get(attributes) }));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Chevron_left = hmr(Chevron_left);
  import.meta.hot.accept((module) => {
    Chevron_left[HMR].update(module.default);
  });
}
var chevron_left_default = Chevron_left;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/prev-trigger.svelte
Prev_trigger2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/prev-trigger.svelte";
var chevronLeft = wrap_snippet(Prev_trigger2, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => chevron_left_default(node, {}), "component", Prev_trigger2, 25, 1, { componentTag: "ChevronLeftIcon" });
  append($$anchor, fragment);
});
var root_35 = add_locations(from_html(`<button><!></button>`), Prev_trigger2[FILENAME], [[31, 1]]);
function Prev_trigger2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Prev_trigger2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, chevronLeft)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getPrevTriggerProps(viewProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node_1 = first_child(fragment_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_2, () => get(element2), () => get(attributes)), "render", Prev_trigger2, 29, 1);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var button = root_35();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_3 = child(button);
      add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Prev_trigger2, 32, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Prev_trigger2,
      28,
      0
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  Prev_trigger2 = hmr(Prev_trigger2);
  import.meta.hot.accept((module) => {
    Prev_trigger2[HMR].update(module.default);
  });
}
var prev_trigger_default2 = Prev_trigger2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/range-text.svelte
Range_text[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/range-text.svelte";
var root_36 = add_locations(from_html(`<div><!></div>`), Range_text[FILENAME], [[30, 1]]);
function Range_text($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Range_text);
  const defaultChildren = wrap_snippet(Range_text, function($$anchor2) {
    validate_snippet_args(...arguments);
    next();
    var text2 = text();
    template_effect(() => set_text(text2, get(rangeText)));
    append($$anchor2, text2);
  });
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const rangeText = tag(
    user_derived(() => Array.from(/* @__PURE__ */ new Set([
      datePicker().visibleRangeText.start,
      datePicker().visibleRangeText.end
    ])).join(" - ")),
    "rangeText"
  );
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, defaultChildren)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getRangeTextProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node = first_child(fragment_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_1 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Range_text, 28, 1);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var div = root_36();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Range_text, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Range_text,
      27,
      0
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  Range_text = hmr(Range_text);
  import.meta.hot.accept((module) => {
    Range_text[HMR].update(module.default);
  });
}
var range_text_default = Range_text;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/root-context.svelte
Root_context6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/root-context.svelte";
function Root_context6($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => datePicker), "render", Root_context6, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context6 = hmr(Root_context6);
  import.meta.hot.accept((module) => {
    Root_context6[HMR].update(module.default);
  });
}
var root_context_default6 = Root_context6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/root-provider.svelte
Root_provider6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/root-provider.svelte";
var root_251 = add_locations(from_html(`<div><!></div>`), Root_provider6[FILENAME], [[27, 1]]);
function Root_provider6($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), datePicker = tag(user_derived(() => $$props.value), "datePicker"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(datePicker)().getRootProps(), get(rest))), "attributes");
  RootContext6.provide(() => get(datePicker)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider6, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_251();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider6, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider6,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider6 = hmr(Root_provider6);
  import.meta.hot.accept((module) => {
    Root_provider6[HMR].update(module.default);
  });
}
var root_provider_default6 = Root_provider6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/modules/provider.svelte.js
function useDatePicker(props25) {
  const service = useMachine(machine6, props25);
  const datePicker = tag(user_derived(() => connect6(service, normalizeProps)), "datePicker");
  return () => get(datePicker);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/root.svelte
Root7[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/root.svelte";
var root_252 = add_locations(from_html(`<div><!></div>`), Root7[FILENAME], [[35, 1]]);
function Root7($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root7);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps7(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), datePickerProps = tag(user_derived(() => get($$array)[0]), "datePickerProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const datePicker = useDatePicker(() => ({ ...get(datePickerProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getRootProps(), get(rest))), "attributes");
  RootContext6.provide(() => datePicker());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root7, 33, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_252();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root7, 36, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root7,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root7 = hmr(Root7);
  import.meta.hot.accept((module) => {
    Root7[HMR].update(module.default);
  });
}
var root_default7 = Root7;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-body.svelte
Table_body[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-body.svelte";
var root_253 = add_locations(from_html(`<tbody><!></tbody>`), Table_body[FILENAME], [[26, 1]]);
function Table_body($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Table_body);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getTableBodyProps(viewProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Table_body, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var tbody = root_253();
      attribute_effect(tbody, () => ({ ...get(attributes) }));
      var node_2 = child(tbody);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Table_body, 27, 2);
      reset(tbody);
      append($$anchor2, tbody);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Table_body,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Table_body = hmr(Table_body);
  import.meta.hot.accept((module) => {
    Table_body[HMR].update(module.default);
  });
}
var table_body_default = Table_body;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/modules/table-cell-context.js
var TableCellContext = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-cell-trigger.svelte
Table_cell_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-cell-trigger.svelte";
var root_254 = add_locations(from_html(`<div><!></div>`), Table_cell_trigger[FILENAME], [[37, 1]]);
function Table_cell_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Table_cell_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const tableCellProps2 = TableCellContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const refinedTableCellProps = tag(
    user_derived(() => {
      return {
        day: datePicker().getDayTableCellTriggerProps,
        month: datePicker().getMonthTableCellTriggerProps,
        year: datePicker().getYearTableCellTriggerProps
        // @ts-expect-error number === DateValue
      }[viewProps2().view](tableCellProps2());
    }),
    "refinedTableCellProps"
  );
  const attributes = tag(user_derived(() => mergeProps2(get(refinedTableCellProps), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Table_cell_trigger, 35, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_254();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Table_cell_trigger, 38, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Table_cell_trigger,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Table_cell_trigger = hmr(Table_cell_trigger);
  import.meta.hot.accept((module) => {
    Table_cell_trigger[HMR].update(module.default);
  });
}
var table_cell_trigger_default = Table_cell_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-cell.svelte
Table_cell[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-cell.svelte";
var root_255 = add_locations(from_html(`<td><!></td>`), Table_cell[FILENAME], [[48, 1]]);
function Table_cell($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Table_cell);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const $$d = user_derived(() => splitTableCellProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), tableCellProps2 = tag(user_derived(() => get($$array)[0]), "tableCellProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const refinedTableCellProps = tag(
    user_derived(() => {
      return {
        day: datePicker().getDayTableCellProps,
        month: datePicker().getMonthTableCellProps,
        year: datePicker().getYearTableCellProps
        // @ts-expect-error number === DateValue
      }[viewProps2().view](get(tableCellProps2));
    }),
    "refinedTableCellProps"
  );
  const attributes = tag(user_derived(() => mergeProps2(get(refinedTableCellProps), get(rest))), "attributes");
  TableCellContext.provide(() => get(tableCellProps2));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Table_cell, 46, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var td = root_255();
      attribute_effect(td, () => ({ ...get(attributes) }));
      var node_2 = child(td);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Table_cell, 49, 2);
      reset(td);
      append($$anchor2, td);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Table_cell,
      45,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Table_cell = hmr(Table_cell);
  import.meta.hot.accept((module) => {
    Table_cell[HMR].update(module.default);
  });
}
var table_cell_default = Table_cell;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-head.svelte
Table_head[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-head.svelte";
var root_256 = add_locations(from_html(`<thead><!></thead>`), Table_head[FILENAME], [[26, 1]]);
function Table_head($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Table_head);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getTableHeadProps(viewProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Table_head, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var thead = root_256();
      attribute_effect(thead, () => ({ ...get(attributes) }));
      var node_2 = child(thead);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Table_head, 27, 2);
      reset(thead);
      append($$anchor2, thead);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Table_head,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Table_head = hmr(Table_head);
  import.meta.hot.accept((module) => {
    Table_head[HMR].update(module.default);
  });
}
var table_head_default = Table_head;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-header.svelte
Table_header[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-header.svelte";
var root_257 = add_locations(from_html(`<th><!></th>`), Table_header[FILENAME], [[26, 1]]);
function Table_header($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Table_header);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getTableHeaderProps(viewProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Table_header, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var th = root_257();
      attribute_effect(th, () => ({ ...get(attributes) }));
      var node_2 = child(th);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Table_header, 27, 2);
      reset(th);
      append($$anchor2, th);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Table_header,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Table_header = hmr(Table_header);
  import.meta.hot.accept((module) => {
    Table_header[HMR].update(module.default);
  });
}
var table_header_default = Table_header;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-row.svelte
Table_row[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table-row.svelte";
var root_258 = add_locations(from_html(`<tr><!></tr>`), Table_row[FILENAME], [[26, 1]]);
function Table_row($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Table_row);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getTableRowProps(viewProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Table_row, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var tr = root_258();
      attribute_effect(tr, () => ({ ...get(attributes) }));
      var node_2 = child(tr);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Table_row, 27, 2);
      reset(tr);
      append($$anchor2, tr);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Table_row,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Table_row = hmr(Table_row);
  import.meta.hot.accept((module) => {
    Table_row[HMR].update(module.default);
  });
}
var table_row_default = Table_row;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table.svelte
Table[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/table.svelte";
var root_259 = add_locations(from_html(`<table><!></table>`), Table[FILENAME], [[26, 1]]);
function Table($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Table);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getTableProps(viewProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Table, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var table = root_259();
      attribute_effect(table, () => ({ ...get(attributes) }));
      var node_2 = child(table);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Table, 27, 2);
      reset(table);
      append($$anchor2, table);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Table,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Table = hmr(Table);
  import.meta.hot.accept((module) => {
    Table[HMR].update(module.default);
  });
}
var table_default = Table;

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/calendar.svelte
Calendar[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/calendar.svelte";
var root5 = add_locations(from_svg(`<svg><path d="M8 2v4"></path><path d="M16 2v4"></path><rect width="18" height="18" x="3" y="4" rx="2"></rect><path d="M3 10h18"></path></svg>`), Calendar[FILENAME], [[32, 0, [[33, 1], [34, 1], [35, 1], [36, 1]]]]);
function Calendar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const rest = tag(user_derived(() => exclude_from_object(props25, [])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var svg = root5();
  attribute_effect(svg, () => ({ ...get(attributes) }));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Calendar = hmr(Calendar);
  import.meta.hot.accept((module) => {
    Calendar[HMR].update(module.default);
  });
}
var calendar_default = Calendar;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/trigger.svelte
Trigger3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/trigger.svelte";
var calendarIcon = wrap_snippet(Trigger3, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => calendar_default(node, {}), "component", Trigger3, 23, 1, { componentTag: "CalendarIcon" });
  append($$anchor, fragment);
});
var root_37 = add_locations(from_html(`<button><!></button>`), Trigger3[FILENAME], [[29, 1]]);
function Trigger3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, calendarIcon)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node_1 = first_child(fragment_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_2, () => get(element2), () => get(attributes)), "render", Trigger3, 27, 1);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var button = root_37();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_3 = child(button);
      add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Trigger3, 30, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger3,
      26,
      0
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger3 = hmr(Trigger3);
  import.meta.hot.accept((module) => {
    Trigger3[HMR].update(module.default);
  });
}
var trigger_default3 = Trigger3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/view-control.svelte
View_control[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/view-control.svelte";
var root_260 = add_locations(from_html(`<div><!></div>`), View_control[FILENAME], [[26, 1]]);
function View_control($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, View_control);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getViewControlProps(viewProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", View_control, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_260();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", View_control, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      View_control,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  View_control = hmr(View_control);
  import.meta.hot.accept((module) => {
    View_control[HMR].update(module.default);
  });
}
var view_control_default = View_control;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/view-trigger.svelte
View_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/view-trigger.svelte";
var root_261 = add_locations(from_html(`<button><!></button>`), View_trigger[FILENAME], [[26, 1]]);
function View_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, View_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const viewProps2 = ViewContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getViewTriggerProps(viewProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", View_trigger, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_261();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", View_trigger, 27, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      View_trigger,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  View_trigger = hmr(View_trigger);
  import.meta.hot.accept((module) => {
    View_trigger[HMR].update(module.default);
  });
}
var view_trigger_default = View_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/view.svelte
View[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/view.svelte";
var root_262 = add_locations(from_html(`<div><!></div>`), View[FILENAME], [[30, 1]]);
function View($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, View);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const $$d = user_derived(() => splitViewProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), viewProps2 = tag(user_derived(() => get($$array)[0]), "viewProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getViewProps(get(viewProps2)), get(rest))), "attributes");
  ViewContext.provide(() => get(viewProps2));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", View, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_262();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", View, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      View,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  View = hmr(View);
  import.meta.hot.accept((module) => {
    View[HMR].update(module.default);
  });
}
var view_default = View;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/year-select.svelte
Year_select[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/anatomy/year-select.svelte";
var root_38 = add_locations(from_html(`<option> </option>`), Year_select[FILENAME], [[26, 3]]);
var root_263 = add_locations(from_html(`<select></select>`), Year_select[FILENAME], [[24, 1]]);
function Year_select($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Year_select);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const datePicker = RootContext6.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(datePicker().getYearSelectProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Year_select, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var select = root_263();
      attribute_effect(select, () => ({ ...get(attributes) }));
      validate_each_keys(() => datePicker().getYears(), (year) => year.value);
      add_svelte_meta(
        () => each(select, 21, () => datePicker().getYears(), (year) => year.value, ($$anchor3, year) => {
          var option = root_38();
          var text2 = child(option, true);
          reset(option);
          var option_value = {};
          template_effect(() => {
            set_text(text2, get(year).label);
            if (option_value !== (option_value = get(year).value)) {
              option.value = (option.__value = get(year).value) ?? "";
            }
          });
          append($$anchor3, option);
        }),
        "each",
        Year_select,
        25,
        2
      );
      reset(select);
      append($$anchor2, select);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Year_select,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Year_select = hmr(Year_select);
  import.meta.hot.accept((module) => {
    Year_select[HMR].update(module.default);
  });
}
var year_select_default = Year_select;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/date-picker/modules/anatomy.js
var DatePicker = Object.assign(root_default7, {
  Provider: root_provider_default6,
  Context: root_context_default6,
  Label: label_default2,
  Control: control_default3,
  PresetTrigger: preset_trigger_default,
  Input: input_default2,
  Trigger: trigger_default3,
  Positioner: positioner_default2,
  Content: content_default3,
  YearSelect: year_select_default,
  MonthSelect: month_select_default,
  View: view_default,
  ViewControl: view_control_default,
  PrevTrigger: prev_trigger_default2,
  ViewTrigger: view_trigger_default,
  RangeText: range_text_default,
  NextTrigger: next_trigger_default2,
  Table: table_default,
  TableHead: table_head_default,
  TableRow: table_row_default,
  TableHeader: table_header_default,
  TableBody: table_body_default,
  TableCell: table_cell_default,
  TableCellTrigger: table_cell_trigger_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/modules/root-context.js
var RootContext7 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/backdrop.svelte
Backdrop[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/backdrop.svelte";
var root_264 = add_locations(from_html(`<div></div>`), Backdrop[FILENAME], [[24, 1]]);
function Backdrop($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Backdrop);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const dialog = RootContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(dialog().getBackdropProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Backdrop, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_264();
      attribute_effect(div, () => ({ ...get(attributes) }));
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Backdrop,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Backdrop = hmr(Backdrop);
  import.meta.hot.accept((module) => {
    Backdrop[HMR].update(module.default);
  });
}
var backdrop_default = Backdrop;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/close-trigger.svelte
Close_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/close-trigger.svelte";
var root_265 = add_locations(from_html(`<button><!></button>`), Close_trigger[FILENAME], [[24, 1]]);
function Close_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Close_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const dialog = RootContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(dialog().getCloseTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Close_trigger, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_265();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Close_trigger, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Close_trigger,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Close_trigger = hmr(Close_trigger);
  import.meta.hot.accept((module) => {
    Close_trigger[HMR].update(module.default);
  });
}
var close_trigger_default = Close_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/content.svelte
Content4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/content.svelte";
var root_266 = add_locations(from_html(`<div><!></div>`), Content4[FILENAME], [[24, 1]]);
function Content4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const dialog = RootContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(dialog().getContentProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_266();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content4, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content4 = hmr(Content4);
  import.meta.hot.accept((module) => {
    Content4[HMR].update(module.default);
  });
}
var content_default4 = Content4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/description.svelte
Description[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/description.svelte";
var root_267 = add_locations(from_html(`<div><!></div>`), Description[FILENAME], [[24, 1]]);
function Description($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Description);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const dialog = RootContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(dialog().getDescriptionProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Description, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_267();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Description, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Description,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Description = hmr(Description);
  import.meta.hot.accept((module) => {
    Description[HMR].update(module.default);
  });
}
var description_default = Description;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/positioner.svelte
Positioner3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/positioner.svelte";
var root_268 = add_locations(from_html(`<div><!></div>`), Positioner3[FILENAME], [[24, 1]]);
function Positioner3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Positioner3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const dialog = RootContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(dialog().getPositionerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Positioner3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_268();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Positioner3, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Positioner3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Positioner3 = hmr(Positioner3);
  import.meta.hot.accept((module) => {
    Positioner3[HMR].update(module.default);
  });
}
var positioner_default3 = Positioner3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/root-context.svelte
Root_context7[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/root-context.svelte";
function Root_context7($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context7);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const dialog = RootContext7.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => dialog), "render", Root_context7, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context7 = hmr(Root_context7);
  import.meta.hot.accept((module) => {
    Root_context7[HMR].update(module.default);
  });
}
var root_context_default7 = Root_context7;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/root-provider.svelte
Root_provider7[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/root-provider.svelte";
function Root_provider7($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider7);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const children = tag(user_derived(() => $$props.children), "children"), dialog = tag(user_derived(() => $$props.value), "dialog");
  RootContext7.provide(() => get(dialog)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root_provider7, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider7 = hmr(Root_provider7);
  import.meta.hot.accept((module) => {
    Root_provider7[HMR].update(module.default);
  });
}
var root_provider_default7 = Root_provider7;

// node_modules/@zag-js/aria-hidden/dist/index.mjs
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
var correctTargets = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) return target;
  const correctedTarget = unwrapHost(target);
  if (correctedTarget && parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent, ". Doing nothing");
  return null;
}).filter((x2) => Boolean(x2));
var ignoreableNodes = /* @__PURE__ */ new Set(["script", "output", "status", "next-route-announcer"]);
var isIgnoredNode = (node) => {
  if (ignoreableNodes.has(node.localName)) return true;
  if (node.role === "status") return true;
  if (node.hasAttribute("aria-live")) return true;
  return node.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props25) => {
  const { parentNode, markerName, controlAttribute, followControlledElements = true } = props25;
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el) => {
    if (!el || elementsToKeep.has(el)) return;
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach((target) => {
    keep(target);
    if (followControlledElements && isHTMLElement(target)) {
      findControlledElements(target, (controlledElement) => {
        keep(controlledElement);
      });
    }
  });
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node) => {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          if (isIgnoredNode(node)) return;
          const attr = node.getAttribute(controlAttribute);
          const alreadyHidden = attr === "true";
          const counterValue = (counterMap.get(node) || 0) + 1;
          const markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("[zag-js > ariaHidden] cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return () => {
    hiddenNodes.forEach((node) => {
      const counterValue = counterMap.get(node) - 1;
      const markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var getParentNode2 = (originalTarget) => {
  const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return target.ownerDocument.body;
};
var hideOthers = (originalTarget, parentNode = getParentNode2(originalTarget), markerName = "data-aria-hidden", followControlledElements = true) => {
  if (!parentNode) return;
  return walkTreeOutside(originalTarget, {
    parentNode,
    markerName,
    controlAttribute: "aria-hidden",
    followControlledElements
  });
};
var raf2 = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options = {}) {
  const { defer = true } = options;
  const func = defer ? raf2 : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements = targets.filter(Boolean);
      if (elements.length === 0) return;
      cleanups.push(hideOthers(elements));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}

// node_modules/@zag-js/focus-trap/dist/index.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
  activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      const activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap(trapStack, trap) {
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var sharedTrapStack = [];
var FocusTrap = class {
  constructor(elements, options) {
    __publicField4(this, "trapStack");
    __publicField4(this, "config");
    __publicField4(this, "doc");
    __publicField4(this, "state", {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    });
    __publicField4(this, "portalContainers", /* @__PURE__ */ new Set());
    __publicField4(this, "listenerCleanups", []);
    __publicField4(this, "handleFocus", (event) => {
      const target = getEventTarget(event);
      const targetContained = this.findContainerIndex(target, event) >= 0;
      if (targetContained || isDocument(target)) {
        if (targetContained) {
          this.state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        let nextNode;
        let navAcrossContainers = true;
        if (this.state.mostRecentlyFocusedNode) {
          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {
            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
            if (tabbableNodes.length > 0) {
              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);
              if (mruTabIdx >= 0) {
                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = this.findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: this.state.mostRecentlyFocusedNode,
            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
          });
        }
        if (nextNode) {
          this.tryFocus(nextNode);
        } else {
          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
        }
      }
      this.state.recentNavEvent = void 0;
    });
    __publicField4(this, "handlePointerDown", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
    });
    __publicField4(this, "handleClick", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    __publicField4(this, "handleTabKey", (event) => {
      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
        this.state.recentNavEvent = event;
        const isBackward = this.config.isKeyBackward(event);
        const destinationNode = this.findNextNavNode({ event, isBackward });
        if (!destinationNode) return;
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        this.tryFocus(destinationNode);
      }
    });
    __publicField4(this, "handleEscapeKey", (event) => {
      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        this.deactivate();
      }
    });
    __publicField4(this, "_mutationObserver");
    __publicField4(this, "setupMutationObserver", () => {
      const win = this.doc.defaultView || window;
      this._mutationObserver = new win.MutationObserver((mutations) => {
        const isFocusedNodeRemoved = mutations.some((mutation) => {
          const removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);
        });
        if (isFocusedNodeRemoved) {
          this.tryFocus(this.getInitialFocusNode());
        }
        const hasControlledChanges = mutations.some((mutation) => {
          if (mutation.type === "attributes" && (mutation.attributeName === "aria-controls" || mutation.attributeName === "aria-expanded")) {
            return true;
          }
          if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
            return Array.from(mutation.addedNodes).some((node) => {
              if (node.nodeType !== Node.ELEMENT_NODE) return false;
              const element2 = node;
              if (hasControllerElements(element2)) {
                return true;
              }
              if (element2.id && !this.state.containers.some((c) => c.contains(element2))) {
                return isControlledByExpandedController(element2);
              }
              return false;
            });
          }
          return false;
        });
        if (hasControlledChanges && this.state.active && !this.state.paused) {
          this.updateTabbableNodes();
          this.updatePortalContainers();
        }
      });
    });
    __publicField4(this, "updateObservedNodes", () => {
      this._mutationObserver?.disconnect();
      if (this.state.active && !this.state.paused) {
        this.state.containers.map((container) => {
          this._mutationObserver?.observe(container, {
            subtree: true,
            childList: true,
            attributes: true,
            attributeFilter: ["aria-controls", "aria-expanded"]
          });
        });
        this.portalContainers.forEach((portalContainer) => {
          this.observePortalContainer(portalContainer);
        });
      }
    });
    __publicField4(this, "getInitialFocusNode", () => {
      let node = this.getNodeForOption("initialFocus", { hasFallback: true });
      if (node === false) {
        return false;
      }
      if (node === void 0 || node && !isFocusable(node)) {
        const activeElement = getActiveElement(this.doc);
        if (activeElement && this.findContainerIndex(activeElement) >= 0) {
          node = activeElement;
        } else {
          const firstTabbableGroup = this.state.tabbableGroups[0];
          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || this.getNodeForOption("fallbackFocus");
        }
      } else if (node === null) {
        node = this.getNodeForOption("fallbackFocus");
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      if (!node.isConnected) {
        node = this.getNodeForOption("fallbackFocus");
      }
      return node;
    });
    __publicField4(this, "tryFocus", (node) => {
      if (node === false) return;
      if (node === getActiveElement(this.doc)) return;
      if (!node || !node.focus) {
        this.tryFocus(this.getInitialFocusNode());
        return;
      }
      node.focus({ preventScroll: !!this.config.preventScroll });
      this.state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    });
    __publicField4(this, "deactivate", (deactivateOptions) => {
      if (!this.state.active) return this;
      const options2 = {
        onDeactivate: this.config.onDeactivate,
        onPostDeactivate: this.config.onPostDeactivate,
        checkCanReturnFocus: this.config.checkCanReturnFocus,
        ...deactivateOptions
      };
      clearTimeout(this.state.delayInitialFocusTimer);
      this.state.delayInitialFocusTimer = void 0;
      this.removeListeners();
      this.state.active = false;
      this.state.paused = false;
      this.updateObservedNodes();
      activeFocusTraps.deactivateTrap(this.trapStack, this);
      this.portalContainers.clear();
      const onDeactivate = this.getOption(options2, "onDeactivate");
      const onPostDeactivate = this.getOption(options2, "onPostDeactivate");
      const checkCanReturnFocus = this.getOption(options2, "checkCanReturnFocus");
      const returnFocus = this.getOption(options2, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate?.();
      const finishDeactivation = () => {
        delay(() => {
          if (returnFocus) {
            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
            this.tryFocus(returnFocusNode);
          }
          onPostDeactivate?.();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    });
    __publicField4(this, "pause", (pauseOptions) => {
      if (this.state.paused || !this.state.active) {
        return this;
      }
      const onPause = this.getOption(pauseOptions, "onPause");
      const onPostPause = this.getOption(pauseOptions, "onPostPause");
      this.state.paused = true;
      onPause?.();
      this.removeListeners();
      this.updateObservedNodes();
      onPostPause?.();
      return this;
    });
    __publicField4(this, "unpause", (unpauseOptions) => {
      if (!this.state.paused || !this.state.active) {
        return this;
      }
      const onUnpause = this.getOption(unpauseOptions, "onUnpause");
      const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
      this.state.paused = false;
      onUnpause?.();
      this.updateTabbableNodes();
      this.addListeners();
      this.updateObservedNodes();
      onPostUnpause?.();
      return this;
    });
    __publicField4(this, "updateContainerElements", (containerElements) => {
      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);
      if (this.state.active) {
        this.updateTabbableNodes();
      }
      this.updateObservedNodes();
      return this;
    });
    __publicField4(this, "getReturnFocusNode", (previousActiveElement) => {
      const node = this.getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node ? node : node === false ? false : previousActiveElement;
    });
    __publicField4(this, "getOption", (configOverrideOptions, optionName, configOptionName) => {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (
        // @ts-expect-error
        this.config[configOptionName || optionName]
      );
    });
    __publicField4(this, "getNodeForOption", (optionName, { hasFallback = false, params = [] } = {}) => {
      let optionValue = this.config[optionName];
      if (typeof optionValue === "function") optionValue = optionValue(...params);
      if (optionValue === true) optionValue = void 0;
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error(`\`${optionName}\` was specified but was not a node, or did not return a node`);
      }
      let node = optionValue;
      if (typeof optionValue === "string") {
        try {
          node = this.doc.querySelector(optionValue);
        } catch (err) {
          throw new Error(`\`${optionName}\` appears to be an invalid selector; error="${err.message}"`);
        }
        if (!node) {
          if (!hasFallback) {
            throw new Error(`\`${optionName}\` as selector refers to no known node`);
          }
        }
      }
      return node;
    });
    __publicField4(this, "findNextNavNode", (opts) => {
      const { event, isBackward = false } = opts;
      const target = opts.target || getEventTarget(event);
      this.updateTabbableNodes();
      let destinationNode = null;
      if (this.state.tabbableGroups.length > 0) {
        const containerIndex = this.findContainerIndex(target, event);
        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          let startOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ firstTabbableNode }) => target === firstTabbableNode
          );
          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target, false);
          }
        } else {
          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ lastTabbableNode }) => target === lastTabbableNode
          );
          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = this.getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    });
    this.trapStack = options.trapStack || sharedTrapStack;
    const config = {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      followControlledElements: true,
      isKeyForward,
      isKeyBackward,
      ...options
    };
    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);
    this.config = config;
    this.updateContainerElements(elements);
    this.setupMutationObserver();
  }
  addPortalContainer(controlledElement) {
    const portalContainer = controlledElement.parentElement;
    if (portalContainer && !this.portalContainers.has(portalContainer)) {
      this.portalContainers.add(portalContainer);
      if (this.state.active && !this.state.paused) {
        this.observePortalContainer(portalContainer);
      }
    }
  }
  observePortalContainer(portalContainer) {
    this._mutationObserver?.observe(portalContainer, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["aria-controls", "aria-expanded"]
    });
  }
  updatePortalContainers() {
    if (!this.config.followControlledElements) return;
    this.state.containers.forEach((container) => {
      const controlledElements = getControlledElements(container);
      controlledElements.forEach((controlledElement) => {
        this.addPortalContainer(controlledElement);
      });
    });
  }
  get active() {
    return this.state.active;
  }
  get paused() {
    return this.state.paused;
  }
  findContainerIndex(element2, event) {
    const composedPath = typeof event?.composedPath === "function" ? event.composedPath() : void 0;
    return this.state.containerGroups.findIndex(
      ({ container, tabbableNodes }) => container.contains(element2) || composedPath?.includes(container) || tabbableNodes.find((node) => node === element2) || this.isControlledElement(container, element2)
    );
  }
  isControlledElement(container, element2) {
    if (!this.config.followControlledElements) return false;
    return isControlledElement(container, element2);
  }
  updateTabbableNodes() {
    this.state.containerGroups = this.state.containers.map((container) => {
      const tabbableNodes = getTabbables(container, { getShadowRoot: this.config.getShadowRoot });
      const focusableNodes = getFocusables(container, { getShadowRoot: this.config.getShadowRoot });
      const firstTabbableNode = tabbableNodes[0];
      const lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
      const firstDomTabbableNode = firstTabbableNode;
      const lastDomTabbableNode = lastTabbableNode;
      let posTabIndexesFound = false;
      for (let i = 0; i < tabbableNodes.length; i++) {
        if (getTabIndex(tabbableNodes[i]) > 0) {
          posTabIndexesFound = true;
          break;
        }
      }
      function nextTabbableNode(node, forward = true) {
        const nodeIdx = tabbableNodes.indexOf(node);
        if (nodeIdx >= 0) {
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
        const focusableIdx = focusableNodes.indexOf(node);
        if (focusableIdx < 0) return void 0;
        if (forward) {
          for (let i = focusableIdx + 1; i < focusableNodes.length; i++) {
            if (isTabbable(focusableNodes[i])) return focusableNodes[i];
          }
        } else {
          for (let i = focusableIdx - 1; i >= 0; i--) {
            if (isTabbable(focusableNodes[i])) return focusableNodes[i];
          }
        }
        return void 0;
      }
      return {
        container,
        tabbableNodes,
        focusableNodes,
        posTabIndexesFound,
        firstTabbableNode,
        lastTabbableNode,
        firstDomTabbableNode,
        lastDomTabbableNode,
        nextTabbableNode
      };
    });
    this.state.tabbableGroups = this.state.containerGroups.filter((group2) => group2.tabbableNodes.length > 0);
    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
      throw new Error(
        "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
      );
    }
    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {
      throw new Error(
        "At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps."
      );
    }
  }
  addListeners() {
    if (!this.state.active) return;
    activeFocusTraps.activateTrap(this.trapStack, this);
    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {
      this.tryFocus(this.getInitialFocusNode());
    }) : this.tryFocus(this.getInitialFocusNode());
    this.listenerCleanups.push(
      addDomEvent(this.doc, "focusin", this.handleFocus, true),
      addDomEvent(this.doc, "mousedown", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "touchstart", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "click", this.handleClick, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleTabKey, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleEscapeKey)
    );
    return this;
  }
  removeListeners() {
    if (!this.state.active) return;
    this.listenerCleanups.forEach((cleanup) => cleanup());
    this.listenerCleanups = [];
    return this;
  }
  activate(activateOptions) {
    if (this.state.active) {
      return this;
    }
    const onActivate = this.getOption(activateOptions, "onActivate");
    const onPostActivate = this.getOption(activateOptions, "onPostActivate");
    const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
    if (!checkCanFocusTrap) {
      this.updateTabbableNodes();
    }
    this.state.active = true;
    this.state.paused = false;
    this.state.nodeFocusedBeforeActivation = getActiveElement(this.doc);
    onActivate?.();
    const finishActivation = () => {
      if (checkCanFocusTrap) {
        this.updateTabbableNodes();
      }
      this.addListeners();
      this.updateObservedNodes();
      onPostActivate?.();
    };
    if (checkCanFocusTrap) {
      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
      return this;
    }
    finishActivation();
    return this;
  }
};
var isKeyboardEvent = (event) => event.type === "keydown";
var isTabEvent = (event) => isKeyboardEvent(event) && event?.key === "Tab";
var isKeyForward = (e) => isKeyboardEvent(e) && e.key === "Tab" && !e?.shiftKey;
var isKeyBackward = (e) => isKeyboardEvent(e) && e.key === "Tab" && e?.shiftKey;
var valueOrHandler = (value, ...params) => typeof value === "function" ? value(...params) : value;
var isEscapeEvent = (event) => !event.isComposing && event.key === "Escape";
var delay = (fn) => setTimeout(fn, 0);
var isSelectableInput = (node) => node.localName === "input" && "select" in node && typeof node.select === "function";
function trapFocus(el, options = {}) {
  let trap;
  const cleanup = raf(() => {
    const elements = Array.isArray(el) ? el : [el];
    const resolvedElements = elements.map((e) => typeof e === "function" ? e() : e).filter((e) => e != null);
    if (resolvedElements.length === 0) return;
    const primaryEl = resolvedElements[0];
    trap = new FocusTrap(resolvedElements, {
      escapeDeactivates: false,
      allowOutsideClick: true,
      preventScroll: true,
      returnFocusOnDeactivate: true,
      delayInitialFocus: false,
      fallbackFocus: primaryEl,
      ...options,
      document: getDocument(primaryEl)
    });
    try {
      trap.activate();
    } catch {
    }
  });
  return function destroy() {
    trap?.deactivate();
    cleanup();
  };
}

// node_modules/@zag-js/remove-scroll/dist/index.mjs
var LOCK_CLASSNAME = "data-scroll-lock";
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function hasStableScrollbarGutter(element2) {
  const styles = getComputedStyle2(element2);
  const scrollbarGutter = styles?.scrollbarGutter;
  return scrollbarGutter === "stable" || scrollbarGutter?.startsWith("stable ") === true;
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  const hasStableGutter = hasStableScrollbarGutter(documentElement) || hasStableScrollbarGutter(body);
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  body.setAttribute(LOCK_CLASSNAME, "");
  const setScrollbarWidthProperty = () => setStyleProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setBodyStyle = () => {
    const styles = {
      overflow: "hidden"
    };
    if (!hasStableGutter && scrollbarWidth > 0) {
      styles[paddingProperty] = `${scrollbarWidth}px`;
    }
    return setStyle(body, styles);
  };
  const setBodyStyleIOS = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = visualViewport?.offsetLeft ?? 0;
    const offsetTop = visualViewport?.offsetTop ?? 0;
    const styles = {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0"
    };
    if (!hasStableGutter && scrollbarWidth > 0) {
      styles[paddingProperty] = `${scrollbarWidth}px`;
    }
    const restoreStyle = setStyle(body, styles);
    return () => {
      restoreStyle?.();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setBodyStyleIOS() : setBodyStyle()];
  return () => {
    cleanups.forEach((fn) => fn?.());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// node_modules/@zag-js/dialog/dist/index.mjs
var anatomy7 = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts7 = anatomy7.build();
var getPositionerId3 = (ctx) => ctx.ids?.positioner ?? `dialog:${ctx.id}:positioner`;
var getBackdropId = (ctx) => ctx.ids?.backdrop ?? `dialog:${ctx.id}:backdrop`;
var getContentId4 = (ctx) => ctx.ids?.content ?? `dialog:${ctx.id}:content`;
var getTriggerId4 = (ctx) => ctx.ids?.trigger ?? `dialog:${ctx.id}:trigger`;
var getTitleId = (ctx) => ctx.ids?.title ?? `dialog:${ctx.id}:title`;
var getDescriptionId = (ctx) => ctx.ids?.description ?? `dialog:${ctx.id}:description`;
var getCloseTriggerId = (ctx) => ctx.ids?.closeTrigger ?? `dialog:${ctx.id}:close`;
var getContentEl4 = (ctx) => ctx.getById(getContentId4(ctx));
var getPositionerEl3 = (ctx) => ctx.getById(getPositionerId3(ctx));
var getBackdropEl = (ctx) => ctx.getById(getBackdropId(ctx));
var getTriggerEl3 = (ctx) => ctx.getById(getTriggerId4(ctx));
var getTitleEl = (ctx) => ctx.getById(getTitleId(ctx));
var getDescriptionEl = (ctx) => ctx.getById(getDescriptionId(ctx));
var getCloseTriggerEl = (ctx) => ctx.getById(getCloseTriggerId(ctx));
function connect7(service, normalize2) {
  const { state: state3, send, context, prop, scope } = service;
  const ariaLabel = prop("aria-label");
  const open = state3.matches("open");
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state3.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts7.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId4(scope),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": getContentId4(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "TOGGLE" });
        }
      });
    },
    getBackdropProps() {
      return normalize2.element({
        ...parts7.backdrop.attrs,
        dir: prop("dir"),
        hidden: !open,
        id: getBackdropId(scope),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts7.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId3(scope),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      const rendered = context.get("rendered");
      return normalize2.element({
        ...parts7.content.attrs,
        dir: prop("dir"),
        role: prop("role"),
        hidden: !open,
        id: getContentId4(scope),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : getTitleId(scope),
        "aria-describedby": rendered.description ? getDescriptionId(scope) : void 0
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts7.title.attrs,
        dir: prop("dir"),
        id: getTitleId(scope)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts7.description.attrs,
        dir: prop("dir"),
        id: getDescriptionId(scope)
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts7.closeTrigger.attrs,
        dir: prop("dir"),
        id: getCloseTriggerId(scope),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send({ type: "CLOSE" });
        }
      });
    }
  };
}
var machine7 = createMachine({
  props({ props: props25, scope }) {
    const alertDialog = props25.role === "alertdialog";
    const initialFocusEl = alertDialog ? () => getCloseTriggerEl(scope) : void 0;
    const modal = typeof props25.modal === "boolean" ? props25.modal : true;
    return {
      role: "dialog",
      modal,
      trapFocus: modal,
      preventScroll: modal,
      closeOnInteractOutside: !alertDialog,
      closeOnEscape: true,
      restoreFocus: true,
      initialFocusEl,
      ...props25
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable: bindable2 }) {
    return {
      rendered: bindable2(() => ({
        defaultValue: { title: true, description: true }
      }))
    };
  },
  watch({ track: track2, action, prop }) {
    track2([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    open: {
      entry: ["checkRenderedElements", "syncZIndex"],
      effects: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackDismissableElement({ scope, send, prop }) {
        const getContentEl22 = () => getContentEl4(scope);
        return trackDismissableElement(getContentEl22, {
          type: "dialog",
          defer: true,
          pointerBlocking: prop("modal"),
          exclude: [getTriggerEl3(scope)],
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          persistentElements: prop("persistentElements"),
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onRequestDismiss: prop("onRequestDismiss"),
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (!prop("closeOnEscape")) {
              event.preventDefault();
            }
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside" });
          }
        });
      },
      preventScroll({ scope, prop }) {
        if (!prop("preventScroll")) return;
        return preventBodyScroll(scope.getDoc());
      },
      trapFocus({ scope, prop }) {
        if (!prop("trapFocus")) return;
        const contentEl = () => getContentEl4(scope);
        return trapFocus(contentEl, {
          preventScroll: true,
          returnFocusOnDeactivate: !!prop("restoreFocus"),
          initialFocus: prop("initialFocusEl"),
          setReturnFocus: (el) => prop("finalFocusEl")?.() ?? el,
          getShadowRoot: true
        });
      },
      hideContentBelow({ scope, prop }) {
        if (!prop("modal")) return;
        const getElements4 = () => [getContentEl4(scope)];
        return ariaHidden(getElements4, { defer: true });
      }
    },
    actions: {
      checkRenderedElements({ context, scope }) {
        raf(() => {
          context.set("rendered", {
            title: !!getTitleEl(scope),
            description: !!getDescriptionEl(scope)
          });
        });
      },
      syncZIndex({ scope }) {
        raf(() => {
          const contentEl = getContentEl4(scope);
          if (!contentEl) return;
          const styles = getComputedStyle2(contentEl);
          const elems = [getPositionerEl3(scope), getBackdropEl(scope)];
          elems.forEach((node) => {
            node?.style.setProperty("--z-index", styles.zIndex);
            node?.style.setProperty("--layer-index", styles.getPropertyValue("--layer-index"));
          });
        });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      toggleVisibility({ prop, send, event }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
var props7 = createProps()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onRequestDismiss",
  "defaultOpen",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps8 = createSplitProps(props7);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/modules/provider.svelte.js
function useDialog(props25) {
  const service = useMachine(machine7, props25);
  const dialog = tag(user_derived(() => connect7(service, normalizeProps)), "dialog");
  return () => get(dialog);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/root.svelte
Root8[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/root.svelte";
function Root8($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root8);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps8(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), dialogProps = tag(user_derived(() => get($$array)[0]), "dialogProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const children = tag(user_derived(() => get(componentProps).children), "children");
  const dialog = useDialog(() => ({ ...get(dialogProps), id }));
  RootContext7.provide(() => dialog());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root8, 27, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root8 = hmr(Root8);
  import.meta.hot.accept((module) => {
    Root8[HMR].update(module.default);
  });
}
var root_default8 = Root8;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/title.svelte
Title[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/title.svelte";
var root_269 = add_locations(from_html(`<div><!></div>`), Title[FILENAME], [[24, 1]]);
function Title($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Title);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const dialog = RootContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(dialog().getTitleProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Title, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_269();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Title, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Title,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Title = hmr(Title);
  import.meta.hot.accept((module) => {
    Title[HMR].update(module.default);
  });
}
var title_default = Title;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/trigger.svelte
Trigger4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/anatomy/trigger.svelte";
var root_270 = add_locations(from_html(`<button><!></button>`), Trigger4[FILENAME], [[24, 1]]);
function Trigger4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const dialog = RootContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(dialog().getTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_270();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger4, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger4 = hmr(Trigger4);
  import.meta.hot.accept((module) => {
    Trigger4[HMR].update(module.default);
  });
}
var trigger_default4 = Trigger4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/dialog/modules/anatomy.js
var Dialog = Object.assign(root_default8, {
  Provider: root_provider_default7,
  Context: root_context_default7,
  Trigger: trigger_default4,
  Backdrop: backdrop_default,
  Positioner: positioner_default3,
  Content: content_default4,
  Title: title_default,
  Description: description_default,
  CloseTrigger: close_trigger_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/modules/root-context.js
var RootContext8 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/clear-trigger.svelte
Clear_trigger2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/clear-trigger.svelte";
var root_271 = add_locations(from_html(`<button><!></button>`), Clear_trigger2[FILENAME], [[24, 1]]);
function Clear_trigger2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Clear_trigger2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getClearTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Clear_trigger2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_271();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Clear_trigger2, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Clear_trigger2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Clear_trigger2 = hmr(Clear_trigger2);
  import.meta.hot.accept((module) => {
    Clear_trigger2[HMR].update(module.default);
  });
}
var clear_trigger_default2 = Clear_trigger2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/dropzone.svelte
Dropzone[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/dropzone.svelte";
var root_272 = add_locations(from_html(`<div><!></div>`), Dropzone[FILENAME], [[25, 1]]);
function Dropzone($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dropzone);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getDropzoneProps(props25), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Dropzone, 23, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_272();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Dropzone, 26, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Dropzone,
      22,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Dropzone = hmr(Dropzone);
  import.meta.hot.accept((module) => {
    Dropzone[HMR].update(module.default);
  });
}
var dropzone_default = Dropzone;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/hidden-input.svelte
Hidden_input[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/hidden-input.svelte";
var root_273 = add_locations(from_html(`<input/>`), Hidden_input[FILENAME], [[24, 1]]);
function Hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Hidden_input);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getHiddenInputProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Hidden_input, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_273();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Hidden_input,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Hidden_input = hmr(Hidden_input);
  import.meta.hot.accept((module) => {
    Hidden_input[HMR].update(module.default);
  });
}
var hidden_input_default = Hidden_input;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/modules/item-context.js
var ItemContext3 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item-delete-trigger.svelte
Item_delete_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item-delete-trigger.svelte";
var times = wrap_snippet(Item_delete_trigger, function($$anchor) {
  validate_snippet_args(...arguments);
  next();
  var text2 = text("");
  append($$anchor, text2);
});
var root_39 = add_locations(from_html(`<button><!></button>`), Item_delete_trigger[FILENAME], [[30, 1]]);
function Item_delete_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_delete_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const itemProps13 = ItemContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, times)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getItemDeleteTriggerProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_delete_trigger, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_39();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_delete_trigger, 31, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_delete_trigger,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_delete_trigger = hmr(Item_delete_trigger);
  import.meta.hot.accept((module) => {
    Item_delete_trigger[HMR].update(module.default);
  });
}
var item_delete_trigger_default = Item_delete_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item-group.svelte
Item_group3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item-group.svelte";
var root_274 = add_locations(from_html(`<ul><!></ul>`), Item_group3[FILENAME], [[24, 1]]);
function Item_group3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_group3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getItemGroupProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_group3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var ul = root_274();
      attribute_effect(ul, () => ({ ...get(attributes) }));
      var node_2 = child(ul);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_group3, 25, 2);
      reset(ul);
      append($$anchor2, ul);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_group3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_group3 = hmr(Item_group3);
  import.meta.hot.accept((module) => {
    Item_group3[HMR].update(module.default);
  });
}
var item_group_default3 = Item_group3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item-name.svelte
Item_name[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item-name.svelte";
var root_275 = add_locations(from_html(`<div><!></div>`), Item_name[FILENAME], [[26, 1]]);
function Item_name($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_name);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const itemProps13 = ItemContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getItemNameProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_name, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_275();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_name, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_name,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_name = hmr(Item_name);
  import.meta.hot.accept((module) => {
    Item_name[HMR].update(module.default);
  });
}
var item_name_default = Item_name;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item-size-text.svelte
Item_size_text[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item-size-text.svelte";
var root_276 = add_locations(from_html(`<div><!></div>`), Item_size_text[FILENAME], [[26, 1]]);
function Item_size_text($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_size_text);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const itemProps13 = ItemContext3.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getItemSizeTextProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_size_text, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_276();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_size_text, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_size_text,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_size_text = hmr(Item_size_text);
  import.meta.hot.accept((module) => {
    Item_size_text[HMR].update(module.default);
  });
}
var item_size_text_default = Item_size_text;

// node_modules/@zag-js/file-utils/dist/index.mjs
var getItemEntry = (item) => typeof item.getAsEntry === "function" ? item.getAsEntry() : typeof item.webkitGetAsEntry === "function" ? item.webkitGetAsEntry() : null;
var isDirectoryEntry = (entry) => entry.isDirectory;
var isFileEntry = (entry) => entry.isFile;
var addRelativePath = (file, path) => {
  Object.defineProperty(file, "relativePath", { value: path ? `${path}/${file.name}` : file.name });
  return file;
};
var getFileEntries = (items, traverseDirectories) => Promise.all(
  Array.from(items).filter((item) => item.kind === "file").map((item) => {
    const entry = getItemEntry(item);
    if (!entry) return null;
    if (isDirectoryEntry(entry) && traverseDirectories) {
      return getDirectoryFiles(entry.createReader(), `${entry.name}`);
    }
    if (isFileEntry(entry) && typeof item.getAsFile === "function") {
      const file = item.getAsFile();
      return Promise.resolve(file ? addRelativePath(file, "") : null);
    }
    if (isFileEntry(entry)) {
      return new Promise((resolve) => {
        entry.file((file) => {
          resolve(addRelativePath(file, ""));
        });
      });
    }
  }).filter((b) => b)
);
var getDirectoryFiles = (reader, path = "") => new Promise((resolve) => {
  const entryPromises = [];
  const readDirectoryEntries = () => {
    reader.readEntries((entries) => {
      if (entries.length === 0) {
        resolve(Promise.all(entryPromises).then((entries2) => entries2.flat()));
        return;
      }
      const promises = entries.map((entry) => {
        if (!entry) return null;
        if (isDirectoryEntry(entry)) {
          return getDirectoryFiles(entry.createReader(), `${path}${entry.name}`);
        }
        if (isFileEntry(entry)) {
          return new Promise((resolve2) => {
            entry.file((file) => {
              resolve2(addRelativePath(file, path));
            });
          });
        }
      }).filter((b) => b);
      entryPromises.push(Promise.all(promises));
      readDirectoryEntries();
    });
  };
  readDirectoryEntries();
});
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
var isValidMIME = (v) => isMIMEType(v) || isExt(v);
function getAcceptAttrString(accept) {
  if (accept == null) return;
  if (typeof accept === "string") {
    return accept;
  }
  if (Array.isArray(accept)) {
    return accept.filter(isValidMIME).join(",");
  }
  return Object.entries(accept).reduce((a, [mimeType, ext]) => [...a, mimeType, ...ext], []).filter(isValidMIME).join(",");
}
var isFileEqual = (file1, file2) => {
  return file1.name === file2.name && file1.size === file2.size && file1.type === file2.type;
};
var isDefined = (v) => v !== void 0 && v !== null;
function isValidFileSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, "FILE_TOO_LARGE"];
      if (file.size < minSize) return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(minSize) && file.size < minSize) {
      return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(maxSize) && file.size > maxSize) {
      return [false, "FILE_TOO_LARGE"];
    }
  }
  return [true, null];
}
var mimeTypes = "3g2_video/3gpp2[3gp,3gpp_video/3gpp[3mf_model/3mf[7z_application/x-7z-compressed[aac_audio/aac[ac_application/pkix-attr-cert[adp_audio/adpcm[adts_audio/aac[ai_application/postscript[aml_application/automationml-aml+xml[amlx_application/automationml-amlx+zip[amr_audio/amr[apk_application/vnd.android.package-archive[apng_image/apng[appcache,manifest_text/cache-manifest[appinstaller_application/appinstaller[appx_application/appx[appxbundle_application/appxbundle[asc_application/pgp-keys[atom_application/atom+xml[atomcat_application/atomcat+xml[atomdeleted_application/atomdeleted+xml[atomsvc_application/atomsvc+xml[au,snd_audio/basic[avi_video/x-msvideo[avci_image/avci[avcs_image/avcs[avif_image/avif[aw_application/applixware[bdoc_application/bdoc[bin,bpk,buffer,deb,deploy,dist,distz,dll,dmg,dms,dump,elc,exe,img,iso,lrf,mar,msi,msm,msp,pkg,so_application/octet-stream[bmp,dib_image/bmp[btf,btif_image/prs.btif[bz2_application/x-bzip2[c_text/x-c[ccxml_application/ccxml+xml[cdfx_application/cdfx+xml[cdmia_application/cdmi-capability[cdmic_application/cdmi-container[cdmid_application/cdmi-domain[cdmio_application/cdmi-object[cdmiq_application/cdmi-queue[cer_application/pkix-cert[cgm_image/cgm[cjs_application/node[class_application/java-vm[coffee,litcoffee_text/coffeescript[conf,def,in,ini,list,log,text,txt_text/plain[cpp,cxx,cc_text/x-c++src[cpl_application/cpl+xml[cpt_application/mac-compactpro[crl_application/pkix-crl[css_text/css[csv_text/csv[cu_application/cu-seeme[cwl_application/cwl[cww_application/prs.cww[davmount_application/davmount+xml[dbk_application/docbook+xml[doc_application/msword[docx_application/vnd.openxmlformats-officedocument.wordprocessingml.document[dsc_text/prs.lines.tag[dssc_application/dssc+der[dtd_application/xml-dtd[dwd_application/atsc-dwd+xml[ear,jar,war_application/java-archive[ecma_application/ecmascript[emf_image/emf[eml,mime_message/rfc822[emma_application/emma+xml[emotionml_application/emotionml+xml[eot_application/vnd.ms-fontobject[eps,ps_application/postscript[epub_application/epub+zip[exi_application/exi[exp_application/express[exr_image/aces[ez_application/andrew-inset[fdf_application/fdf[fdt_application/fdt+xml[fits_image/fits[flac_audio/flac[flv_video/x-flv[g3_image/g3fax[geojson_application/geo+json[gif_image/gif[glb_model/gltf-binary[gltf_model/gltf+json[gml_application/gml+xml[go_text/x-go[gpx_application/gpx+xml[gz_application/gzip[h_text/x-h[h261_video/h261[h263_video/h263[h264_video/h264[heic_image/heic[heics_image/heic-sequence[heif_image/heif[heifs_image/heif-sequence[htm,html,shtml_text/html[ico_image/x-icon[icns_image/x-icns[ics,ifb_text/calendar[iges,igs_model/iges[ink,inkml_application/inkml+xml[ipa_application/octet-stream[java_text/x-java-source[jp2,jpg2_image/jp2[jpeg,jpe,jpg_image/jpeg[jpf,jpx_image/jpx[jpm,jpgm_image/jpm[jpgv_video/jpeg[jph_image/jph[js,mjs_text/javascript[json_application/json[json5_application/json5[jsonld_application/ld+json[jsx_text/jsx[jxl_image/jxl[jxr_image/jxr[ktx_image/ktx[ktx2_image/ktx2[less_text/less[m1v,m2v,mpe,mpeg,mpg_video/mpeg[m4a_audio/mp4[m4v_video/x-m4v[md,markdown_text/markdown[mid,midi,kar,rmi_audio/midi[mkv_video/x-matroska[mp2,mp2a,mp3,mpga,m3a,m2a_audio/mpeg[mp4,mp4v,mpg4_video/mp4[mp4a_audio/mp4[mp4s,m4p_application/mp4[odp_application/vnd.oasis.opendocument.presentation[oda_application/oda[ods_application/vnd.oasis.opendocument.spreadsheet[odt_application/vnd.oasis.opendocument.text[oga,ogg,opus,spx_audio/ogg[ogv_video/ogg[ogx_application/ogg[otf_font/otf[p12,pfx_application/x-pkcs12[pdf_application/pdf[pem_application/x-pem-file[php_text/x-php[png_image/png[ppt_application/vnd.ms-powerpoint[pptx_application/vnd.openxmlformats-officedocument.presentationml.presentation[pskcxml_application/pskc+xml[psd_image/vnd.adobe.photoshop[py_text/x-python[qt,mov_video/quicktime[rar_application/vnd.rar[rdf_application/rdf+xml[rtf_text/rtf[sass_text/x-sass[scss_text/x-scss[sgm,sgml_text/sgml[sh_application/x-sh[svg,svgz_image/svg+xml[swf_application/x-shockwave-flash[tar_application/x-tar[tif,tiff_image/tiff[toml_application/toml[ts_video/mp2t[tsx_text/tsx[tsv_text/tab-separated-values[ttc_font/collection[ttf_font/ttf[vtt_text/vtt[wasm_application/wasm[wav_audio/wav[weba_audio/webm[webm_video/webm[webmanifest_application/manifest+json[webp_image/webp[wma_audio/x-ms-wma[wmv_video/x-ms-wmv[woff_font/woff[woff2_font/woff2[xls_application/vnd.ms-excel[xlsx_application/vnd.openxmlformats-officedocument.spreadsheetml.sheet[xml_application/xml[xz_application/x-xz[yaml,yml_text/yaml[zip_application/zip";
var mimeTypesMap = new Map(
  mimeTypes.split("[").flatMap((mime) => {
    const [extensions, mimeType] = mime.split("_");
    return extensions.split(",").map((ext) => [ext, mimeType]);
  })
);
function getFileMimeType(name) {
  const extension = name.split(".").pop();
  return extension ? mimeTypesMap.get(extension) || null : null;
}
function isFileAccepted(file, accept) {
  if (file && accept) {
    const types = Array.isArray(accept) ? accept : typeof accept === "string" ? accept.split(",") : [];
    if (types.length === 0) return true;
    const fileName = file.name || "";
    const mimeType = (file.type || getFileMimeType(fileName) || "").toLowerCase();
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return types.some((type) => {
      const validType = type.trim().toLowerCase();
      if (validType.charAt(0) === ".") {
        return fileName.toLowerCase().endsWith(validType);
      }
      if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
}
function isValidFileType(file, accept) {
  const isAcceptable = file.type === "application/x-moz-file" || isFileAccepted(file, accept);
  return [isAcceptable, isAcceptable ? null : "FILE_INVALID_TYPE"];
}

// node_modules/@zag-js/i18n-utils/dist/index.mjs
function i18nCache(Ins) {
  const formatterCache = /* @__PURE__ */ new Map();
  return function create(locale, options) {
    const cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
    if (formatterCache.has(cacheKey)) {
      return formatterCache.get(cacheKey);
    }
    let formatter = new Ins(locale, options);
    formatterCache.set(cacheKey, formatter);
    return formatter;
  };
}
var getCollator = i18nCache(Intl.Collator);
var collatorCache = i18nCache(Intl.Collator);
var getNumberFormatter = i18nCache(Intl.NumberFormat);
function formatNumber(v, locale, options = {}) {
  const formatter = getNumberFormatter(locale, options);
  return formatter.format(v);
}
var bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
var bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
var formatBytes = (bytes, locale = "en-US", options = {}) => {
  if (Number.isNaN(bytes)) return "";
  if (bytes === 0) return "0 B";
  const { unitSystem = "decimal", precision = 3, unit = "byte", unitDisplay = "short" } = options;
  const factor = unitSystem === "binary" ? 1024 : 1e3;
  const prefix = unit === "bit" ? bitPrefixes : bytePrefixes;
  const isNegative = bytes < 0;
  const absoluteBytes = Math.abs(bytes);
  let value = absoluteBytes;
  let index = 0;
  while (value >= factor && index < prefix.length - 1) {
    value /= factor;
    index++;
  }
  const v = parseFloat(value.toPrecision(precision));
  const finalValue = isNegative ? -v : v;
  return formatNumber(finalValue, locale, {
    style: "unit",
    unit: prefix[index] + unit,
    unitDisplay
  });
};
var getListFormatter = i18nCache(Intl.ListFormat);
var getRelativeTimeFormatter = i18nCache(Intl.RelativeTimeFormat);
var MINUTE_TO_MS = 1e3 * 60;
var HOUR_TO_MS = 1e3 * 60 * 60;
var DAY_TO_MS = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS = 1e3 * 60 * 60 * 24 * 365;

// node_modules/@zag-js/file-upload/dist/index.mjs
var anatomy8 = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
var parts8 = anatomy8.build();
var getRootId7 = (ctx) => ctx.ids?.root ?? `file:${ctx.id}`;
var getDropzoneId = (ctx) => ctx.ids?.dropzone ?? `file:${ctx.id}:dropzone`;
var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `file:${ctx.id}:input`;
var getTriggerId5 = (ctx) => ctx.ids?.trigger ?? `file:${ctx.id}:trigger`;
var getLabelId3 = (ctx) => ctx.ids?.label ?? `file:${ctx.id}:label`;
var getItemId4 = (ctx, id) => ctx.ids?.item?.(id) ?? `file:${ctx.id}:item:${id}`;
var getItemNameId = (ctx, id) => ctx.ids?.itemName?.(id) ?? `file:${ctx.id}:item-name:${id}`;
var getItemSizeTextId = (ctx, id) => ctx.ids?.itemSizeText?.(id) ?? `file:${ctx.id}:item-size:${id}`;
var getItemPreviewId = (ctx, id) => ctx.ids?.itemPreview?.(id) ?? `file:${ctx.id}:item-preview:${id}`;
var getItemDeleteTriggerId = (ctx, id) => ctx.ids?.itemDeleteTrigger?.(id) ?? `file:${ctx.id}:item-delete:${id}`;
var getFileId = (file) => hash(`${file.name}-${file.size}`);
var getRootEl3 = (ctx) => ctx.getById(getRootId7(ctx));
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));
var getDropzoneEl = (ctx) => ctx.getById(getDropzoneId(ctx));
function isEventWithFiles(event) {
  const target = getEventTarget(event);
  if (!event.dataTransfer) return !!target && "files" in target;
  return event.dataTransfer.types.some((type) => {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function isFilesWithinRange(ctx, incomingCount, currentAcceptedFiles) {
  const { prop, computed } = ctx;
  if (!computed("multiple") && incomingCount > 1) return false;
  if (!computed("multiple") && incomingCount + currentAcceptedFiles.length === 2) return true;
  if (incomingCount + currentAcceptedFiles.length > prop("maxFiles")) return false;
  return true;
}
function getEventFiles(ctx, files, currentAcceptedFiles = [], currentRejectedFiles = []) {
  const { prop, computed } = ctx;
  const acceptedFiles = [];
  const rejectedFiles = [];
  const validateParams = {
    acceptedFiles: currentAcceptedFiles,
    rejectedFiles: currentRejectedFiles
  };
  files.forEach((file) => {
    const [accepted, acceptError] = isValidFileType(file, computed("acceptAttr"));
    const [sizeMatch, sizeError] = isValidFileSize(file, prop("minFileSize"), prop("maxFileSize"));
    const validateErrors = prop("validate")?.(file, validateParams);
    const valid = validateErrors ? validateErrors.length === 0 : true;
    if (accepted && sizeMatch && valid) {
      acceptedFiles.push(file);
    } else {
      const errors = [acceptError, sizeError];
      if (!valid) errors.push(...validateErrors ?? []);
      rejectedFiles.push({ file, errors: errors.filter(Boolean) });
    }
  });
  if (!isFilesWithinRange(ctx, acceptedFiles.length, currentAcceptedFiles)) {
    acceptedFiles.forEach((file) => {
      rejectedFiles.push({ file, errors: ["TOO_MANY_FILES"] });
    });
    acceptedFiles.splice(0);
  }
  return {
    acceptedFiles,
    rejectedFiles
  };
}
function setInputFiles(inputEl, files) {
  const win = getWindow(inputEl);
  try {
    if ("DataTransfer" in win) {
      const dataTransfer = new win.DataTransfer();
      files.forEach((file) => {
        dataTransfer.items.add(file);
      });
      inputEl.files = dataTransfer.files;
    }
  } catch {
  }
}
var DEFAULT_ITEM_TYPE = "accepted";
var INTERACTIVE_SELECTOR = "button, a[href], input:not([type='file']), select, textarea, [tabindex], [contenteditable]";
function isInteractiveTarget(element2, container) {
  if (!element2 || element2.getAttribute("type") === "file") return false;
  const interactive = element2.closest(INTERACTIVE_SELECTOR);
  return interactive != container && contains(container, interactive);
}
function connect8(service, normalize2) {
  const { state: state3, send, prop, computed, scope, context } = service;
  const disabled = !!prop("disabled");
  const readOnly = !!prop("readOnly");
  const required = !!prop("required");
  const allowDrop = prop("allowDrop");
  const translations = prop("translations");
  const dragging = state3.matches("dragging");
  const focused = state3.matches("focused") && !disabled;
  const acceptedFiles = context.get("acceptedFiles");
  const maxFiles = prop("maxFiles");
  return {
    dragging,
    focused,
    disabled,
    readOnly,
    transforming: context.get("transforming"),
    maxFilesReached: acceptedFiles.length >= maxFiles,
    remainingFiles: Math.max(0, maxFiles - acceptedFiles.length),
    openFilePicker() {
      if (disabled || readOnly) return;
      send({ type: "OPEN" });
    },
    deleteFile(file, type = DEFAULT_ITEM_TYPE) {
      if (disabled || readOnly) return;
      send({ type: "FILE.DELETE", file, itemType: type });
    },
    acceptedFiles,
    rejectedFiles: context.get("rejectedFiles"),
    setFiles(files) {
      if (disabled || readOnly) return;
      send({ type: "FILES.SET", files, count: files.length });
    },
    clearRejectedFiles() {
      if (disabled || readOnly) return;
      send({ type: "REJECTED_FILES.CLEAR" });
    },
    clearFiles() {
      if (disabled || readOnly) return;
      send({ type: "FILES.CLEAR" });
    },
    getFileSize(file) {
      return formatBytes(file.size, prop("locale"));
    },
    createFileUrl(file, cb) {
      const win = scope.getWin();
      const url = win.URL.createObjectURL(file);
      cb(url);
      return () => win.URL.revokeObjectURL(url);
    },
    setClipboardFiles(dt) {
      if (disabled || readOnly) return false;
      const items = Array.from(dt?.items ?? []);
      const files = items.reduce((acc, item) => {
        if (item.kind !== "file") return acc;
        const file = item.getAsFile();
        if (!file) return acc;
        return [...acc, file];
      }, []);
      if (!files.length) return false;
      send({ type: "FILE.SELECT", files });
      return true;
    },
    getRootProps() {
      return normalize2.element({
        ...parts8.root.attrs,
        dir: prop("dir"),
        id: getRootId7(scope),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "data-dragging": dataAttr(dragging)
      });
    },
    getDropzoneProps(props25 = {}) {
      return normalize2.element({
        ...parts8.dropzone.attrs,
        dir: prop("dir"),
        id: getDropzoneId(scope),
        tabIndex: disabled || readOnly || props25.disableClick ? void 0 : 0,
        role: props25.disableClick ? "application" : "button",
        "aria-label": translations.dropzone,
        "aria-disabled": disabled,
        "aria-readonly": readOnly,
        "data-invalid": dataAttr(prop("invalid")),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "data-dragging": dataAttr(dragging),
        onKeyDown(event) {
          if (disabled || readOnly) return;
          if (event.defaultPrevented) return;
          const target = getEventTarget(event);
          if (!contains(event.currentTarget, target)) return;
          if (isInteractiveTarget(target, event.currentTarget)) return;
          if (props25.disableClick) return;
          if (event.key !== "Enter" && event.key !== " ") return;
          send({ type: "DROPZONE.CLICK", src: "keydown" });
        },
        onClick(event) {
          if (disabled || readOnly) return;
          if (event.defaultPrevented) return;
          if (props25.disableClick) return;
          const target = getEventTarget(event);
          if (!contains(event.currentTarget, target)) return;
          if (isInteractiveTarget(target, event.currentTarget)) return;
          if (event.currentTarget.localName === "label") {
            event.preventDefault();
          }
          send({ type: "DROPZONE.CLICK" });
        },
        onDragOver(event) {
          if (disabled || readOnly) return;
          if (!allowDrop) return;
          event.preventDefault();
          event.stopPropagation();
          try {
            event.dataTransfer.dropEffect = "copy";
          } catch {
          }
          const hasFiles = isEventWithFiles(event);
          if (!hasFiles) return;
          const count = event.dataTransfer.items.length;
          send({ type: "DROPZONE.DRAG_OVER", count });
        },
        onDragLeave(event) {
          if (disabled || readOnly) return;
          if (!allowDrop) return;
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "DROPZONE.DRAG_LEAVE" });
        },
        onDrop(event) {
          if (disabled || readOnly) return;
          if (allowDrop) {
            event.preventDefault();
            event.stopPropagation();
          }
          const hasFiles = isEventWithFiles(event);
          if (!hasFiles) return;
          getFileEntries(event.dataTransfer.items, prop("directory")).then((files) => {
            send({ type: "DROPZONE.DROP", files: flatArray(files) });
          });
        },
        onFocus() {
          if (disabled || readOnly) return;
          send({ type: "DROPZONE.FOCUS" });
        },
        onBlur() {
          if (disabled || readOnly) return;
          send({ type: "DROPZONE.BLUR" });
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts8.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId5(scope),
        disabled: disabled || readOnly,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "data-invalid": dataAttr(prop("invalid")),
        type: "button",
        onClick(event) {
          if (disabled || readOnly) return;
          if (contains(getDropzoneEl(scope), event.currentTarget)) {
            event.stopPropagation();
          }
          send({ type: "OPEN" });
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: getHiddenInputId(scope),
        tabIndex: -1,
        disabled: disabled || readOnly,
        type: "file",
        required: prop("required"),
        capture: prop("capture"),
        name: prop("name"),
        accept: computed("acceptAttr"),
        webkitdirectory: prop("directory") ? "" : void 0,
        multiple: computed("multiple") || prop("maxFiles") > 1,
        onClick(event) {
          event.stopPropagation();
          event.currentTarget.value = "";
        },
        onInput(event) {
          if (disabled || readOnly) return;
          const { files } = event.currentTarget;
          send({ type: "FILE.SELECT", files: files ? Array.from(files) : [] });
        },
        style: visuallyHiddenStyle
      });
    },
    getItemGroupProps(props25 = {}) {
      const { type = DEFAULT_ITEM_TYPE } = props25;
      return normalize2.element({
        ...parts8.itemGroup.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-type": type
      });
    },
    getItemProps(props25) {
      const { file, type = DEFAULT_ITEM_TYPE } = props25;
      return normalize2.element({
        ...parts8.item.attrs,
        dir: prop("dir"),
        id: getItemId4(scope, getFileId(file)),
        "data-disabled": dataAttr(disabled),
        "data-type": type
      });
    },
    getItemNameProps(props25) {
      const { file, type = DEFAULT_ITEM_TYPE } = props25;
      return normalize2.element({
        ...parts8.itemName.attrs,
        dir: prop("dir"),
        id: getItemNameId(scope, getFileId(file)),
        "data-disabled": dataAttr(disabled),
        "data-type": type
      });
    },
    getItemSizeTextProps(props25) {
      const { file, type = DEFAULT_ITEM_TYPE } = props25;
      return normalize2.element({
        ...parts8.itemSizeText.attrs,
        dir: prop("dir"),
        id: getItemSizeTextId(scope, getFileId(file)),
        "data-disabled": dataAttr(disabled),
        "data-type": type
      });
    },
    getItemPreviewProps(props25) {
      const { file, type = DEFAULT_ITEM_TYPE } = props25;
      return normalize2.element({
        ...parts8.itemPreview.attrs,
        dir: prop("dir"),
        id: getItemPreviewId(scope, getFileId(file)),
        "data-disabled": dataAttr(disabled),
        "data-type": type
      });
    },
    getItemPreviewImageProps(props25) {
      const { file, url, type = DEFAULT_ITEM_TYPE } = props25;
      const isImage = file.type.startsWith("image/");
      if (!isImage) {
        throw new Error("Preview Image is only supported for image files");
      }
      return normalize2.img({
        ...parts8.itemPreviewImage.attrs,
        alt: translations.itemPreview?.(file),
        src: url,
        "data-disabled": dataAttr(disabled),
        "data-type": type
      });
    },
    getItemDeleteTriggerProps(props25) {
      const { file, type = DEFAULT_ITEM_TYPE } = props25;
      return normalize2.button({
        ...parts8.itemDeleteTrigger.attrs,
        dir: prop("dir"),
        id: getItemDeleteTriggerId(scope, getFileId(file)),
        type: "button",
        disabled: disabled || readOnly,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "data-type": type,
        "aria-label": translations.deleteFile?.(file),
        onClick() {
          if (disabled || readOnly) return;
          send({ type: "FILE.DELETE", file, itemType: type });
        }
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts8.label.attrs,
        dir: prop("dir"),
        id: getLabelId3(scope),
        htmlFor: getHiddenInputId(scope),
        "data-disabled": dataAttr(disabled),
        "data-required": dataAttr(required)
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts8.clearTrigger.attrs,
        dir: prop("dir"),
        type: "button",
        disabled: disabled || readOnly,
        hidden: acceptedFiles.length === 0,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled || readOnly) return;
          send({ type: "FILES.CLEAR" });
        }
      });
    }
  };
}
var machine8 = createMachine({
  props({ props: props25 }) {
    return {
      minFileSize: 0,
      maxFileSize: Number.POSITIVE_INFINITY,
      maxFiles: 1,
      allowDrop: true,
      preventDocumentDrop: true,
      defaultAcceptedFiles: [],
      ...props25,
      translations: {
        dropzone: "dropzone",
        itemPreview: (file) => `preview of ${file.name}`,
        deleteFile: (file) => `delete file ${file.name}`,
        ...props25.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable: bindable2, getContext: getContext2 }) {
    return {
      acceptedFiles: bindable2(() => ({
        defaultValue: prop("defaultAcceptedFiles"),
        value: prop("acceptedFiles"),
        isEqual: (a, b) => a.length === b?.length && a.every((file, i) => isFileEqual(file, b[i])),
        hash(value) {
          return value.map((file) => `${file.name}-${file.size}`).join(",");
        },
        onChange(value) {
          const ctx = getContext2();
          prop("onFileAccept")?.({ files: value });
          prop("onFileChange")?.({ acceptedFiles: value, rejectedFiles: ctx.get("rejectedFiles") });
        }
      })),
      rejectedFiles: bindable2(() => ({
        defaultValue: [],
        isEqual: (a, b) => a.length === b?.length && a.every((file, i) => isFileEqual(file.file, b[i].file)),
        onChange(value) {
          const ctx = getContext2();
          prop("onFileReject")?.({ files: value });
          prop("onFileChange")?.({ acceptedFiles: ctx.get("acceptedFiles"), rejectedFiles: value });
        }
      })),
      transforming: bindable2(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    acceptAttr: ({ prop }) => getAcceptAttrString(prop("accept")),
    multiple: ({ prop }) => prop("maxFiles") > 1
  },
  watch({ track: track2, context, action }) {
    track2([() => context.hash("acceptedFiles")], () => {
      action(["syncInputElement"]);
    });
  },
  on: {
    "FILES.SET": {
      actions: ["setFiles"]
    },
    "FILE.SELECT": {
      actions: ["setEventFiles"]
    },
    "FILE.DELETE": {
      actions: ["removeFile"]
    },
    "FILES.CLEAR": {
      actions: ["clearFiles"]
    },
    "REJECTED_FILES.CLEAR": {
      actions: ["clearRejectedFiles"]
    }
  },
  effects: ["preventDocumentDrop"],
  states: {
    idle: {
      on: {
        OPEN: {
          actions: ["openFilePicker"]
        },
        "DROPZONE.CLICK": {
          actions: ["openFilePicker"]
        },
        "DROPZONE.FOCUS": {
          target: "focused"
        },
        "DROPZONE.DRAG_OVER": {
          target: "dragging"
        }
      }
    },
    focused: {
      on: {
        "DROPZONE.BLUR": {
          target: "idle"
        },
        OPEN: {
          actions: ["openFilePicker"]
        },
        "DROPZONE.CLICK": {
          actions: ["openFilePicker"]
        },
        "DROPZONE.DRAG_OVER": {
          target: "dragging"
        }
      }
    },
    dragging: {
      on: {
        "DROPZONE.DROP": {
          target: "idle",
          actions: ["setEventFiles"]
        },
        "DROPZONE.DRAG_LEAVE": {
          target: "idle"
        }
      }
    }
  },
  implementations: {
    effects: {
      preventDocumentDrop({ prop, scope }) {
        if (!prop("preventDocumentDrop")) return;
        if (!prop("allowDrop")) return;
        if (prop("disabled")) return;
        const doc = scope.getDoc();
        const onDragOver = (event) => {
          event?.preventDefault();
        };
        const onDrop = (event) => {
          if (contains(getRootEl3(scope), getEventTarget(event))) return;
          event.preventDefault();
        };
        return callAll(addDomEvent(doc, "dragover", onDragOver, false), addDomEvent(doc, "drop", onDrop, false));
      }
    },
    actions: {
      syncInputElement({ scope, context }) {
        queueMicrotask(() => {
          const inputEl = getHiddenInputEl(scope);
          if (!inputEl) return;
          setInputFiles(inputEl, context.get("acceptedFiles"));
          const win = scope.getWin();
          inputEl.dispatchEvent(new win.Event("change", { bubbles: true }));
        });
      },
      openFilePicker({ scope }) {
        raf(() => {
          getHiddenInputEl(scope)?.click();
        });
      },
      setFiles(params) {
        const { computed, context, event } = params;
        const { acceptedFiles, rejectedFiles } = getEventFiles(params, event.files);
        context.set(
          "acceptedFiles",
          computed("multiple") ? acceptedFiles : acceptedFiles.length > 0 ? [acceptedFiles[0]] : []
        );
        context.set("rejectedFiles", rejectedFiles);
      },
      setEventFiles(params) {
        const { computed, context, event, prop } = params;
        const currentAcceptedFiles = context.get("acceptedFiles");
        const currentRejectedFiles = context.get("rejectedFiles");
        const { acceptedFiles, rejectedFiles } = getEventFiles(
          params,
          event.files,
          currentAcceptedFiles,
          currentRejectedFiles
        );
        const set2 = (files) => {
          if (computed("multiple")) {
            context.set("acceptedFiles", (prev2) => [...prev2, ...files]);
            context.set("rejectedFiles", rejectedFiles);
            return;
          }
          if (files.length) {
            context.set("acceptedFiles", [files[0]]);
            context.set("rejectedFiles", rejectedFiles);
            return;
          }
          if (rejectedFiles.length) {
            context.set("acceptedFiles", context.get("acceptedFiles"));
            context.set("rejectedFiles", rejectedFiles);
          }
        };
        const transform2 = prop("transformFiles");
        if (transform2) {
          context.set("transforming", true);
          transform2(acceptedFiles).then(set2).catch((err) => {
            warn(`[zag-js/file-upload] error transforming files
${err}`);
          }).finally(() => {
            context.set("transforming", false);
          });
        } else {
          set2(acceptedFiles);
        }
      },
      removeFile({ context, event }) {
        if (event.itemType === "rejected") {
          const rejectedFiles = context.get("rejectedFiles").filter((item) => !isFileEqual(item.file, event.file));
          context.set("rejectedFiles", rejectedFiles);
        } else {
          const files = context.get("acceptedFiles").filter((file) => !isFileEqual(file, event.file));
          context.set("acceptedFiles", files);
        }
      },
      clearRejectedFiles({ context }) {
        context.set("rejectedFiles", []);
      },
      clearFiles({ context }) {
        context.set("acceptedFiles", []);
        context.set("rejectedFiles", []);
      }
    }
  }
});
var props8 = createProps()([
  "accept",
  "acceptedFiles",
  "allowDrop",
  "capture",
  "defaultAcceptedFiles",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "onFileAccept",
  "onFileChange",
  "onFileReject",
  "preventDocumentDrop",
  "readOnly",
  "required",
  "transformFiles",
  "translations",
  "validate"
]);
var splitProps9 = createSplitProps(props8);
var itemProps4 = createProps()(["file", "type"]);
var splitItemProps4 = createSplitProps(itemProps4);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item.svelte
Item4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/item.svelte";
var root_277 = add_locations(from_html(`<li><!></li>`), Item4[FILENAME], [[30, 1]]);
function Item4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const $$d = user_derived(() => splitItemProps4(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getItemProps(get(itemProps13)), get(rest))), "attributes");
  ItemContext3.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item4, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var li = root_277();
      attribute_effect(li, () => ({ ...get(attributes) }));
      var node_2 = child(li);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item4, 31, 2);
      reset(li);
      append($$anchor2, li);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item4,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item4 = hmr(Item4);
  import.meta.hot.accept((module) => {
    Item4[HMR].update(module.default);
  });
}
var item_default4 = Item4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/label.svelte
Label3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/label.svelte";
var root_278 = add_locations(from_html(`<label><!></label>`), Label3[FILENAME], [[24, 1]]);
function Label3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_278();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label3, 25, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label3 = hmr(Label3);
  import.meta.hot.accept((module) => {
    Label3[HMR].update(module.default);
  });
}
var label_default3 = Label3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/root-context.svelte
Root_context8[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/root-context.svelte";
function Root_context8($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context8);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => fileUpload), "render", Root_context8, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context8 = hmr(Root_context8);
  import.meta.hot.accept((module) => {
    Root_context8[HMR].update(module.default);
  });
}
var root_context_default8 = Root_context8;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/root-provider.svelte
Root_provider8[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/root-provider.svelte";
var root_279 = add_locations(from_html(`<div><!></div>`), Root_provider8[FILENAME], [[27, 1]]);
function Root_provider8($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider8);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), fileUpload = tag(user_derived(() => $$props.value), "fileUpload"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(fileUpload)().getRootProps(), get(rest))), "attributes");
  RootContext8.provide(() => get(fileUpload)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider8, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_279();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider8, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider8,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider8 = hmr(Root_provider8);
  import.meta.hot.accept((module) => {
    Root_provider8[HMR].update(module.default);
  });
}
var root_provider_default8 = Root_provider8;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/modules/provider.svelte.js
function useFileUpload(props25) {
  const service = useMachine(machine8, props25);
  const fileUpload = tag(user_derived(() => connect8(service, normalizeProps)), "fileUpload");
  return () => get(fileUpload);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/root.svelte
Root9[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/root.svelte";
var root_280 = add_locations(from_html(`<div><!></div>`), Root9[FILENAME], [[34, 1]]);
function Root9($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root9);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps9(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), fileUploadProps = tag(user_derived(() => get($$array)[0]), "fileUploadProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const fileUpload = useFileUpload(() => ({ ...get(fileUploadProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getRootProps(), get(rest))), "attributes");
  RootContext8.provide(() => fileUpload());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root9, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_280();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root9, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root9,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root9 = hmr(Root9);
  import.meta.hot.accept((module) => {
    Root9[HMR].update(module.default);
  });
}
var root_default9 = Root9;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/trigger.svelte
Trigger5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/anatomy/trigger.svelte";
var root_281 = add_locations(from_html(`<button><!></button>`), Trigger5[FILENAME], [[24, 1]]);
function Trigger5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const fileUpload = RootContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(fileUpload().getTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger5, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_281();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger5, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger5,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger5 = hmr(Trigger5);
  import.meta.hot.accept((module) => {
    Trigger5[HMR].update(module.default);
  });
}
var trigger_default5 = Trigger5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/file-upload/modules/anatomy.js
var FileUpload = Object.assign(root_default9, {
  Provider: root_provider_default8,
  Context: root_context_default8,
  Label: label_default3,
  Dropzone: dropzone_default,
  Trigger: trigger_default5,
  ClearTrigger: clear_trigger_default2,
  HiddenInput: hidden_input_default,
  ItemGroup: item_group_default3,
  Item: item_default4,
  ItemName: item_name_default,
  ItemSizeText: item_size_text_default,
  ItemDeleteTrigger: item_delete_trigger_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/modules/root-context.js
var RootContext9 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/body.svelte
Body[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/body.svelte";
var root_282 = add_locations(from_html(`<div><!></div>`), Body[FILENAME], [[24, 1]]);
function Body($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Body);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getBodyProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Body, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_282();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Body, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Body,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Body = hmr(Body);
  import.meta.hot.accept((module) => {
    Body[HMR].update(module.default);
  });
}
var body_default = Body;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/close-trigger.svelte
Close_trigger2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/close-trigger.svelte";
var root_283 = add_locations(from_html(`<button><!></button>`), Close_trigger2[FILENAME], [[24, 1]]);
function Close_trigger2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Close_trigger2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getCloseTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Close_trigger2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_283();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Close_trigger2, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Close_trigger2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Close_trigger2 = hmr(Close_trigger2);
  import.meta.hot.accept((module) => {
    Close_trigger2[HMR].update(module.default);
  });
}
var close_trigger_default2 = Close_trigger2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/content.svelte
Content5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/content.svelte";
var root_284 = add_locations(from_html(`<div><!></div>`), Content5[FILENAME], [[24, 1]]);
function Content5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getContentProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content5, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_284();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content5, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content5,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content5 = hmr(Content5);
  import.meta.hot.accept((module) => {
    Content5[HMR].update(module.default);
  });
}
var content_default5 = Content5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/control.svelte
Control4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/control.svelte";
var root_285 = add_locations(from_html(`<div><!></div>`), Control4[FILENAME], [[24, 1]]);
function Control4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getControlProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Control4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_285();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Control4, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Control4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Control4 = hmr(Control4);
  import.meta.hot.accept((module) => {
    Control4[HMR].update(module.default);
  });
}
var control_default4 = Control4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/drag-trigger.svelte
Drag_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/drag-trigger.svelte";
var root_286 = add_locations(from_html(`<div><!></div>`), Drag_trigger[FILENAME], [[24, 1]]);
function Drag_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Drag_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getDragTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Drag_trigger, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_286();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Drag_trigger, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Drag_trigger,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Drag_trigger = hmr(Drag_trigger);
  import.meta.hot.accept((module) => {
    Drag_trigger[HMR].update(module.default);
  });
}
var drag_trigger_default = Drag_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/header.svelte
Header[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/header.svelte";
var root_287 = add_locations(from_html(`<div><!></div>`), Header[FILENAME], [[24, 1]]);
function Header($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Header);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getHeaderProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Header, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_287();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Header, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Header,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Header = hmr(Header);
  import.meta.hot.accept((module) => {
    Header[HMR].update(module.default);
  });
}
var header_default = Header;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/positioner.svelte
Positioner4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/positioner.svelte";
var root_288 = add_locations(from_html(`<div><!></div>`), Positioner4[FILENAME], [[24, 1]]);
function Positioner4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Positioner4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getPositionerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Positioner4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_288();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Positioner4, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Positioner4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Positioner4 = hmr(Positioner4);
  import.meta.hot.accept((module) => {
    Positioner4[HMR].update(module.default);
  });
}
var positioner_default4 = Positioner4;

// node_modules/@zag-js/rect-utils/dist/index.mjs
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
var AffineTransform = class _AffineTransform {
  constructor([m00, m01, m02, m10, m11, m12] = [0, 0, 0, 0, 0, 0]) {
    __publicField5(this, "m00");
    __publicField5(this, "m01");
    __publicField5(this, "m02");
    __publicField5(this, "m10");
    __publicField5(this, "m11");
    __publicField5(this, "m12");
    __publicField5(this, "rotate", (...args) => {
      return this.prepend(_AffineTransform.rotate(...args));
    });
    __publicField5(this, "scale", (...args) => {
      return this.prepend(_AffineTransform.scale(...args));
    });
    __publicField5(this, "translate", (...args) => {
      return this.prepend(_AffineTransform.translate(...args));
    });
    this.m00 = m00;
    this.m01 = m01;
    this.m02 = m02;
    this.m10 = m10;
    this.m11 = m11;
    this.m12 = m12;
  }
  applyTo(point) {
    const { x: x2, y } = point;
    const { m00, m01, m02, m10, m11, m12 } = this;
    return {
      x: m00 * x2 + m01 * y + m02,
      y: m10 * x2 + m11 * y + m12
    };
  }
  prepend(other) {
    return new _AffineTransform([
      this.m00 * other.m00 + this.m01 * other.m10,
      // m00
      this.m00 * other.m01 + this.m01 * other.m11,
      // m01
      this.m00 * other.m02 + this.m01 * other.m12 + this.m02,
      // m02
      this.m10 * other.m00 + this.m11 * other.m10,
      // m10
      this.m10 * other.m01 + this.m11 * other.m11,
      // m11
      this.m10 * other.m02 + this.m11 * other.m12 + this.m12
      // m12
    ]);
  }
  append(other) {
    return new _AffineTransform([
      other.m00 * this.m00 + other.m01 * this.m10,
      // m00
      other.m00 * this.m01 + other.m01 * this.m11,
      // m01
      other.m00 * this.m02 + other.m01 * this.m12 + other.m02,
      // m02
      other.m10 * this.m00 + other.m11 * this.m10,
      // m10
      other.m10 * this.m01 + other.m11 * this.m11,
      // m11
      other.m10 * this.m02 + other.m11 * this.m12 + other.m12
      // m12
    ]);
  }
  get determinant() {
    return this.m00 * this.m11 - this.m01 * this.m10;
  }
  get isInvertible() {
    const det = this.determinant;
    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;
  }
  invert() {
    const det = this.determinant;
    return new _AffineTransform([
      this.m11 / det,
      // m00
      -this.m01 / det,
      // m01
      (this.m01 * this.m12 - this.m11 * this.m02) / det,
      // m02
      -this.m10 / det,
      // m10
      this.m00 / det,
      // m11
      (this.m10 * this.m02 - this.m00 * this.m12) / det
      // m12
    ]);
  }
  get array() {
    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1];
  }
  get float32Array() {
    return new Float32Array(this.array);
  }
  // Static
  static get identity() {
    return new _AffineTransform([1, 0, 0, 0, 1, 0]);
  }
  static rotate(theta, origin) {
    const rotation = new _AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0]);
    if (origin && (origin.x !== 0 || origin.y !== 0)) {
      return _AffineTransform.multiply(
        _AffineTransform.translate(origin.x, origin.y),
        rotation,
        _AffineTransform.translate(-origin.x, -origin.y)
      );
    }
    return rotation;
  }
  static scale(sx, sy = sx, origin = { x: 0, y: 0 }) {
    const scale = new _AffineTransform([sx, 0, 0, 0, sy, 0]);
    if (origin.x !== 0 || origin.y !== 0) {
      return _AffineTransform.multiply(
        _AffineTransform.translate(origin.x, origin.y),
        scale,
        _AffineTransform.translate(-origin.x, -origin.y)
      );
    }
    return scale;
  }
  static translate(tx, ty) {
    return new _AffineTransform([1, 0, tx, 0, 1, ty]);
  }
  static multiply(...[first2, ...rest]) {
    if (!first2) return _AffineTransform.identity;
    return rest.reduce((result, item) => result.prepend(item), first2);
  }
  get a() {
    return this.m00;
  }
  get b() {
    return this.m10;
  }
  get c() {
    return this.m01;
  }
  get d() {
    return this.m11;
  }
  get tx() {
    return this.m02;
  }
  get ty() {
    return this.m12;
  }
  get scaleComponents() {
    return { x: this.a, y: this.d };
  }
  get translationComponents() {
    return { x: this.tx, y: this.ty };
  }
  get skewComponents() {
    return { x: this.c, y: this.b };
  }
  toString() {
    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;
  }
};
var clamp3 = (value, min3, max22) => Math.min(Math.max(value, min3), max22);
var clampPoint = (position, size2, boundaryRect) => {
  const x2 = clamp3(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size2.width);
  const y = clamp3(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size2.height);
  return { x: x2, y };
};
var defaultMinSize = {
  width: 0,
  height: 0
};
var defaultMaxSize = {
  width: Infinity,
  height: Infinity
};
var clampSize = (size2, minSize = defaultMinSize, maxSize = defaultMaxSize) => {
  return {
    width: Math.min(Math.max(size2.width, minSize.width), maxSize.width),
    height: Math.min(Math.max(size2.height, minSize.height), maxSize.height)
  };
};
var createPoint = (x2, y) => ({ x: x2, y });
var subtractPoints = (a, b) => {
  if (!b) return a;
  return createPoint(a.x - b.x, a.y - b.y);
};
var addPoints = (a, b) => createPoint(a.x + b.x, a.y + b.y);
function createRect(r) {
  const { x: x2, y, width, height } = r;
  const midX = x2 + width / 2;
  const midY = y + height / 2;
  return {
    x: x2,
    y,
    width,
    height,
    minX: x2,
    minY: y,
    maxX: x2 + width,
    maxY: y + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function getRectCorners(v) {
  const top = createPoint(v.minX, v.minY);
  const right = createPoint(v.maxX, v.minY);
  const bottom = createPoint(v.maxX, v.maxY);
  const left = createPoint(v.minX, v.maxY);
  return { top, right, bottom, left };
}
var constrainRect = (rect, boundary) => {
  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));
  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));
  return {
    x: left,
    y: top,
    width: Math.min(rect.width, boundary.width),
    height: Math.min(rect.height, boundary.height)
  };
};
var isSizeEqual = (a, b) => {
  return a.width === b?.width && a.height === b?.height;
};
var isPointEqual = (a, b) => {
  return a.x === b?.x && a.y === b?.y;
};
var styleCache2 = /* @__PURE__ */ new WeakMap();
function getCacheComputedStyle(el) {
  if (!styleCache2.has(el)) {
    const win = el.ownerDocument.defaultView || window;
    styleCache2.set(el, win.getComputedStyle(el));
  }
  return styleCache2.get(el);
}
function getElementRect(el, opts = {}) {
  return createRect(getClientRect(el, opts));
}
function getClientRect(el, opts = {}) {
  const { excludeScrollbar = false, excludeBorders = false } = opts;
  const { x: x2, y, width, height } = el.getBoundingClientRect();
  const r = { x: x2, y, width, height };
  const style = getCacheComputedStyle(el);
  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style;
  const borderXWidth = sum(borderLeftWidth, borderRightWidth);
  const borderYWidth = sum(borderTopWidth, borderBottomWidth);
  if (excludeBorders) {
    r.width -= borderXWidth;
    r.height -= borderYWidth;
    r.x += px(borderLeftWidth);
    r.y += px(borderTopWidth);
  }
  if (excludeScrollbar) {
    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;
    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;
    r.width -= scrollbarWidth;
    r.height -= scrollbarHeight;
  }
  return r;
}
var px = (v) => parseFloat(v.replace("px", ""));
var sum = (...vals) => vals.reduce((sum2, v) => sum2 + (v ? px(v) : 0), 0);
var { min: min2, max: max2 } = Math;
function getWindowRect(win, opts = {}) {
  return createRect(getViewportRect(win, opts));
}
function getViewportRect(win, opts) {
  const { excludeScrollbar = false } = opts;
  const { innerWidth, innerHeight, document: doc, visualViewport } = win;
  const width = visualViewport?.width || innerWidth;
  const height = visualViewport?.height || innerHeight;
  const rect = { x: 0, y: 0, width, height };
  if (excludeScrollbar) {
    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;
    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;
    rect.width -= scrollbarWidth;
    rect.height -= scrollbarHeight;
  }
  return rect;
}
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point) {
  const { x: x2, y } = point;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
var compassDirectionMap = {
  n: { x: 0.5, y: 0 },
  ne: { x: 1, y: 0 },
  e: { x: 1, y: 0.5 },
  se: { x: 1, y: 1 },
  s: { x: 0.5, y: 1 },
  sw: { x: 0, y: 1 },
  w: { x: 0, y: 0.5 },
  nw: { x: 0, y: 0 }
};
var oppositeDirectionMap = {
  n: "s",
  ne: "sw",
  e: "w",
  se: "nw",
  s: "n",
  sw: "ne",
  w: "e",
  nw: "se"
};
var { sign: sign2, abs: abs2, min: min22 } = Math;
function getRectExtentPoint(rect, direction) {
  const { minX, minY, maxX, maxY, midX, midY } = rect;
  const x2 = direction.includes("w") ? minX : direction.includes("e") ? maxX : midX;
  const y = direction.includes("n") ? minY : direction.includes("s") ? maxY : midY;
  return { x: x2, y };
}
function getOppositeDirection(direction) {
  return oppositeDirectionMap[direction];
}
function resizeRect(rect, offset2, direction, opts) {
  const { scalingOriginMode, lockAspectRatio } = opts;
  const extent = getRectExtentPoint(rect, direction);
  const oppositeDirection = getOppositeDirection(direction);
  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);
  if (scalingOriginMode === "center") {
    offset2 = { x: offset2.x * 2, y: offset2.y * 2 };
  }
  const newExtent = {
    x: extent.x + offset2.x,
    y: extent.y + offset2.y
  };
  const multiplier = {
    x: compassDirectionMap[direction].x * 2 - 1,
    y: compassDirectionMap[direction].y * 2 - 1
  };
  const newSize = {
    width: newExtent.x - oppositeExtent.x,
    height: newExtent.y - oppositeExtent.y
  };
  const scaleX = multiplier.x * newSize.width / rect.width;
  const scaleY = multiplier.y * newSize.height / rect.height;
  const largestMagnitude = abs2(scaleX) > abs2(scaleY) ? scaleX : scaleY;
  const scale = lockAspectRatio ? { x: largestMagnitude, y: largestMagnitude } : {
    x: extent.x === oppositeExtent.x ? 1 : scaleX,
    y: extent.y === oppositeExtent.y ? 1 : scaleY
  };
  if (extent.y === oppositeExtent.y) {
    scale.y = abs2(scale.y);
  } else if (sign2(scale.y) !== sign2(scaleY)) {
    scale.y *= -1;
  }
  if (extent.x === oppositeExtent.x) {
    scale.x = abs2(scale.x);
  } else if (sign2(scale.x) !== sign2(scaleX)) {
    scale.x *= -1;
  }
  switch (scalingOriginMode) {
    case "extent":
      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);
    case "center":
      return transformRect(
        rect,
        AffineTransform.scale(scale.x, scale.y, {
          x: rect.midX,
          y: rect.midY
        }),
        false
      );
  }
}
function createRectFromPoints(initialPoint, finalPoint, normalized = true) {
  if (normalized) {
    return {
      x: min22(finalPoint.x, initialPoint.x),
      y: min22(finalPoint.y, initialPoint.y),
      width: abs2(finalPoint.x - initialPoint.x),
      height: abs2(finalPoint.y - initialPoint.y)
    };
  }
  return {
    x: initialPoint.x,
    y: initialPoint.y,
    width: finalPoint.x - initialPoint.x,
    height: finalPoint.y - initialPoint.y
  };
}
function transformRect(rect, transform2, normalized = true) {
  const p1 = transform2.applyTo({ x: rect.minX, y: rect.minY });
  const p2 = transform2.applyTo({ x: rect.maxX, y: rect.maxY });
  return createRectFromPoints(p1, p2, normalized);
}

// node_modules/proxy-compare/dist/index.js
var GET_ORIGINAL_SYMBOL = /* @__PURE__ */ Symbol();
var getProto = Object.getPrototypeOf;
var objectsToTrack = /* @__PURE__ */ new WeakMap();
var isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
var getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
var markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};

// node_modules/@zag-js/store/dist/index.mjs
function glob() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function globalRef(key, value) {
  const g = glob();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var refSet = globalRef("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var isReactElement2 = (x2) => typeof x2 === "object" && x2 !== null && "$$typeof" in x2 && "props" in x2;
var isVueElement2 = (x2) => typeof x2 === "object" && x2 !== null && "__v_isVNode" in x2;
var isDOMElement = (x2) => typeof x2 === "object" && x2 !== null && "nodeType" in x2 && typeof x2.nodeName === "string";
var isElement = (x2) => isReactElement2(x2) || isVueElement2(x2) || isDOMElement(x2);
var isObject3 = (x2) => x2 !== null && typeof x2 === "object";
var canProxy = (x2) => isObject3(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !isElement(x2) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer) && !(x2 instanceof Promise) && !(x2 instanceof File) && !(x2 instanceof Blob) && !(x2 instanceof AbortController);
var isDev = () => true;
var proxyStateMap = globalRef("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version) => {
  const cache = snapCache.get(target);
  if (cache?.[0] === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject3(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      entry[1]?.();
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject3(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if (Object.getOwnPropertyDescriptor(target, prop)?.set) ;
      else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy2(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy2(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion());
}

// node_modules/@zag-js/floating-panel/dist/index.mjs
var anatomy9 = createAnatomy("floating-panel").parts(
  "trigger",
  "positioner",
  "content",
  "header",
  "body",
  "title",
  "resizeTrigger",
  "dragTrigger",
  "stageTrigger",
  "closeTrigger",
  "control"
);
var parts9 = anatomy9.build();
var getTriggerId6 = (ctx) => ctx.ids?.trigger ?? `float:${ctx.id}:trigger`;
var getPositionerId4 = (ctx) => ctx.ids?.positioner ?? `float:${ctx.id}:positioner`;
var getContentId5 = (ctx) => ctx.ids?.content ?? `float:${ctx.id}:content`;
var getTitleId2 = (ctx) => ctx.ids?.title ?? `float:${ctx.id}:title`;
var getHeaderId = (ctx) => ctx.ids?.header ?? `float:${ctx.id}:header`;
var getTriggerEl4 = (ctx) => ctx.getById(getTriggerId6(ctx));
var getPositionerEl4 = (ctx) => ctx.getById(getPositionerId4(ctx));
var getContentEl5 = (ctx) => ctx.getById(getContentId5(ctx));
var getHeaderEl = (ctx) => ctx.getById(getHeaderId(ctx));
var getBoundaryRect = (ctx, boundaryEl, allowOverflow) => {
  let boundaryRect;
  if (isHTMLElement(boundaryEl)) {
    boundaryRect = getElementRect(boundaryEl);
  } else {
    boundaryRect = getWindowRect(ctx.getWin());
  }
  if (allowOverflow) {
    boundaryRect = createRect({
      x: -boundaryRect.width,
      // empty(left)
      y: boundaryRect.minY,
      width: boundaryRect.width * 3,
      // empty(left) + win + empty(right)
      height: boundaryRect.height * 2
      // win + empty(bottom)
    });
  }
  return pick(boundaryRect, ["x", "y", "width", "height"]);
};
function getResizeAxisStyle(axis) {
  switch (axis) {
    case "n":
      return {
        cursor: "n-resize",
        width: "100%",
        top: 0,
        left: "50%",
        translate: "-50%"
      };
    case "e":
      return {
        cursor: "e-resize",
        height: "100%",
        right: 0,
        top: "50%",
        translate: "0 -50%"
      };
    case "s":
      return {
        cursor: "s-resize",
        width: "100%",
        bottom: 0,
        left: "50%",
        translate: "-50%"
      };
    case "w":
      return {
        cursor: "w-resize",
        height: "100%",
        left: 0,
        top: "50%",
        translate: "0 -50%"
      };
    case "se":
      return {
        cursor: "se-resize",
        bottom: 0,
        right: 0
      };
    case "sw":
      return {
        cursor: "sw-resize",
        bottom: 0,
        left: 0
      };
    case "ne":
      return {
        cursor: "ne-resize",
        top: 0,
        right: 0
      };
    case "nw":
      return {
        cursor: "nw-resize",
        top: 0,
        left: 0
      };
    default:
      throw new Error(`Invalid axis: ${axis}`);
  }
}
var validStages = /* @__PURE__ */ new Set(["minimized", "maximized", "default"]);
function connect9(service, normalize2) {
  const { state: state3, send, scope, prop, computed, context } = service;
  const open = state3.hasTag("open");
  const dragging = state3.matches("open.dragging");
  const resizing = state3.matches("open.resizing");
  const isTopmost = context.get("isTopmost");
  const size2 = context.get("size");
  const position = context.get("position");
  const isMaximized = computed("isMaximized");
  const isMinimized = computed("isMinimized");
  const isStaged = computed("isStaged");
  const canResize = computed("canResize");
  const canDrag = computed("canDrag");
  return {
    open,
    resizable: prop("resizable"),
    draggable: prop("draggable"),
    setOpen(nextOpen) {
      const open2 = state3.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    dragging,
    resizing,
    position,
    size: size2,
    setPosition(position2) {
      send({ type: "SET_POSITION", position: position2 });
    },
    setSize(size22) {
      send({ type: "SET_SIZE", size: size22 });
    },
    minimize() {
      send({ type: "MINIMIZE" });
    },
    maximize() {
      send({ type: "MAXIMIZE" });
    },
    restore() {
      send({ type: "RESTORE" });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts9.trigger.attrs,
        dir: prop("dir"),
        type: "button",
        disabled: prop("disabled"),
        id: getTriggerId6(scope),
        "data-state": open ? "open" : "closed",
        "data-dragging": dataAttr(dragging),
        "aria-controls": getContentId5(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (prop("disabled")) return;
          const open2 = state3.hasTag("open");
          send({ type: open2 ? "CLOSE" : "OPEN", src: "trigger" });
        }
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts9.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId4(scope),
        style: {
          "--width": toPx(size2?.width),
          "--height": toPx(size2?.height),
          "--x": toPx(position?.x),
          "--y": toPx(position?.y),
          position: prop("strategy"),
          top: "var(--y)",
          left: "var(--x)"
        }
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts9.content.attrs,
        dir: prop("dir"),
        role: "dialog",
        tabIndex: 0,
        hidden: !open,
        id: getContentId5(scope),
        "aria-labelledby": getTitleId2(scope),
        "data-state": open ? "open" : "closed",
        "data-dragging": dataAttr(dragging),
        "data-topmost": dataAttr(isTopmost),
        "data-behind": dataAttr(!isTopmost),
        "data-minimized": dataAttr(isMinimized),
        "data-maximized": dataAttr(isMaximized),
        "data-staged": dataAttr(isStaged),
        style: {
          width: "var(--width)",
          height: "var(--height)",
          overflow: isMinimized ? "hidden" : void 0
        },
        onFocus() {
          send({ type: "CONTENT_FOCUS" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.currentTarget !== getEventTarget(event)) return;
          const step = getEventStep(event) * prop("gridSize");
          const keyMap2 = {
            Escape() {
              if (!isTopmost) return;
              send({ type: "ESCAPE" });
            },
            ArrowLeft() {
              send({ type: "MOVE", direction: "left", step });
            },
            ArrowRight() {
              send({ type: "MOVE", direction: "right", step });
            },
            ArrowUp() {
              send({ type: "MOVE", direction: "up", step });
            },
            ArrowDown() {
              send({ type: "MOVE", direction: "down", step });
            }
          };
          const handler = keyMap2[getEventKey(event, { dir: prop("dir") })];
          if (handler) {
            event.preventDefault();
            handler(event);
          }
        }
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts9.closeTrigger.attrs,
        dir: prop("dir"),
        disabled: prop("disabled"),
        "aria-label": "Close Window",
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "CLOSE" });
        }
      });
    },
    getStageTriggerProps(props25) {
      if (!validStages.has(props25.stage)) {
        throw new Error(`[zag-js] Invalid stage: ${props25.stage}. Must be one of: ${Array.from(validStages).join(", ")}`);
      }
      const translations = prop("translations");
      const actionProps = match(props25.stage, {
        minimized: () => ({
          "aria-label": translations.minimize,
          hidden: isStaged
        }),
        maximized: () => ({
          "aria-label": translations.maximize,
          hidden: isStaged
        }),
        default: () => ({
          "aria-label": translations.restore,
          hidden: !isStaged
        })
      });
      return normalize2.button({
        ...parts9.stageTrigger.attrs,
        dir: prop("dir"),
        disabled: prop("disabled"),
        ...actionProps,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!prop("resizable")) return;
          const type = match(props25.stage, {
            minimized: () => "MINIMIZE",
            maximized: () => "MAXIMIZE",
            default: () => "RESTORE"
          });
          send({ type: type.toUpperCase() });
        }
      });
    },
    getResizeTriggerProps(props25) {
      return normalize2.element({
        ...parts9.resizeTrigger.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(!canResize),
        "data-axis": props25.axis,
        onPointerDown(event) {
          if (!canResize) return;
          if (!isLeftClick(event)) return;
          event.currentTarget.setPointerCapture(event.pointerId);
          event.stopPropagation();
          send({
            type: "RESIZE_START",
            axis: props25.axis,
            position: { x: event.clientX, y: event.clientY }
          });
        },
        onPointerUp(event) {
          if (!canResize) return;
          const node = event.currentTarget;
          if (node.hasPointerCapture(event.pointerId)) {
            node.releasePointerCapture(event.pointerId);
          }
        },
        style: {
          position: "absolute",
          touchAction: "none",
          ...getResizeAxisStyle(props25.axis)
        }
      });
    },
    getDragTriggerProps() {
      return normalize2.element({
        ...parts9.dragTrigger.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(!canDrag),
        onPointerDown(event) {
          if (!canDrag) return;
          if (!isLeftClick(event)) return;
          const target = getEventTarget(event);
          if (target?.closest("button") || target?.closest("[data-no-drag]")) {
            return;
          }
          event.currentTarget.setPointerCapture(event.pointerId);
          event.stopPropagation();
          send({
            type: "DRAG_START",
            pointerId: event.pointerId,
            position: { x: event.clientX, y: event.clientY }
          });
        },
        onPointerUp(event) {
          if (!canDrag) return;
          const node = event.currentTarget;
          if (node.hasPointerCapture(event.pointerId)) {
            node.releasePointerCapture(event.pointerId);
          }
        },
        onDoubleClick(event) {
          if (event.defaultPrevented) return;
          if (!prop("resizable")) return;
          send({ type: isMaximized ? "RESTORE" : "MAXIMIZE" });
        },
        style: {
          WebkitUserSelect: "none",
          userSelect: "none",
          touchAction: "none",
          cursor: "move"
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts9.control.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(prop("disabled")),
        "data-stage": context.get("stage"),
        "data-minimized": dataAttr(isMinimized),
        "data-maximized": dataAttr(isMaximized),
        "data-staged": dataAttr(isStaged)
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts9.title.attrs,
        dir: prop("dir"),
        id: getTitleId2(scope)
      });
    },
    getHeaderProps() {
      return normalize2.element({
        ...parts9.header.attrs,
        dir: prop("dir"),
        id: getHeaderId(scope),
        "data-dragging": dataAttr(dragging),
        "data-topmost": dataAttr(isTopmost),
        "data-behind": dataAttr(!isTopmost),
        "data-minimized": dataAttr(isMinimized),
        "data-maximized": dataAttr(isMaximized),
        "data-staged": dataAttr(isStaged)
      });
    },
    getBodyProps() {
      return normalize2.element({
        ...parts9.body.attrs,
        dir: prop("dir"),
        "data-dragging": dataAttr(dragging),
        "data-minimized": dataAttr(isMinimized),
        "data-maximized": dataAttr(isMaximized),
        "data-staged": dataAttr(isStaged),
        hidden: isMinimized
      });
    }
  };
}
var panelStack = proxy2({
  stack: [],
  count() {
    return this.stack.length;
  },
  add(panelId) {
    if (this.stack.includes(panelId)) return;
    this.stack.push(panelId);
  },
  remove(panelId) {
    const index = this.stack.indexOf(panelId);
    if (index < 0) return;
    this.stack.splice(index, 1);
  },
  bringToFront(id) {
    this.remove(id);
    this.add(id);
  },
  isTopmost(id) {
    return this.stack[this.stack.length - 1] === id;
  },
  indexOf(id) {
    return this.stack.indexOf(id);
  }
});
var { not: not3, and: and4 } = createGuards();
var defaultTranslations2 = {
  minimize: "Minimize window",
  maximize: "Maximize window",
  restore: "Restore window"
};
var machine9 = createMachine({
  props({ props: props25 }) {
    ensureProps(props25, ["id"], "floating-panel");
    return {
      strategy: "fixed",
      gridSize: 1,
      defaultSize: { width: 320, height: 240 },
      defaultPosition: { x: 300, y: 100 },
      allowOverflow: true,
      resizable: true,
      draggable: true,
      ...props25,
      hasSpecifiedPosition: !!props25.defaultPosition || !!props25.position,
      translations: {
        ...defaultTranslations2,
        ...props25.translations
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ prop, bindable: bindable2 }) {
    return {
      size: bindable2(() => ({
        defaultValue: prop("defaultSize"),
        value: prop("size"),
        isEqual: isSizeEqual,
        sync: true,
        hash(v) {
          return `W:${v.width} H:${v.height}`;
        },
        onChange(value) {
          prop("onSizeChange")?.({ size: value });
        }
      })),
      position: bindable2(() => ({
        defaultValue: prop("defaultPosition"),
        value: prop("position"),
        isEqual: isPointEqual,
        sync: true,
        hash(v) {
          return `X:${v.x} Y:${v.y}`;
        },
        onChange(value) {
          prop("onPositionChange")?.({ position: value });
        }
      })),
      stage: bindable2(() => ({
        defaultValue: "default",
        onChange(value) {
          prop("onStageChange")?.({ stage: value });
        }
      })),
      lastEventPosition: bindable2(() => ({
        defaultValue: null
      })),
      prevPosition: bindable2(() => ({
        defaultValue: null
      })),
      prevSize: bindable2(() => ({
        defaultValue: null
      })),
      isTopmost: bindable2(() => ({
        defaultValue: void 0
      }))
    };
  },
  computed: {
    isMaximized: ({ context }) => context.get("stage") === "maximized",
    isMinimized: ({ context }) => context.get("stage") === "minimized",
    isStaged: ({ context }) => context.get("stage") !== "default",
    canResize: ({ context, prop }) => prop("resizable") && !prop("disabled") && context.get("stage") === "default",
    canDrag: ({ prop, computed }) => prop("draggable") && !prop("disabled") && !computed("isMaximized")
  },
  watch({ track: track2, context, action, prop }) {
    track2([() => context.hash("position")], () => {
      action(["setPositionStyle"]);
    });
    track2([() => context.hash("size")], () => {
      action(["setSizeStyle"]);
    });
    track2([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  effects: ["trackPanelStack"],
  on: {
    CONTENT_FOCUS: {
      actions: ["bringToFrontOfPanelStack"]
    },
    SET_POSITION: {
      actions: ["setPosition"]
    },
    SET_SIZE: {
      actions: ["setSize"]
    }
  },
  states: {
    closed: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["setAnchorPosition", "setPositionStyle", "setSizeStyle", "focusContentEl"]
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setAnchorPosition", "setPositionStyle", "setSizeStyle", "focusContentEl"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      entry: ["bringToFrontOfPanelStack"],
      effects: ["trackBoundaryRect"],
      on: {
        DRAG_START: {
          guard: not3("isMaximized"),
          target: "open.dragging",
          actions: ["setPrevPosition"]
        },
        RESIZE_START: {
          guard: not3("isMinimized"),
          target: "open.resizing",
          actions: ["setPrevSize"]
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["resetRect", "focusTriggerEl"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            target: "closed",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose", "resetRect", "focusTriggerEl"]
          }
        ],
        ESCAPE: [
          {
            guard: and4("isOpenControlled", "closeOnEsc"),
            actions: ["invokeOnClose"]
          },
          {
            guard: "closeOnEsc",
            target: "closed",
            actions: ["invokeOnClose", "resetRect", "focusTriggerEl"]
          }
        ],
        MINIMIZE: {
          actions: ["setMinimized"]
        },
        MAXIMIZE: {
          actions: ["setMaximized"]
        },
        RESTORE: {
          actions: ["setRestored"]
        },
        MOVE: {
          actions: ["setPositionFromKeyboard"]
        }
      }
    },
    "open.dragging": {
      tags: ["open"],
      effects: ["trackPointerMove"],
      exit: ["clearPrevPosition"],
      on: {
        DRAG: {
          actions: ["setPosition"]
        },
        DRAG_END: {
          target: "open",
          actions: ["invokeOnDragEnd"]
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["resetRect"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            target: "closed",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose", "resetRect"]
          }
        ],
        ESCAPE: {
          target: "open"
        }
      }
    },
    "open.resizing": {
      tags: ["open"],
      effects: ["trackPointerMove"],
      exit: ["clearPrevSize"],
      on: {
        DRAG: {
          actions: ["setSize"]
        },
        DRAG_END: {
          target: "open",
          actions: ["invokeOnResizeEnd"]
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["resetRect"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            target: "closed",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose", "resetRect"]
          }
        ],
        ESCAPE: {
          target: "open"
        }
      }
    }
  },
  implementations: {
    guards: {
      closeOnEsc: ({ prop }) => !!prop("closeOnEscape"),
      isMaximized: ({ context }) => context.get("stage") === "maximized",
      isMinimized: ({ context }) => context.get("stage") === "minimized",
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackPointerMove({ scope, send, event: evt, prop }) {
        const doc = scope.getDoc();
        const boundaryEl = prop("getBoundaryEl")?.();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);
        return trackPointerMove(doc, {
          onPointerMove({ point, event }) {
            const { altKey, shiftKey } = event;
            let x2 = clampValue(point.x, boundaryRect.x, boundaryRect.x + boundaryRect.width);
            let y = clampValue(point.y, boundaryRect.y, boundaryRect.y + boundaryRect.height);
            send({ type: "DRAG", position: { x: x2, y }, axis: evt.axis, altKey, shiftKey });
          },
          onPointerUp() {
            send({ type: "DRAG_END" });
          }
        });
      },
      trackBoundaryRect({ context, scope, prop, computed }) {
        const win = scope.getWin();
        let skip = true;
        const exec = () => {
          if (skip) {
            skip = false;
            return;
          }
          const boundaryEl2 = prop("getBoundaryEl")?.();
          let boundaryRect = getBoundaryRect(scope, boundaryEl2, false);
          if (!computed("isMaximized")) {
            const rect = { ...context.get("position"), ...context.get("size") };
            boundaryRect = constrainRect(rect, boundaryRect);
          }
          context.set("size", pick(boundaryRect, ["width", "height"]));
          context.set("position", pick(boundaryRect, ["x", "y"]));
        };
        const boundaryEl = prop("getBoundaryEl")?.();
        if (isHTMLElement(boundaryEl)) {
          return resizeObserverBorderBox.observe(boundaryEl, exec);
        }
        return addDomEvent(win, "resize", exec);
      },
      trackPanelStack({ context, scope }) {
        const unsub = subscribe(panelStack, () => {
          context.set("isTopmost", panelStack.isTopmost(scope.id));
          const contentEl = getContentEl5(scope);
          if (!contentEl) return;
          const index = panelStack.indexOf(scope.id);
          if (index === -1) return;
          contentEl.style.setProperty("--z-index", `${index + 1}`);
        });
        return () => {
          panelStack.remove(scope.id);
          unsub();
        };
      }
    },
    actions: {
      setAnchorPosition({ context, prop, scope }) {
        if (prop("hasSpecifiedPosition")) return;
        const hasPrevRect = context.get("prevPosition") || context.get("prevSize");
        if (prop("persistRect") && hasPrevRect) return;
        raf(() => {
          const triggerRect = getTriggerEl4(scope);
          const boundaryRect = getBoundaryRect(scope, prop("getBoundaryEl")?.(), false);
          let anchorPosition = prop("getAnchorPosition")?.({
            triggerRect: triggerRect ? DOMRect.fromRect(getElementRect(triggerRect)) : null,
            boundaryRect: DOMRect.fromRect(boundaryRect)
          });
          if (!anchorPosition) {
            const size2 = context.get("size");
            anchorPosition = {
              x: boundaryRect.x + (boundaryRect.width - size2.width) / 2,
              y: boundaryRect.y + (boundaryRect.height - size2.height) / 2
            };
          }
          if (!anchorPosition) return;
          context.set("position", anchorPosition);
        });
      },
      setPrevPosition({ context, event }) {
        context.set("prevPosition", { ...context.get("position") });
        context.set("lastEventPosition", event.position);
      },
      clearPrevPosition({ context, prop }) {
        if (!prop("persistRect")) context.set("prevPosition", null);
        context.set("lastEventPosition", null);
      },
      setPosition({ context, event, prop, scope }) {
        let diff3 = subtractPoints(event.position, context.get("lastEventPosition"));
        diff3.x = Math.round(diff3.x / prop("gridSize")) * prop("gridSize");
        diff3.y = Math.round(diff3.y / prop("gridSize")) * prop("gridSize");
        const prevPosition = context.get("prevPosition");
        if (!prevPosition) return;
        let position = addPoints(prevPosition, diff3);
        const boundaryEl = prop("getBoundaryEl")?.();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, prop("allowOverflow"));
        position = clampPoint(position, context.get("size"), boundaryRect);
        context.set("position", position);
      },
      setPositionStyle({ scope, context }) {
        const el = getPositionerEl4(scope);
        const position = context.get("position");
        el?.style.setProperty("--x", `${position.x}px`);
        el?.style.setProperty("--y", `${position.y}px`);
      },
      resetRect({ context, prop }) {
        context.set("stage", "default");
        if (!prop("persistRect")) {
          context.set("position", context.initial("position"));
          context.set("size", context.initial("size"));
        }
      },
      setPrevSize({ context, event }) {
        context.set("prevSize", { ...context.get("size") });
        context.set("prevPosition", { ...context.get("position") });
        context.set("lastEventPosition", event.position);
      },
      clearPrevSize({ context }) {
        context.set("prevSize", null);
        context.set("prevPosition", null);
        context.set("lastEventPosition", null);
      },
      setSize({ context, event, scope, prop }) {
        const prevSize = context.get("prevSize");
        const prevPosition = context.get("prevPosition");
        const lastEventPosition = context.get("lastEventPosition");
        if (!prevSize || !prevPosition || !lastEventPosition) return;
        const prevRect = createRect({ ...prevPosition, ...prevSize });
        const offset2 = subtractPoints(event.position, lastEventPosition);
        const nextRect = resizeRect(prevRect, offset2, event.axis, {
          scalingOriginMode: event.altKey ? "center" : "extent",
          lockAspectRatio: !!prop("lockAspectRatio") || event.shiftKey
        });
        let nextSize = pick(nextRect, ["width", "height"]);
        let nextPosition = pick(nextRect, ["x", "y"]);
        const boundaryEl = prop("getBoundaryEl")?.();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);
        nextSize = clampSize(nextSize, prop("minSize"), prop("maxSize"));
        nextSize = clampSize(nextSize, prop("minSize"), boundaryRect);
        context.set("size", nextSize);
        if (nextPosition) {
          const point = clampPoint(nextPosition, nextSize, boundaryRect);
          context.set("position", point);
        }
      },
      setSizeStyle({ scope, context }) {
        queueMicrotask(() => {
          const el = getPositionerEl4(scope);
          const size2 = context.get("size");
          el?.style.setProperty("--width", `${size2.width}px`);
          el?.style.setProperty("--height", `${size2.height}px`);
        });
      },
      setMaximized({ context, prop, scope }) {
        context.set("stage", "maximized");
        context.set("prevSize", context.get("size"));
        context.set("prevPosition", context.get("position"));
        const boundaryEl = prop("getBoundaryEl")?.();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);
        context.set("position", pick(boundaryRect, ["x", "y"]));
        context.set("size", pick(boundaryRect, ["height", "width"]));
      },
      setMinimized({ context, scope }) {
        context.set("stage", "minimized");
        context.set("prevSize", context.get("size"));
        context.set("prevPosition", context.get("position"));
        const headerEl = getHeaderEl(scope);
        if (!headerEl) return;
        const size2 = {
          ...context.get("size"),
          height: headerEl?.offsetHeight
        };
        context.set("size", size2);
      },
      setRestored({ context, prop, scope }) {
        const boundaryRect = getBoundaryRect(scope, prop("getBoundaryEl")?.(), false);
        context.set("stage", "default");
        const prevSize = context.get("prevSize");
        if (prevSize) {
          let nextSize = prevSize;
          nextSize = clampSize(nextSize, prop("minSize"), prop("maxSize"));
          nextSize = clampSize(nextSize, prop("minSize"), boundaryRect);
          context.set("size", nextSize);
          context.set("prevSize", null);
        }
        if (context.get("prevPosition")) {
          let nextPosition = context.get("prevPosition");
          nextPosition = clampPoint(nextPosition, context.get("size"), boundaryRect);
          context.set("position", nextPosition);
          context.set("prevPosition", null);
        }
      },
      setPositionFromKeyboard({ context, event, prop, scope }) {
        invariant(event.step == null, "step is required");
        const position = context.get("position");
        const step = event.step;
        let nextPosition = match(event.direction, {
          left: { x: position.x - step, y: position.y },
          right: { x: position.x + step, y: position.y },
          up: { x: position.x, y: position.y - step },
          down: { x: position.x, y: position.y + step }
        });
        const boundaryEl = prop("getBoundaryEl")?.();
        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);
        nextPosition = clampPoint(nextPosition, context.get("size"), boundaryRect);
        context.set("position", nextPosition);
      },
      bringToFrontOfPanelStack({ prop }) {
        panelStack.bringToFront(prop("id"));
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      invokeOnDragEnd({ context, prop }) {
        prop("onPositionChangeEnd")?.({ position: context.get("position") });
      },
      invokeOnResizeEnd({ context, prop }) {
        prop("onSizeChangeEnd")?.({ size: context.get("size") });
      },
      focusTriggerEl({ scope }) {
        raf(() => {
          getTriggerEl4(scope)?.focus();
        });
      },
      focusContentEl({ scope }) {
        raf(() => {
          getContentEl5(scope)?.focus();
        });
      },
      toggleVisibility({ send, prop, event }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
var props9 = createProps()([
  "allowOverflow",
  "closeOnEscape",
  "defaultOpen",
  "defaultPosition",
  "defaultSize",
  "dir",
  "disabled",
  "draggable",
  "getAnchorPosition",
  "getBoundaryEl",
  "getRootNode",
  "gridSize",
  "id",
  "ids",
  "lockAspectRatio",
  "maxSize",
  "minSize",
  "onOpenChange",
  "onPositionChange",
  "onPositionChangeEnd",
  "onSizeChange",
  "onSizeChangeEnd",
  "onStageChange",
  "open",
  "persistRect",
  "position",
  "resizable",
  "size",
  "strategy",
  "translations"
]);
var splitProps10 = createSplitProps(props9);
var resizeTriggerProps = createProps()(["axis"]);
var splitResizeTriggerProps = createSplitProps(resizeTriggerProps);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/resize-trigger.svelte
Resize_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/resize-trigger.svelte";
var root_289 = add_locations(from_html(`<div><!></div>`), Resize_trigger[FILENAME], [[28, 1]]);
function Resize_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Resize_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const $$d = user_derived(() => splitResizeTriggerProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), resizeTriggerProps2 = tag(user_derived(() => get($$array)[0]), "resizeTriggerProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getResizeTriggerProps(get(resizeTriggerProps2)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Resize_trigger, 26, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_289();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Resize_trigger, 29, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Resize_trigger,
      25,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Resize_trigger = hmr(Resize_trigger);
  import.meta.hot.accept((module) => {
    Resize_trigger[HMR].update(module.default);
  });
}
var resize_trigger_default = Resize_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/root-context.svelte
Root_context9[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/root-context.svelte";
function Root_context9($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context9);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => floatingPanel), "render", Root_context9, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context9 = hmr(Root_context9);
  import.meta.hot.accept((module) => {
    Root_context9[HMR].update(module.default);
  });
}
var root_context_default9 = Root_context9;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/root-provider.svelte
Root_provider9[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/root-provider.svelte";
function Root_provider9($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider9);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const children = tag(user_derived(() => $$props.children), "children"), floatingPanel = tag(user_derived(() => $$props.value), "floatingPanel");
  RootContext9.provide(() => get(floatingPanel)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root_provider9, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider9 = hmr(Root_provider9);
  import.meta.hot.accept((module) => {
    Root_provider9[HMR].update(module.default);
  });
}
var root_provider_default9 = Root_provider9;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/modules/provider.svelte.js
function useFloatingPanel(props25) {
  const service = useMachine(machine9, props25);
  const floatingPanel = tag(user_derived(() => connect9(service, normalizeProps)), "floatingPanel");
  return () => get(floatingPanel);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/root.svelte
Root10[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/root.svelte";
function Root10($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root10);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps10(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), floatingPanelProps = tag(user_derived(() => get($$array)[0]), "floatingPanelProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const children = tag(user_derived(() => get(componentProps).children), "children");
  const floatingPanel = useFloatingPanel(() => ({ ...get(floatingPanelProps), id }));
  RootContext9.provide(() => floatingPanel());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root10, 27, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root10 = hmr(Root10);
  import.meta.hot.accept((module) => {
    Root10[HMR].update(module.default);
  });
}
var root_default10 = Root10;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/stage-trigger.svelte
Stage_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/stage-trigger.svelte";
var root_290 = add_locations(from_html(`<button><!></button>`), Stage_trigger[FILENAME], [[25, 1]]);
function Stage_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Stage_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), stage = tag(user_derived(() => $$props.stage), "stage"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "stage"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getStageTriggerProps({ stage: get(stage) }), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Stage_trigger, 23, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_290();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Stage_trigger, 26, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Stage_trigger,
      22,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Stage_trigger = hmr(Stage_trigger);
  import.meta.hot.accept((module) => {
    Stage_trigger[HMR].update(module.default);
  });
}
var stage_trigger_default = Stage_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/title.svelte
Title2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/title.svelte";
var root_291 = add_locations(from_html(`<div><!></div>`), Title2[FILENAME], [[24, 1]]);
function Title2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Title2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getTitleProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Title2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_291();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Title2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Title2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Title2 = hmr(Title2);
  import.meta.hot.accept((module) => {
    Title2[HMR].update(module.default);
  });
}
var title_default2 = Title2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/trigger.svelte
Trigger6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/anatomy/trigger.svelte";
var root_292 = add_locations(from_html(`<button><!></button>`), Trigger6[FILENAME], [[24, 1]]);
function Trigger6($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const floatingPanel = RootContext9.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(floatingPanel().getTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger6, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_292();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger6, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger6,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger6 = hmr(Trigger6);
  import.meta.hot.accept((module) => {
    Trigger6[HMR].update(module.default);
  });
}
var trigger_default6 = Trigger6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/floating-panel/modules/anatomy.js
var FloatingPanel = Object.assign(root_default10, {
  Provider: root_provider_default9,
  Context: root_context_default9,
  Trigger: trigger_default6,
  Positioner: positioner_default4,
  Content: content_default5,
  DragTrigger: drag_trigger_default,
  Header: header_default,
  Title: title_default2,
  Control: control_default4,
  StageTrigger: stage_trigger_default,
  CloseTrigger: close_trigger_default2,
  Body: body_default,
  ResizeTrigger: resize_trigger_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/modules/root-context.js
var RootContext10 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/content.svelte
Content6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/content.svelte";
var root_293 = add_locations(from_html(`<ul><!></ul>`), Content6[FILENAME], [[24, 1]]);
function Content6($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const listbox = RootContext10.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(listbox().getContentProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content6, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var ul = root_293();
      attribute_effect(ul, () => ({ ...get(attributes) }));
      var node_2 = child(ul);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content6, 25, 2);
      reset(ul);
      append($$anchor2, ul);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content6,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content6 = hmr(Content6);
  import.meta.hot.accept((module) => {
    Content6[HMR].update(module.default);
  });
}
var content_default6 = Content6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/input.svelte
Input3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/input.svelte";
var root_294 = add_locations(from_html(`<input/>`), Input3[FILENAME], [[24, 1]]);
function Input3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Input3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const listbox = RootContext10.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(listbox().getInputProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Input3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_294();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Input3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Input3 = hmr(Input3);
  import.meta.hot.accept((module) => {
    Input3[HMR].update(module.default);
  });
}
var input_default3 = Input3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/modules/item-group-context.js
var ItemGroupContext2 = createContext();

// node_modules/@zag-js/focus-visible/dist/index.mjs
function isValidKey(e) {
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e) {
  const target = e ? getEventTarget(e) : null;
  const win = getWindow(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target?.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e) {
  for (let handler of changeHandlers) {
    handler(modality, e);
  }
}
function handleKeyboardEvent(e) {
  hasEventBeforeFocus = true;
  if (isValidKey(e)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e);
  }
}
function handlePointerEvent(e) {
  currentModality = "pointer";
  if (e.type === "mousedown" || e.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e);
  }
}
function handleClickEvent(e) {
  if (isVirtualClick(e)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e) {
  const target = getEventTarget(e);
  if (target === getWindow(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root10) {
  if (typeof window === "undefined" || listenerMap.get(getWindow(root10))) {
    return;
  }
  const win = getWindow(root10);
  const doc = getDocument(root10);
  let focus = win.HTMLElement.prototype.focus;
  function patchedFocus() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  }
  try {
    Object.defineProperty(win.HTMLElement.prototype, "focus", {
      configurable: true,
      value: patchedFocus
    });
  } catch {
  }
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root10);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root10, loadListener) => {
  const win = getWindow(root10);
  const doc = getDocument(root10);
  const listenerData = listenerMap.get(win);
  if (!listenerData) {
    return;
  }
  try {
    Object.defineProperty(win.HTMLElement.prototype, "focus", {
      configurable: true,
      value: listenerData.focus
    });
  } catch {
  }
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function getInteractionModality() {
  return currentModality;
}
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props25 = {}) {
  const { isTextInput, autoFocus, onChange, root: root10 } = props25;
  setupGlobalFocusEvents(root10);
  onChange?.({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
    onChange?.({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}

// node_modules/@zag-js/listbox/dist/index.mjs
var anatomy10 = createAnatomy("listbox").parts(
  "label",
  "input",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "content",
  "root",
  "valueText"
);
var parts10 = anatomy10.build();
var collection2 = (options) => {
  return new ListCollection(options);
};
collection2.empty = () => {
  return new ListCollection({ items: [] });
};
var gridCollection = (options) => {
  return new GridCollection(options);
};
gridCollection.empty = () => {
  return new GridCollection({ items: [], columnCount: 0 });
};
var getRootId8 = (ctx) => ctx.ids?.root ?? `select:${ctx.id}`;
var getContentId6 = (ctx) => ctx.ids?.content ?? `select:${ctx.id}:content`;
var getLabelId4 = (ctx) => ctx.ids?.label ?? `select:${ctx.id}:label`;
var getItemId5 = (ctx, id) => ctx.ids?.item?.(id) ?? `select:${ctx.id}:option:${id}`;
var getItemGroupId3 = (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `select:${ctx.id}:optgroup:${id}`;
var getItemGroupLabelId2 = (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `select:${ctx.id}:optgroup-label:${id}`;
var getContentEl6 = (ctx) => ctx.getById(getContentId6(ctx));
var getItemEl2 = (ctx, id) => ctx.getById(getItemId5(ctx, id));
function connect10(service, normalize2) {
  const { context, prop, scope, computed, send, refs } = service;
  const disabled = prop("disabled");
  const collection22 = prop("collection");
  const layout = isGridCollection(collection22) ? "grid" : "list";
  const focused = context.get("focused");
  const focusVisible = refs.get("focusVisible") && focused;
  const inputState = refs.get("inputState");
  const value = context.get("value");
  const selectedItems = context.get("selectedItems");
  const highlightedValue = context.get("highlightedValue");
  const highlightedItem = context.get("highlightedItem");
  const isTypingAhead = computed("isTypingAhead");
  const interactive = computed("isInteractive");
  const ariaActiveDescendant = highlightedValue ? getItemId5(scope, highlightedValue) : void 0;
  function getItemState(props25) {
    const itemDisabled = collection22.getItemDisabled(props25.item);
    const value2 = collection22.getItemValue(props25.item);
    ensure(value2, () => `[zag-js] No value found for item ${JSON.stringify(props25.item)}`);
    const highlighted = highlightedValue === value2;
    return {
      value: value2,
      disabled: Boolean(disabled || itemDisabled),
      focused: highlighted && focused,
      focusVisible: highlighted && focusVisible,
      // deprecated
      highlighted: highlighted && (inputState.focused ? focused : focusVisible),
      selected: context.get("value").includes(value2)
    };
  }
  return {
    empty: value.length === 0,
    highlightedItem,
    highlightedValue,
    clearHighlightedValue() {
      send({ type: "HIGHLIGHTED_VALUE.SET", value: null });
    },
    selectedItems,
    hasSelectedItems: computed("hasSelectedItems"),
    value,
    valueAsString: computed("valueAsString"),
    collection: collection22,
    disabled: !!disabled,
    selectValue(value2) {
      send({ type: "ITEM.SELECT", value: value2 });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    selectAll() {
      if (!computed("multiple")) {
        throw new Error("[zag-js] Cannot select all items in a single-select listbox");
      }
      send({ type: "VALUE.SET", value: collection22.getValues() });
    },
    highlightValue(value2) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value: value2 });
    },
    clearValue(value2) {
      if (value2) {
        send({ type: "ITEM.CLEAR", value: value2 });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts10.root.attrs,
        dir: prop("dir"),
        id: getRootId8(scope),
        "data-orientation": prop("orientation"),
        "data-disabled": dataAttr(disabled)
      });
    },
    getInputProps(props25 = {}) {
      return normalize2.input({
        ...parts10.input.attrs,
        dir: prop("dir"),
        disabled,
        "data-disabled": dataAttr(disabled),
        autoComplete: "off",
        autoCorrect: "off",
        "aria-haspopup": "listbox",
        "aria-controls": getContentId6(scope),
        "aria-autocomplete": "list",
        "aria-activedescendant": ariaActiveDescendant,
        spellCheck: false,
        enterKeyHint: "go",
        onFocus() {
          queueMicrotask(() => {
            send({ type: "INPUT.FOCUS", autoHighlight: !!props25?.autoHighlight });
          });
        },
        onBlur() {
          send({ type: "CONTENT.BLUR", src: "input" });
        },
        onInput(event) {
          if (!props25?.autoHighlight) return;
          if (event.currentTarget.value.trim()) return;
          queueMicrotask(() => {
            send({ type: "HIGHLIGHTED_VALUE.SET", value: null });
          });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const nativeEvent = getNativeEvent(event);
          const forwardEvent = () => {
            event.preventDefault();
            const win = scope.getWin();
            const keyboardEvent = new win.KeyboardEvent(nativeEvent.type, nativeEvent);
            getContentEl6(scope)?.dispatchEvent(keyboardEvent);
          };
          switch (nativeEvent.key) {
            case "ArrowLeft":
            case "ArrowRight": {
              if (!isGridCollection(collection22)) return;
              if (event.ctrlKey) return;
              forwardEvent();
            }
            case "Home":
            case "End": {
              if (highlightedValue == null && event.shiftKey) return;
              forwardEvent();
            }
            case "ArrowDown":
            case "ArrowUp": {
              forwardEvent();
              break;
            }
            case "Enter":
              if (highlightedValue != null) {
                event.preventDefault();
                send({ type: "ITEM.CLICK", value: highlightedValue });
              }
              break;
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        dir: prop("dir"),
        id: getLabelId4(scope),
        ...parts10.label.attrs,
        "data-disabled": dataAttr(disabled)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts10.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        id: getItemId5(scope, itemState.value),
        role: "option",
        ...parts10.item.attrs,
        dir: prop("dir"),
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-selected": dataAttr(itemState.selected),
        "data-layout": layout,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-orientation": prop("orientation"),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-disabled": dataAttr(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (!props25.highlightOnHover) return;
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.highlighted) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onMouseDown(event) {
          event.preventDefault();
          getContentEl6(scope)?.focus();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({
            type: "ITEM.CLICK",
            value: itemState.value,
            shiftKey: event.shiftKey,
            anchorValue: highlightedValue,
            metaKey: isCtrlOrMetaKey(event)
          });
        }
      });
    },
    getItemTextProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts10.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts10.itemIndicator.attrs,
        "aria-hidden": true,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props25) {
      const { htmlFor } = props25;
      return normalize2.element({
        ...parts10.itemGroupLabel.attrs,
        id: getItemGroupLabelId2(scope, htmlFor),
        dir: prop("dir"),
        role: "presentation"
      });
    },
    getItemGroupProps(props25) {
      const { id } = props25;
      return normalize2.element({
        ...parts10.itemGroup.attrs,
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-empty": dataAttr(collection22.size === 0),
        id: getItemGroupId3(scope, id),
        "aria-labelledby": getItemGroupLabelId2(scope, id),
        role: "group",
        dir: prop("dir")
      });
    },
    getContentProps() {
      return normalize2.element({
        dir: prop("dir"),
        id: getContentId6(scope),
        role: "listbox",
        ...parts10.content.attrs,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": ariaActiveDescendant,
        "data-orientation": prop("orientation"),
        "aria-multiselectable": computed("multiple") ? true : void 0,
        "aria-labelledby": getLabelId4(scope),
        tabIndex: 0,
        "data-layout": layout,
        "data-empty": dataAttr(collection22.size === 0),
        style: {
          "--column-count": isGridCollection(collection22) ? collection22.columnCount : 1
        },
        onFocus() {
          send({ type: "CONTENT.FOCUS" });
        },
        onBlur() {
          send({ type: "CONTENT.BLUR" });
        },
        onKeyDown(event) {
          if (!interactive) return;
          if (!contains(event.currentTarget, getEventTarget(event))) return;
          const shiftKey = event.shiftKey;
          const keyMap2 = {
            ArrowUp(event2) {
              let nextValue = null;
              if (isGridCollection(collection22) && highlightedValue) {
                nextValue = collection22.getPreviousRowValue(highlightedValue);
              } else if (highlightedValue) {
                nextValue = collection22.getPreviousValue(highlightedValue);
              }
              if (!nextValue && (prop("loopFocus") || !highlightedValue)) {
                nextValue = collection22.lastValue;
              }
              if (!nextValue) return;
              event2.preventDefault();
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            ArrowDown(event2) {
              let nextValue = null;
              if (isGridCollection(collection22) && highlightedValue) {
                nextValue = collection22.getNextRowValue(highlightedValue);
              } else if (highlightedValue) {
                nextValue = collection22.getNextValue(highlightedValue);
              }
              if (!nextValue && (prop("loopFocus") || !highlightedValue)) {
                nextValue = collection22.firstValue;
              }
              if (!nextValue) return;
              event2.preventDefault();
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            ArrowLeft() {
              if (!isGridCollection(collection22) && prop("orientation") === "vertical") return;
              let nextValue = highlightedValue ? collection22.getPreviousValue(highlightedValue) : null;
              if (!nextValue && prop("loopFocus")) {
                nextValue = collection22.lastValue;
              }
              if (!nextValue) return;
              event.preventDefault();
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            ArrowRight() {
              if (!isGridCollection(collection22) && prop("orientation") === "vertical") return;
              let nextValue = highlightedValue ? collection22.getNextValue(highlightedValue) : null;
              if (!nextValue && prop("loopFocus")) {
                nextValue = collection22.firstValue;
              }
              if (!nextValue) return;
              event.preventDefault();
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            Home(event2) {
              event2.preventDefault();
              let nextValue = collection22.firstValue;
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            End(event2) {
              event2.preventDefault();
              let nextValue = collection22.lastValue;
              send({ type: "NAVIGATE", value: nextValue, shiftKey, anchorValue: highlightedValue });
            },
            Enter() {
              send({ type: "ITEM.CLICK", value: highlightedValue });
            },
            a(event2) {
              if (isCtrlOrMetaKey(event2) && computed("multiple") && !prop("disallowSelectAll")) {
                event2.preventDefault();
                send({ type: "VALUE.SET", value: collection22.getValues() });
              }
            },
            Space(event2) {
              if (isTypingAhead && prop("typeahead")) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                keyMap2.Enter?.(event2);
              }
            },
            Escape(event2) {
              if (prop("deselectable") && value.length > 0) {
                event2.preventDefault();
                event2.stopPropagation();
                send({ type: "VALUE.CLEAR" });
              }
            }
          };
          const exec = keyMap2[getEventKey(event)];
          if (exec) {
            exec(event);
            return;
          }
          const target = getEventTarget(event);
          if (isEditableElement(target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event) && prop("typeahead")) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    }
  };
}
var { guards: guards2, createMachine: createMachine3 } = setup();
var { or } = guards2;
var machine10 = createMachine3({
  props({ props: props25 }) {
    return {
      loopFocus: false,
      composite: true,
      defaultValue: [],
      multiple: false,
      typeahead: true,
      collection: collection2.empty(),
      orientation: "vertical",
      selectionMode: "single",
      ...props25
    };
  },
  context({ prop, bindable: bindable2 }) {
    return {
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        onChange(value) {
          const items = prop("collection").findMany(value);
          return prop("onValueChange")?.({ value, items });
        }
      })),
      highlightedValue: bindable2(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        sync: true,
        onChange(value) {
          prop("onHighlightChange")?.({
            highlightedValue: value,
            highlightedItem: prop("collection").find(value),
            highlightedIndex: prop("collection").indexOf(value)
          });
        }
      })),
      highlightedItem: bindable2(() => ({
        defaultValue: null
      })),
      selectedItems: bindable2(() => {
        const value = prop("value") ?? prop("defaultValue") ?? [];
        const items = prop("collection").findMany(value);
        return { defaultValue: items };
      }),
      focused: bindable2(() => ({
        sync: true,
        defaultValue: false
      }))
    };
  },
  refs() {
    return {
      typeahead: { ...getByTypeahead.defaultOptions },
      focusVisible: false,
      inputState: { autoHighlight: false, focused: false }
    };
  },
  computed: {
    hasSelectedItems: ({ context }) => context.get("value").length > 0,
    isTypingAhead: ({ refs }) => refs.get("typeahead").keysSoFar !== "",
    isInteractive: ({ prop }) => !prop("disabled"),
    selection: ({ context, prop }) => {
      const selection = new Selection(context.get("value"));
      selection.selectionMode = prop("selectionMode");
      selection.deselectable = !!prop("deselectable");
      return selection;
    },
    multiple: ({ prop }) => prop("selectionMode") === "multiple" || prop("selectionMode") === "extended",
    valueAsString: ({ context, prop }) => prop("collection").stringifyItems(context.get("selectedItems"))
  },
  initialState() {
    return "idle";
  },
  watch({ context, prop, track: track2, action }) {
    track2([() => context.get("value").toString()], () => {
      action(["syncSelectedItems"]);
    });
    track2([() => context.get("highlightedValue")], () => {
      action(["syncHighlightedItem"]);
    });
    track2([() => prop("collection").toString()], () => {
      action(["syncHighlightedValue"]);
    });
  },
  effects: ["trackFocusVisible"],
  on: {
    "HIGHLIGHTED_VALUE.SET": {
      actions: ["setHighlightedItem"]
    },
    "ITEM.SELECT": {
      actions: ["selectItem"]
    },
    "ITEM.CLEAR": {
      actions: ["clearItem"]
    },
    "VALUE.SET": {
      actions: ["setSelectedItems"]
    },
    "VALUE.CLEAR": {
      actions: ["clearSelectedItems"]
    }
  },
  states: {
    idle: {
      effects: ["scrollToHighlightedItem"],
      on: {
        "INPUT.FOCUS": {
          actions: ["setFocused", "setInputState"]
        },
        "CONTENT.FOCUS": [
          {
            guard: or("hasSelectedValue", "hasHighlightedValue"),
            actions: ["setFocused"]
          },
          {
            actions: ["setFocused", "setDefaultHighlightedValue"]
          }
        ],
        "CONTENT.BLUR": {
          actions: ["clearFocused", "clearInputState"]
        },
        "ITEM.CLICK": {
          actions: ["setHighlightedItem", "selectHighlightedItem"]
        },
        "CONTENT.TYPEAHEAD": {
          actions: ["setFocused", "highlightMatchingItem"]
        },
        "ITEM.POINTER_MOVE": {
          actions: ["highlightItem"]
        },
        "ITEM.POINTER_LEAVE": {
          actions: ["clearHighlightedItem"]
        },
        NAVIGATE: {
          actions: ["setFocused", "setHighlightedItem", "selectWithKeyboard"]
        }
      }
    }
  },
  implementations: {
    guards: {
      hasSelectedValue: ({ context }) => context.get("value").length > 0,
      hasHighlightedValue: ({ context }) => context.get("highlightedValue") != null
    },
    effects: {
      trackFocusVisible: ({ scope, refs }) => {
        return trackFocusVisible({
          root: scope.getRootNode?.(),
          onChange(details) {
            refs.set("focusVisible", details.isFocusVisible);
          }
        });
      },
      scrollToHighlightedItem({ context, prop, scope }) {
        const exec = (immediate) => {
          const highlightedValue = context.get("highlightedValue");
          if (highlightedValue == null) return;
          const modality = getInteractionModality();
          if (modality !== "keyboard") return;
          const contentEl2 = getContentEl6(scope);
          const scrollToIndexFn = prop("scrollToIndexFn");
          if (scrollToIndexFn) {
            const highlightedIndex = prop("collection").indexOf(highlightedValue);
            scrollToIndexFn?.({
              index: highlightedIndex,
              immediate,
              getElement() {
                return getItemEl2(scope, highlightedValue);
              }
            });
            return;
          }
          const itemEl = getItemEl2(scope, highlightedValue);
          scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
        };
        raf(() => exec(true));
        const contentEl = () => getContentEl6(scope);
        return observeAttributes(contentEl, {
          defer: true,
          attributes: ["data-activedescendant"],
          callback() {
            exec(false);
          }
        });
      }
    },
    actions: {
      selectHighlightedItem({ context, prop, event, computed }) {
        const value = event.value ?? context.get("highlightedValue");
        const collection22 = prop("collection");
        if (value == null || !collection22.has(value)) return;
        const selection = computed("selection");
        if (event.shiftKey && computed("multiple") && event.anchorValue) {
          const next3 = selection.extendSelection(collection22, event.anchorValue, value);
          invokeOnSelect(selection, next3, prop("onSelect"));
          context.set("value", Array.from(next3));
        } else {
          const next3 = selection.select(collection22, value, event.metaKey);
          invokeOnSelect(selection, next3, prop("onSelect"));
          context.set("value", Array.from(next3));
        }
      },
      selectWithKeyboard({ context, prop, event, computed }) {
        const selection = computed("selection");
        const collection22 = prop("collection");
        if (event.shiftKey && computed("multiple") && event.anchorValue) {
          const next3 = selection.extendSelection(collection22, event.anchorValue, event.value);
          invokeOnSelect(selection, next3, prop("onSelect"));
          context.set("value", Array.from(next3));
          return;
        }
        if (prop("selectOnHighlight")) {
          const next3 = selection.replaceSelection(collection22, event.value);
          invokeOnSelect(selection, next3, prop("onSelect"));
          context.set("value", Array.from(next3));
        }
      },
      highlightItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      highlightMatchingItem({ context, prop, event, refs }) {
        const value = prop("collection").search(event.key, {
          state: refs.get("typeahead"),
          currentValue: context.get("highlightedValue")
        });
        if (value == null) return;
        context.set("highlightedValue", value);
      },
      setHighlightedItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      selectItem({ context, prop, event, computed }) {
        const collection22 = prop("collection");
        const selection = computed("selection");
        const next3 = selection.select(collection22, event.value);
        invokeOnSelect(selection, next3, prop("onSelect"));
        context.set("value", Array.from(next3));
      },
      clearItem({ context, event, computed }) {
        const selection = computed("selection");
        const value = selection.deselect(event.value);
        context.set("value", Array.from(value));
      },
      setSelectedItems({ context, event }) {
        context.set("value", event.value);
      },
      clearSelectedItems({ context }) {
        context.set("value", []);
      },
      syncSelectedItems({ context, prop }) {
        const collection22 = prop("collection");
        const prevSelectedItems = context.get("selectedItems");
        const value = context.get("value");
        const selectedItems = value.map((value2) => {
          const item = prevSelectedItems.find((item2) => collection22.getItemValue(item2) === value2);
          return item || collection22.find(value2);
        });
        context.set("selectedItems", selectedItems);
      },
      syncHighlightedItem({ context, prop }) {
        const collection22 = prop("collection");
        const highlightedValue = context.get("highlightedValue");
        const highlightedItem = highlightedValue ? collection22.find(highlightedValue) : null;
        context.set("highlightedItem", highlightedItem);
      },
      syncHighlightedValue({ context, prop, refs }) {
        const collection22 = prop("collection");
        const highlightedValue = context.get("highlightedValue");
        const { autoHighlight } = refs.get("inputState");
        if (autoHighlight) {
          queueMicrotask(() => {
            context.set("highlightedValue", prop("collection").firstValue ?? null);
          });
          return;
        }
        if (highlightedValue != null && !collection22.has(highlightedValue)) {
          queueMicrotask(() => {
            context.set("highlightedValue", null);
          });
        }
      },
      setFocused({ context }) {
        context.set("focused", true);
      },
      setDefaultHighlightedValue({ context, prop }) {
        const collection22 = prop("collection");
        const firstValue = collection22.firstValue;
        if (firstValue != null) {
          context.set("highlightedValue", firstValue);
        }
      },
      clearFocused({ context }) {
        context.set("focused", false);
      },
      setInputState({ refs, event }) {
        refs.set("inputState", { autoHighlight: !!event.autoHighlight, focused: true });
      },
      clearInputState({ refs }) {
        refs.set("inputState", { autoHighlight: false, focused: false });
      }
    }
  }
});
var diff2 = (a, b) => {
  const result = new Set(a);
  for (const item of b) result.delete(item);
  return result;
};
function invokeOnSelect(current, next3, onSelect) {
  const added = diff2(next3, current);
  for (const item of added) {
    onSelect?.({ value: item });
  }
}
var props10 = createProps()([
  "collection",
  "defaultHighlightedValue",
  "defaultValue",
  "dir",
  "disabled",
  "deselectable",
  "disallowSelectAll",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "onHighlightChange",
  "onSelect",
  "onValueChange",
  "orientation",
  "scrollToIndexFn",
  "selectionMode",
  "selectOnHighlight",
  "typeahead",
  "value"
]);
var splitProps11 = createSplitProps(props10);
var itemProps5 = createProps()(["item", "highlightOnHover"]);
var splitItemProps5 = createSplitProps(itemProps5);
var itemGroupProps2 = createProps()(["id"]);
var splitItemGroupProps2 = createSplitProps(itemGroupProps2);
var itemGroupLabelProps2 = createProps()(["htmlFor"]);
var splitItemGroupLabelProps2 = createSplitProps(itemGroupLabelProps2);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item-group-label.svelte
Item_group_label2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item-group-label.svelte";
var root_295 = add_locations(from_html(`<div><!></div>`), Item_group_label2[FILENAME], [[34, 1]]);
function Item_group_label2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_group_label2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const listbox = RootContext10.consume();
  const itemGroupProps4 = ItemGroupContext2.consume();
  const $$d = user_derived(() => splitItemGroupLabelProps2({ htmlFor: itemGroupProps4().id, ...props25 })), $$array = tag(user_derived(() => to_array(get($$d), 1)), "[$derived iterable]"), itemGroupLabelProps4 = tag(user_derived(() => get($$array)[0]), "itemGroupLabelProps");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(listbox().getItemGroupLabelProps(get(itemGroupLabelProps4)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_group_label2, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_295();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_group_label2, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_group_label2,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_group_label2 = hmr(Item_group_label2);
  import.meta.hot.accept((module) => {
    Item_group_label2[HMR].update(module.default);
  });
}
var item_group_label_default2 = Item_group_label2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item-group.svelte
Item_group4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item-group.svelte";
var root_296 = add_locations(from_html(`<div><!></div>`), Item_group4[FILENAME], [[36, 1]]);
function Item_group4($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Item_group4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const listbox = RootContext10.consume();
  const $$d = user_derived(() => splitItemGroupProps2({ id, ...props25 })), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemGroupProps4 = tag(user_derived(() => get($$array)[0]), "itemGroupProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(listbox().getItemGroupProps(get(itemGroupProps4)), get(rest))), "attributes");
  ItemGroupContext2.provide(() => get(itemGroupProps4));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_group4, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_296();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_group4, 37, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_group4,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_group4 = hmr(Item_group4);
  import.meta.hot.accept((module) => {
    Item_group4[HMR].update(module.default);
  });
}
var item_group_default4 = Item_group4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/modules/item-context.js
var ItemContext4 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item-indicator.svelte
Item_indicator3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item-indicator.svelte";
var check2 = wrap_snippet(Item_indicator3, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => check_default(node, { class: "size-4" }), "component", Item_indicator3, 25, 1, { componentTag: "Check" });
  append($$anchor, fragment);
});
var root_310 = add_locations(from_html(`<span><!></span>`), Item_indicator3[FILENAME], [[31, 1]]);
function Item_indicator3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_indicator3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const listbox = RootContext10.consume();
  const itemProps13 = ItemContext4.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, check2)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(listbox().getItemIndicatorProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node_1 = first_child(fragment_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_2, () => get(element2), () => get(attributes)), "render", Item_indicator3, 29, 1);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var span = root_310();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_3 = child(span);
      add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Item_indicator3, 32, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_indicator3,
      28,
      0
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_indicator3 = hmr(Item_indicator3);
  import.meta.hot.accept((module) => {
    Item_indicator3[HMR].update(module.default);
  });
}
var item_indicator_default3 = Item_indicator3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item-text.svelte
Item_text2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item-text.svelte";
var root_297 = add_locations(from_html(`<span><!></span>`), Item_text2[FILENAME], [[26, 1]]);
function Item_text2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_text2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const listbox = RootContext10.consume();
  const itemProps13 = ItemContext4.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(listbox().getItemTextProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_text2, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_297();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_text2, 27, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_text2,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_text2 = hmr(Item_text2);
  import.meta.hot.accept((module) => {
    Item_text2[HMR].update(module.default);
  });
}
var item_text_default2 = Item_text2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item.svelte
Item5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/item.svelte";
var root_298 = add_locations(from_html(`<li><!></li>`), Item5[FILENAME], [[30, 1]]);
function Item5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const listbox = RootContext10.consume();
  const $$d = user_derived(() => splitItemProps5(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(listbox().getItemProps(get(itemProps13)), get(rest))), "attributes");
  ItemContext4.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item5, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var li = root_298();
      attribute_effect(li, () => ({ ...get(attributes) }));
      var node_2 = child(li);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item5, 31, 2);
      reset(li);
      append($$anchor2, li);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item5,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item5 = hmr(Item5);
  import.meta.hot.accept((module) => {
    Item5[HMR].update(module.default);
  });
}
var item_default5 = Item5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/label.svelte
Label4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/label.svelte";
var root_299 = add_locations(from_html(`<label><!></label>`), Label4[FILENAME], [[24, 1]]);
function Label4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const listbox = RootContext10.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(listbox().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_299();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label4, 25, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label4 = hmr(Label4);
  import.meta.hot.accept((module) => {
    Label4[HMR].update(module.default);
  });
}
var label_default4 = Label4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/root-context.svelte
Root_context10[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/root-context.svelte";
function Root_context10($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context10);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const listbox = RootContext10.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => listbox), "render", Root_context10, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context10 = hmr(Root_context10);
  import.meta.hot.accept((module) => {
    Root_context10[HMR].update(module.default);
  });
}
var root_context_default10 = Root_context10;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/root-provider.svelte
Root_provider10[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/root-provider.svelte";
var root_2100 = add_locations(from_html(`<div><!></div>`), Root_provider10[FILENAME], [[27, 1]]);
function Root_provider10($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider10);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), listbox = tag(user_derived(() => $$props.value), "listbox"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(listbox)().getRootProps(), get(rest))), "attributes");
  RootContext10.provide(() => get(listbox)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider10, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2100();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider10, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider10,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider10 = hmr(Root_provider10);
  import.meta.hot.accept((module) => {
    Root_provider10[HMR].update(module.default);
  });
}
var root_provider_default10 = Root_provider10;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/modules/provider.svelte.js
function useListbox(props25) {
  const service = useMachine(machine10, props25);
  const listbox = tag(user_derived(() => connect10(service, normalizeProps)), "listbox");
  return () => get(listbox);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/root.svelte
Root11[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/anatomy/root.svelte";
var root_2101 = add_locations(from_html(`<div><!></div>`), Root11[FILENAME], [[33, 1]]);
function Root11($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root11);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps11(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), listboxProps = tag(user_derived(() => get($$array)[0]), "listboxProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const listbox = useListbox(() => ({ ...get(listboxProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(listbox().getRootProps(), get(rest))), "attributes");
  RootContext10.provide(() => listbox());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root11, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2101();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root11, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root11,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root11 = hmr(Root11);
  import.meta.hot.accept((module) => {
    Root11[HMR].update(module.default);
  });
}
var root_default11 = Root11;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/listbox/modules/anatomy.js
var Listbox = Object.assign(root_default11, {
  Provider: root_provider_default10,
  Context: root_context_default10,
  Label: label_default4,
  Input: input_default3,
  Content: content_default6,
  ItemGroup: item_group_default4,
  ItemGroupLabel: item_group_label_default2,
  Item: item_default5,
  ItemText: item_text_default2,
  ItemIndicator: item_indicator_default3
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/modules/root-context.js
var RootContext11 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/arrow-tip.svelte
Arrow_tip[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/arrow-tip.svelte";
var root_2102 = add_locations(from_html(`<div><!></div>`), Arrow_tip[FILENAME], [[24, 1]]);
function Arrow_tip($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow_tip);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getArrowTipProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Arrow_tip, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2102();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Arrow_tip, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Arrow_tip,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Arrow_tip = hmr(Arrow_tip);
  import.meta.hot.accept((module) => {
    Arrow_tip[HMR].update(module.default);
  });
}
var arrow_tip_default = Arrow_tip;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/arrow.svelte
Arrow[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/arrow.svelte";
var root_2103 = add_locations(from_html(`<div><!></div>`), Arrow[FILENAME], [[24, 1]]);
function Arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getArrowProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Arrow, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2103();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Arrow, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Arrow,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Arrow = hmr(Arrow);
  import.meta.hot.accept((module) => {
    Arrow[HMR].update(module.default);
  });
}
var arrow_default = Arrow;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/content.svelte
Content7[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/content.svelte";
var root_2104 = add_locations(from_html(`<div><!></div>`), Content7[FILENAME], [[24, 1]]);
function Content7($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content7);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getContentProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content7, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2104();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content7, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content7,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content7 = hmr(Content7);
  import.meta.hot.accept((module) => {
    Content7[HMR].update(module.default);
  });
}
var content_default7 = Content7;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/context-trigger.svelte
Context_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/context-trigger.svelte";
var root_2105 = add_locations(from_html(`<button><!></button>`), Context_trigger[FILENAME], [[24, 1]]);
function Context_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getContextTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Context_trigger, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2105();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Context_trigger, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Context_trigger,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Context_trigger = hmr(Context_trigger);
  import.meta.hot.accept((module) => {
    Context_trigger[HMR].update(module.default);
  });
}
var context_trigger_default = Context_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/indicator.svelte
Indicator3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/indicator.svelte";
var root_2106 = add_locations(from_html(`<div><!></div>`), Indicator3[FILENAME], [[24, 1]]);
function Indicator3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Indicator3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getIndicatorProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Indicator3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2106();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Indicator3, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Indicator3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Indicator3 = hmr(Indicator3);
  import.meta.hot.accept((module) => {
    Indicator3[HMR].update(module.default);
  });
}
var indicator_default3 = Indicator3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/modules/item-group-context.js
var ItemGroupContext3 = createContext();

// node_modules/@zag-js/menu/dist/index.mjs
var anatomy11 = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts11 = anatomy11.build();
var getTriggerId7 = (ctx) => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`;
var getContextTriggerId = (ctx) => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`;
var getContentId7 = (ctx) => ctx.ids?.content ?? `menu:${ctx.id}:content`;
var getArrowId = (ctx) => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`;
var getPositionerId5 = (ctx) => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`;
var getGroupId = (ctx, id) => ctx.ids?.group?.(id) ?? `menu:${ctx.id}:group:${id}`;
var getItemId6 = (ctx, id) => `${ctx.id}/${id}`;
var getItemValue = (el) => el?.dataset.value ?? null;
var getGroupLabelId = (ctx, id) => ctx.ids?.groupLabel?.(id) ?? `menu:${ctx.id}:group-label:${id}`;
var getContentEl7 = (ctx) => ctx.getById(getContentId7(ctx));
var getPositionerEl5 = (ctx) => ctx.getById(getPositionerId5(ctx));
var getTriggerEl5 = (ctx) => ctx.getById(getTriggerId7(ctx));
var getItemEl3 = (ctx, value) => value ? ctx.getById(getItemId6(ctx, value)) : null;
var getContextTriggerEl = (ctx) => ctx.getById(getContextTriggerId(ctx));
var getElements = (ctx) => {
  const ownerId = CSS.escape(getContentId7(ctx));
  const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
  return queryAll(getContentEl7(ctx), selector);
};
var getFirstEl = (ctx) => first(getElements(ctx));
var getLastEl = (ctx) => last(getElements(ctx));
var isMatch = (el, value) => {
  if (!value) return false;
  return el.id === value || el.dataset.value === value;
};
var getNextEl = (ctx, opts) => {
  const items = getElements(ctx);
  const index = items.findIndex((el) => isMatch(el, opts.value));
  return next2(items, index, { loop: opts.loop ?? opts.loopFocus });
};
var getPrevEl = (ctx, opts) => {
  const items = getElements(ctx);
  const index = items.findIndex((el) => isMatch(el, opts.value));
  return prev(items, index, { loop: opts.loop ?? opts.loopFocus });
};
var getElemByKey = (ctx, opts) => {
  const items = getElements(ctx);
  const item = items.find((el) => isMatch(el, opts.value));
  return getByTypeahead(items, { state: opts.typeaheadState, key: opts.key, activeId: item?.id ?? null });
};
var isTargetDisabled = (v) => {
  return isHTMLElement(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
};
var isTriggerItem = (el) => {
  return !!el?.getAttribute("role")?.startsWith("menuitem") && !!el?.hasAttribute("data-controls");
};
var itemSelectEvent = "menu:select";
function dispatchSelectionEvent(el, value) {
  if (!el) return;
  const win = getWindow(el);
  const event = new win.CustomEvent(itemSelectEvent, { detail: { value } });
  el.dispatchEvent(event);
}
function connect11(service, normalize2) {
  const { context, send, state: state3, computed, prop, scope } = service;
  const open = state3.hasTag("open");
  const isSubmenu = context.get("isSubmenu");
  const isTypingAhead = computed("isTypingAhead");
  const composite = prop("composite");
  const currentPlacement = context.get("currentPlacement");
  const anchorPoint = context.get("anchorPoint");
  const highlightedValue = context.get("highlightedValue");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: anchorPoint ? "bottom" : currentPlacement
  });
  function getItemState(props25) {
    return {
      id: getItemId6(scope, props25.value),
      disabled: !!props25.disabled,
      highlighted: highlightedValue === props25.value
    };
  }
  function getOptionItemProps(props25) {
    const valueText = props25.valueText ?? props25.value;
    return { ...props25, id: props25.value, valueText };
  }
  function getOptionItemState(props25) {
    const itemState = getItemState(getOptionItemProps(props25));
    return {
      ...itemState,
      checked: !!props25.checked
    };
  }
  function getItemProps(props25) {
    const { closeOnSelect, valueText, value } = props25;
    const itemState = getItemState(props25);
    const id = getItemId6(scope, value);
    return normalize2.element({
      ...parts11.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": ariaAttr(itemState.disabled),
      "data-disabled": dataAttr(itemState.disabled),
      "data-ownedby": getContentId7(scope),
      "data-highlighted": dataAttr(itemState.highlighted),
      "data-value": value,
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink) event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const target = event.currentTarget;
        if (itemState.highlighted) return;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerLeave(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const pointerMoved = service.event.previous()?.type.includes("POINTER");
        if (!pointerMoved) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onClick(event) {
        if (isDownloadingEvent(event)) return;
        if (isOpeningInNewTab(event)) return;
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", target, id, closeOnSelect });
      }
    });
  }
  return {
    highlightedValue,
    open,
    setOpen(nextOpen) {
      const open2 = state3.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", value });
    },
    setParent(parent) {
      send({ type: "PARENT.SET", value: parent, id: parent.prop("id") });
    },
    setChild(child2) {
      send({ type: "CHILD.SET", value: child2, id: child2.prop("id") });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    addItemListener(props25) {
      const node = scope.getById(props25.id);
      if (!node) return;
      const listener = () => props25.onSelect?.();
      node.addEventListener(itemSelectEvent, listener);
      return () => node.removeEventListener(itemSelectEvent, listener);
    },
    getContextTriggerProps() {
      return normalize2.element({
        ...parts11.contextTrigger.attrs,
        dir: prop("dir"),
        id: getContextTriggerId(scope),
        "data-state": open ? "open" : "closed",
        onPointerDown(event) {
          if (event.pointerType === "mouse") return;
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onContextMenu(event) {
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          WebkitUserSelect: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      const triggerProps2 = childApi.getTriggerProps();
      return mergeProps(getItemProps({ value: triggerProps2.id }), triggerProps2);
    },
    getTriggerProps() {
      return normalize2.button({
        ...isSubmenu ? parts11.triggerItem.attrs : parts11.trigger.attrs,
        "data-placement": context.get("currentPlacement"),
        type: "button",
        dir: prop("dir"),
        id: getTriggerId7(scope),
        "data-uid": prop("id"),
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": getContentId7(scope),
        "data-controls": getContentId7(scope),
        "aria-expanded": open || void 0,
        "data-state": open ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse") return;
          const disabled = isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu) return;
          const point = getEventPoint(event);
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget, point });
        },
        onPointerLeave(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if (event.pointerType !== "mouse") return;
          if (!isSubmenu) return;
          const point = getEventPoint(event);
          send({
            type: "TRIGGER_POINTERLEAVE",
            target: event.currentTarget,
            point
          });
        },
        onPointerDown(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if (isContextMenuEvent(event)) return;
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (isTargetDisabled(event.currentTarget)) return;
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        },
        onBlur() {
          send({ type: "TRIGGER_BLUR" });
        },
        onFocus() {
          send({ type: "TRIGGER_FOCUS" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = getEventKey(event, {
            orientation: "vertical",
            dir: prop("dir")
          });
          const exec = keyMap2[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts11.indicator.attrs,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts11.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId5(scope),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: getArrowId(scope),
        ...parts11.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts11.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts11.content.attrs,
        id: getContentId7(scope),
        "aria-label": prop("aria-label"),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: prop("dir"),
        "aria-activedescendant": computed("highlightedId") || void 0,
        "aria-labelledby": getTriggerId7(scope),
        "data-placement": currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse") return;
          send({ type: "MENU_POINTERENTER" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!contains(event.currentTarget, getEventTarget(event))) return;
          const target = getEventTarget(event);
          const sameMenu = target?.closest("[role=menu]") === event.currentTarget || target === event.currentTarget;
          if (!sameMenu) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            ArrowLeft() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT" });
            },
            Enter() {
              send({ type: "ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                keyMap2.Enter?.(event2);
              }
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!prop("typeahead")) return;
          if (!isPrintableKey(event)) return;
          if (isModifierKey(event)) return;
          if (isEditableElement(target)) return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize2.element({
        ...parts11.separator.attrs,
        role: "separator",
        dir: prop("dir"),
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props25) {
      const { type, disabled, closeOnSelect } = props25;
      const option = getOptionItemProps(props25);
      const itemState = getOptionItemState(props25);
      return {
        ...getItemProps(option),
        ...normalize2.element({
          "data-type": type,
          ...parts11.item.attrs,
          dir: prop("dir"),
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onClick(event) {
            if (disabled) return;
            if (isDownloadingEvent(event)) return;
            if (isOpeningInNewTab(event)) return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", target, option, closeOnSelect });
          }
        })
      };
    },
    getItemIndicatorProps(props25) {
      const itemState = getOptionItemState(cast(props25));
      const dataState = itemState.checked ? "checked" : "unchecked";
      return normalize2.element({
        ...parts11.itemIndicator.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": hasProp(props25, "checked") ? dataState : void 0,
        hidden: hasProp(props25, "checked") ? !itemState.checked : void 0
      });
    },
    getItemTextProps(props25) {
      const itemState = getOptionItemState(cast(props25));
      const dataState = itemState.checked ? "checked" : "unchecked";
      return normalize2.element({
        ...parts11.itemText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": hasProp(props25, "checked") ? dataState : void 0
      });
    },
    getItemGroupLabelProps(props25) {
      return normalize2.element({
        ...parts11.itemGroupLabel.attrs,
        id: getGroupLabelId(scope, props25.htmlFor),
        dir: prop("dir")
      });
    },
    getItemGroupProps(props25) {
      return normalize2.element({
        id: getGroupId(scope, props25.id),
        ...parts11.itemGroup.attrs,
        dir: prop("dir"),
        "aria-labelledby": getGroupLabelId(scope, props25.id),
        role: "group"
      });
    }
  };
}
var { not: not4, and: and5, or: or2 } = createGuards();
var machine11 = createMachine({
  props({ props: props25 }) {
    return {
      closeOnSelect: true,
      typeahead: true,
      composite: true,
      loopFocus: false,
      navigate(details) {
        clickIfLink(details.node);
      },
      ...props25,
      positioning: {
        placement: "bottom-start",
        gutter: 8,
        ...props25.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  context({ bindable: bindable2, prop }) {
    return {
      suspendPointer: bindable2(() => ({
        defaultValue: false
      })),
      highlightedValue: bindable2(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          prop("onHighlightChange")?.({ highlightedValue: value });
        }
      })),
      lastHighlightedValue: bindable2(() => ({
        defaultValue: null
      })),
      currentPlacement: bindable2(() => ({
        defaultValue: void 0
      })),
      intentPolygon: bindable2(() => ({
        defaultValue: null
      })),
      anchorPoint: bindable2(() => ({
        defaultValue: null,
        hash(value) {
          return `x: ${value?.x}, y: ${value?.y}`;
        }
      })),
      isSubmenu: bindable2(() => ({
        defaultValue: false
      }))
    };
  },
  refs() {
    return {
      parent: null,
      children: {},
      typeaheadState: { ...getByTypeahead.defaultOptions },
      positioningOverride: {}
    };
  },
  computed: {
    isRtl: ({ prop }) => prop("dir") === "rtl",
    isTypingAhead: ({ refs }) => refs.get("typeaheadState").keysSoFar !== "",
    highlightedId: ({ context, scope, refs }) => resolveItemId(refs.get("children"), context.get("highlightedValue"), scope)
  },
  watch({ track: track2, action, context, prop }) {
    track2([() => context.get("isSubmenu")], () => {
      action(["setSubmenuPlacement"]);
    });
    track2([() => context.hash("anchorPoint")], () => {
      if (!context.get("anchorPoint")) return;
      action(["reposition"]);
    });
    track2([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "PARENT.SET": {
      actions: ["setParentMenu"]
    },
    "CHILD.SET": {
      actions: ["setChildMenu"]
    },
    OPEN: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        target: "open",
        actions: ["invokeOnOpen"]
      }
    ],
    OPEN_AUTOFOCUS: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        // internal: true,
        target: "open",
        actions: ["highlightFirstItem", "invokeOnOpen"]
      }
    ],
    CLOSE: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnClose"]
      },
      {
        target: "closed",
        actions: ["invokeOnClose"]
      }
    ],
    "HIGHLIGHTED.RESTORE": {
      actions: ["restoreHighlightedItem"]
    },
    "HIGHLIGHTED.SET": {
      actions: ["setHighlightedItem"]
    }
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_FOCUS: {
          guard: not4("isSubmenu"),
          target: "closed"
        },
        TRIGGER_POINTERMOVE: {
          guard: "isSubmenu",
          target: "opening"
        }
      }
    },
    "opening:contextmenu": {
      tags: ["closed"],
      effects: ["waitForLongPress"],
      on: {
        "CONTROLLED.OPEN": { target: "open" },
        "CONTROLLED.CLOSE": { target: "closed" },
        CONTEXT_MENU_CANCEL: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "LONG_PRESS.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    opening: {
      tags: ["closed"],
      effects: ["waitForOpenDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        BLUR: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TRIGGER_POINTERLEAVE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "DELAY.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    closing: {
      tags: ["open"],
      effects: ["trackPointerMove", "trackInteractOutside", "waitForCloseDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["focusParentMenu", "restoreParentHighlightedItem"]
        },
        // don't invoke on open here since the menu is still open (we're only keeping it open)
        MENU_POINTERENTER: {
          target: "open",
          actions: ["clearIntentPolygon"]
        },
        POINTER_MOVED_AWAY_FROM_SUBMENU: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem"]
          }
        ],
        "DELAY.CLOSE": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem", "invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      tags: ["closed"],
      entry: ["clearHighlightedItem", "focusTrigger", "resumePointer", "clearAnchorPoint"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: or2("isOpenAutoFocusEvent", "isArrowDownEvent"),
            target: "open",
            actions: ["highlightFirstItem"]
          },
          {
            guard: "isArrowUpEvent",
            target: "open",
            actions: ["highlightLastItem"]
          },
          {
            target: "open"
          }
        ],
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          target: "opening"
        },
        TRIGGER_BLUR: { target: "idle" },
        ARROW_DOWN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        ARROW_UP: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightLastItem", "invokeOnOpen"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
      entry: ["focusMenu", "resumePointer"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            target: "closed",
            guard: "isArrowLeftEvent",
            actions: ["focusParentMenu"]
          },
          {
            target: "closed"
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: and5(not4("isTriggerItem"), "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: not4("isTriggerItem"),
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        CONTEXT_MENU: {
          actions: ["setAnchorPoint", "focusMenu"]
        },
        ARROW_UP: {
          actions: ["highlightPrevItem", "focusMenu"]
        },
        ARROW_DOWN: {
          actions: ["highlightNextItem", "focusMenu"]
        },
        ARROW_LEFT: [
          {
            guard: and5("isSubmenu", "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: "isSubmenu",
            target: "closed",
            actions: ["focusParentMenu", "invokeOnClose"]
          }
        ],
        HOME: {
          actions: ["highlightFirstItem", "focusMenu"]
        },
        END: {
          actions: ["highlightLastItem", "focusMenu"]
        },
        ARROW_RIGHT: {
          guard: "isTriggerItemHighlighted",
          actions: ["openSubmenu"]
        },
        ENTER: [
          {
            guard: "isTriggerItemHighlighted",
            actions: ["openSubmenu"]
          },
          {
            actions: ["clickHighlightedItem"]
          }
        ],
        ITEM_POINTERMOVE: [
          {
            guard: not4("isPointerSuspended"),
            actions: ["setHighlightedItem", "focusMenu"]
          },
          {
            actions: ["setLastHighlightedItem"]
          }
        ],
        ITEM_POINTERLEAVE: {
          guard: and5(not4("isPointerSuspended"), not4("isTriggerItem")),
          actions: ["clearHighlightedItem"]
        },
        ITEM_CLICK: [
          // == grouped ==
          {
            guard: and5(
              not4("isTriggerItemHighlighted"),
              not4("isHighlightedItemEditable"),
              "closeOnSelect",
              "isOpenControlled"
            ),
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          {
            guard: and5(not4("isTriggerItemHighlighted"), not4("isHighlightedItemEditable"), "closeOnSelect"),
            target: "closed",
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          //
          {
            guard: and5(not4("isTriggerItemHighlighted"), not4("isHighlightedItemEditable")),
            actions: ["invokeOnSelect", "setOptionState"]
          },
          { actions: ["setHighlightedItem"] }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          actions: ["setIntentPolygon"]
        },
        TRIGGER_POINTERLEAVE: {
          target: "closing"
        },
        ITEM_POINTERDOWN: {
          actions: ["setHighlightedItem"]
        },
        TYPEAHEAD: {
          actions: ["highlightMatchedItem"]
        },
        FOCUS_MENU: {
          actions: ["focusMenu"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      closeOnSelect: ({ prop, event }) => !!(event?.closeOnSelect ?? prop("closeOnSelect")),
      // whether the trigger is also a menu item
      isTriggerItem: ({ event }) => isTriggerItem(event.target),
      // whether the trigger item is the active item
      isTriggerItemHighlighted: ({ event, scope, computed }) => {
        const target = event.target ?? scope.getById(computed("highlightedId"));
        return !!target?.hasAttribute("data-controls");
      },
      isSubmenu: ({ context }) => context.get("isSubmenu"),
      isPointerSuspended: ({ context }) => context.get("suspendPointer"),
      isHighlightedItemEditable: ({ scope, computed }) => isEditableElement(scope.getById(computed("highlightedId"))),
      // guard assertions (for controlled mode)
      isOpenControlled: ({ prop }) => prop("open") !== void 0,
      isArrowLeftEvent: ({ event }) => event.previousEvent?.type === "ARROW_LEFT",
      isArrowUpEvent: ({ event }) => event.previousEvent?.type === "ARROW_UP",
      isArrowDownEvent: ({ event }) => event.previousEvent?.type === "ARROW_DOWN",
      isOpenAutoFocusEvent: ({ event }) => event.previousEvent?.type === "OPEN_AUTOFOCUS"
    },
    effects: {
      waitForOpenDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.OPEN" });
        }, 100);
        return () => clearTimeout(timer);
      },
      waitForCloseDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.CLOSE" });
        }, 300);
        return () => clearTimeout(timer);
      },
      waitForLongPress({ send }) {
        const timer = setTimeout(() => {
          send({ type: "LONG_PRESS.OPEN" });
        }, 700);
        return () => clearTimeout(timer);
      },
      trackPositioning({ context, prop, scope, refs }) {
        if (!!getContextTriggerEl(scope)) return;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        context.set("currentPlacement", positioning.placement);
        const getPositionerEl22 = () => getPositionerEl5(scope);
        return getPlacement(getTriggerEl5(scope), getPositionerEl22, {
          ...positioning,
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackInteractOutside({ refs, scope, prop, context, send }) {
        const getContentEl22 = () => getContentEl7(scope);
        let restoreFocus = true;
        return trackDismissableElement(getContentEl22, {
          type: "menu",
          defer: true,
          exclude: [getTriggerEl5(scope)],
          onInteractOutside: prop("onInteractOutside"),
          onRequestDismiss: prop("onRequestDismiss"),
          onFocusOutside(event) {
            prop("onFocusOutside")?.(event);
            const target = getEventTarget(event.detail.originalEvent);
            const isWithinContextTrigger = contains(getContextTriggerEl(scope), target);
            if (isWithinContextTrigger) {
              event.preventDefault();
              return;
            }
          },
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (context.get("isSubmenu")) event.preventDefault();
            closeRootMenu({ parent: refs.get("parent") });
          },
          onPointerDownOutside(event) {
            prop("onPointerDownOutside")?.(event);
            const target = getEventTarget(event.detail.originalEvent);
            const isWithinContextTrigger = contains(getContextTriggerEl(scope), target);
            if (isWithinContextTrigger && event.detail.contextmenu) {
              event.preventDefault();
              return;
            }
            restoreFocus = !event.detail.focusable;
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      trackPointerMove({ context, scope, send, refs, flush: flush2 }) {
        const parent = refs.get("parent");
        flush2(() => {
          parent.context.set("suspendPointer", true);
        });
        const doc = scope.getDoc();
        return addDomEvent(doc, "pointermove", (e) => {
          const isMovingToSubmenu = isWithinPolygon(context.get("intentPolygon"), {
            x: e.clientX,
            y: e.clientY
          });
          if (!isMovingToSubmenu) {
            send({ type: "POINTER_MOVED_AWAY_FROM_SUBMENU" });
            parent.context.set("suspendPointer", false);
          }
        });
      },
      scrollToHighlightedItem({ event, scope, computed }) {
        const exec = () => {
          if (event.current().type.startsWith("ITEM_POINTER")) return;
          const itemEl = scope.getById(computed("highlightedId"));
          const contentEl2 = getContentEl7(scope);
          scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
        };
        raf(() => exec());
        const contentEl = () => getContentEl7(scope);
        return observeAttributes(contentEl, {
          defer: true,
          attributes: ["aria-activedescendant"],
          callback: exec
        });
      }
    },
    actions: {
      setAnchorPoint({ context, event }) {
        context.set("anchorPoint", (prev2) => isEqual(prev2, event.point) ? prev2 : event.point);
      },
      setSubmenuPlacement({ context, computed, refs }) {
        if (!context.get("isSubmenu")) return;
        const placement = computed("isRtl") ? "left-start" : "right-start";
        refs.set("positioningOverride", { placement, gutter: 0 });
      },
      reposition({ context, scope, prop, event, refs }) {
        const getPositionerEl22 = () => getPositionerEl5(scope);
        const anchorPoint = context.get("anchorPoint");
        const getAnchorRect = anchorPoint ? () => ({ width: 0, height: 0, ...anchorPoint }) : void 0;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        getPlacement(getTriggerEl5(scope), getPositionerEl22, {
          ...positioning,
          defer: true,
          getAnchorRect,
          ...event.options ?? {},
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      setOptionState({ event }) {
        if (!event.option) return;
        const { checked, onCheckedChange, type } = event.option;
        if (type === "radio") {
          onCheckedChange?.(true);
        } else if (type === "checkbox") {
          onCheckedChange?.(!checked);
        }
      },
      clickHighlightedItem({ scope, computed, prop, context }) {
        const itemEl = scope.getById(computed("highlightedId"));
        if (!itemEl || itemEl.dataset.disabled) return;
        const highlightedValue = context.get("highlightedValue");
        if (isAnchorElement(itemEl)) {
          prop("navigate")?.({ value: highlightedValue, node: itemEl, href: itemEl.href });
        } else {
          queueMicrotask(() => itemEl.click());
        }
      },
      setIntentPolygon({ context, scope, event }) {
        const menu = getContentEl7(scope);
        const placement = context.get("currentPlacement");
        if (!menu || !placement) return;
        const rect = menu.getBoundingClientRect();
        const polygon = getElementPolygon(rect, placement);
        if (!polygon) return;
        const rightSide = getPlacementSide(placement) === "right";
        const bleed = rightSide ? -5 : 5;
        context.set("intentPolygon", [{ ...event.point, x: event.point.x + bleed }, ...polygon]);
      },
      clearIntentPolygon({ context }) {
        context.set("intentPolygon", null);
      },
      clearAnchorPoint({ context }) {
        context.set("anchorPoint", null);
      },
      resumePointer({ refs, flush: flush2 }) {
        const parent = refs.get("parent");
        if (!parent) return;
        flush2(() => {
          parent.context.set("suspendPointer", false);
        });
      },
      setHighlightedItem({ context, event }) {
        const value = event.value || getItemValue(event.target);
        context.set("highlightedValue", value);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      focusMenu({ scope }) {
        raf(() => {
          const contentEl = getContentEl7(scope);
          const initialFocusEl = getInitialFocus({
            root: contentEl,
            enabled: !contains(contentEl, scope.getActiveElement()),
            filter(node) {
              return !node.role?.startsWith("menuitem");
            }
          });
          initialFocusEl?.focus({ preventScroll: true });
        });
      },
      highlightFirstItem({ context, scope }) {
        const fn = getContentEl7(scope) ? queueMicrotask : raf;
        fn(() => {
          const first2 = getFirstEl(scope);
          if (!first2) return;
          context.set("highlightedValue", getItemValue(first2));
        });
      },
      highlightLastItem({ context, scope }) {
        const fn = getContentEl7(scope) ? queueMicrotask : raf;
        fn(() => {
          const last2 = getLastEl(scope);
          if (!last2) return;
          context.set("highlightedValue", getItemValue(last2));
        });
      },
      highlightNextItem({ context, scope, event, prop }) {
        const next22 = getNextEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", getItemValue(next22));
      },
      highlightPrevItem({ context, scope, event, prop }) {
        const prev2 = getPrevEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", getItemValue(prev2));
      },
      invokeOnSelect({ context, prop, scope }) {
        const value = context.get("highlightedValue");
        if (value == null) return;
        const node = getItemEl3(scope, value);
        dispatchSelectionEvent(node, value);
        prop("onSelect")?.({ value });
      },
      focusTrigger({ scope, context, event }) {
        if (context.get("isSubmenu") || context.get("anchorPoint") || event.restoreFocus === false) return;
        queueMicrotask(() => getTriggerEl5(scope)?.focus({ preventScroll: true }));
      },
      highlightMatchedItem({ scope, context, event, refs }) {
        const node = getElemByKey(scope, {
          key: event.key,
          value: context.get("highlightedValue"),
          typeaheadState: refs.get("typeaheadState")
        });
        if (!node) return;
        context.set("highlightedValue", getItemValue(node));
      },
      setParentMenu({ refs, event, context }) {
        refs.set("parent", event.value);
        context.set("isSubmenu", true);
      },
      setChildMenu({ refs, event }) {
        const children = refs.get("children");
        children[event.id] = event.value;
        refs.set("children", children);
      },
      closeRootMenu({ refs }) {
        closeRootMenu({ parent: refs.get("parent") });
      },
      openSubmenu({ refs, scope, computed }) {
        const item = scope.getById(computed("highlightedId"));
        const id = item?.getAttribute("data-uid");
        const children = refs.get("children");
        const child2 = id ? children[id] : null;
        child2?.send({ type: "OPEN_AUTOFOCUS" });
      },
      focusParentMenu({ refs }) {
        refs.get("parent")?.send({ type: "FOCUS_MENU" });
      },
      setLastHighlightedItem({ context, event }) {
        context.set("lastHighlightedValue", getItemValue(event.target));
      },
      restoreHighlightedItem({ context }) {
        if (!context.get("lastHighlightedValue")) return;
        context.set("highlightedValue", context.get("lastHighlightedValue"));
        context.set("lastHighlightedValue", null);
      },
      restoreParentHighlightedItem({ refs }) {
        refs.get("parent")?.send({ type: "HIGHLIGHTED.RESTORE" });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      toggleVisibility({ prop, event, send }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.context.get("isSubmenu")) {
    parent = parent.refs.get("parent");
  }
  parent?.send({ type: "CLOSE" });
}
function isWithinPolygon(polygon, point) {
  if (!polygon) return false;
  return isPointInPolygon(polygon, point);
}
function resolveItemId(children, value, scope) {
  const hasChildren = Object.keys(children).length > 0;
  if (!value) return null;
  if (!hasChildren) {
    return getItemId6(scope, value);
  }
  for (const id in children) {
    const childMenu = children[id];
    const childTriggerId = getTriggerId7(childMenu.scope);
    if (childTriggerId === value) {
      return childTriggerId;
    }
  }
  return getItemId6(scope, value);
}
var props11 = createProps()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "composite",
  "defaultHighlightedValue",
  "defaultOpen",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onRequestDismiss",
  "onSelect",
  "open",
  "positioning",
  "typeahead"
]);
var splitProps12 = createSplitProps(props11);
var itemProps6 = createProps()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps6 = createSplitProps(itemProps6);
var itemGroupLabelProps3 = createProps()(["htmlFor"]);
var splitItemGroupLabelProps3 = createSplitProps(itemGroupLabelProps3);
var itemGroupProps3 = createProps()(["id"]);
var splitItemGroupProps3 = createSplitProps(itemGroupProps3);
var optionItemProps = createProps()([
  "checked",
  "closeOnSelect",
  "disabled",
  "onCheckedChange",
  "type",
  "value",
  "valueText"
]);
var splitOptionItemProps = createSplitProps(optionItemProps);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item-group-label.svelte
Item_group_label3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item-group-label.svelte";
var root_2107 = add_locations(from_html(`<div><!></div>`), Item_group_label3[FILENAME], [[35, 1]]);
function Item_group_label3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_group_label3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const itemGroupProps4 = ItemGroupContext3.consume();
  const $$d = user_derived(() => splitItemGroupLabelProps3({ htmlFor: itemGroupProps4().id, ...props25 })), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), labelProps = tag(user_derived(() => get($$array)[0]), "labelProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getItemGroupLabelProps(get(labelProps)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_group_label3, 33, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2107();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_group_label3, 36, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_group_label3,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_group_label3 = hmr(Item_group_label3);
  import.meta.hot.accept((module) => {
    Item_group_label3[HMR].update(module.default);
  });
}
var item_group_label_default3 = Item_group_label3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item-group.svelte
Item_group5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item-group.svelte";
var root_2108 = add_locations(from_html(`<div><!></div>`), Item_group5[FILENAME], [[36, 1]]);
function Item_group5($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Item_group5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const $$d = user_derived(() => splitItemGroupProps3({ id, ...props25 })), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemGroupProps4 = tag(user_derived(() => get($$array)[0]), "itemGroupProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getItemGroupProps(get(itemGroupProps4)), get(rest))), "attributes");
  ItemGroupContext3.provide(() => get(itemGroupProps4));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_group5, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2108();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_group5, 37, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_group5,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_group5 = hmr(Item_group5);
  import.meta.hot.accept((module) => {
    Item_group5[HMR].update(module.default);
  });
}
var item_group_default5 = Item_group5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/modules/item-context.js
var ItemContext5 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item-indicator.svelte
Item_indicator4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item-indicator.svelte";
var root_2109 = add_locations(from_html(`<div><!></div>`), Item_indicator4[FILENAME], [[26, 1]]);
function Item_indicator4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_indicator4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const itemProps13 = ItemContext5.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getItemIndicatorProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_indicator4, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2109();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_indicator4, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_indicator4,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_indicator4 = hmr(Item_indicator4);
  import.meta.hot.accept((module) => {
    Item_indicator4[HMR].update(module.default);
  });
}
var item_indicator_default4 = Item_indicator4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item-text.svelte
Item_text3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item-text.svelte";
var root_2110 = add_locations(from_html(`<div><!></div>`), Item_text3[FILENAME], [[26, 1]]);
function Item_text3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_text3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const itemProps13 = ItemContext5.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getItemTextProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_text3, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2110();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_text3, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_text3,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_text3 = hmr(Item_text3);
  import.meta.hot.accept((module) => {
    Item_text3[HMR].update(module.default);
  });
}
var item_text_default3 = Item_text3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item.svelte
Item6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/item.svelte";
var root_2111 = add_locations(from_html(`<div><!></div>`), Item6[FILENAME], [[30, 1]]);
function Item6($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const $$d = user_derived(() => splitItemProps6(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getItemProps(get(itemProps13)), get(rest))), "attributes");
  ItemContext5.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item6, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2111();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item6, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item6,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item6 = hmr(Item6);
  import.meta.hot.accept((module) => {
    Item6[HMR].update(module.default);
  });
}
var item_default6 = Item6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/option-item.svelte
Option_item[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/option-item.svelte";
var root_2112 = add_locations(from_html(`<div><!></div>`), Option_item[FILENAME], [[30, 1]]);
function Option_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Option_item);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const $$d = user_derived(() => splitOptionItemProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getOptionItemProps(get(itemProps13)), get(rest))), "attributes");
  ItemContext5.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Option_item, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2112();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Option_item, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Option_item,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Option_item = hmr(Option_item);
  import.meta.hot.accept((module) => {
    Option_item[HMR].update(module.default);
  });
}
var option_item_default = Option_item;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/positioner.svelte
Positioner5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/positioner.svelte";
var root_2113 = add_locations(from_html(`<div><!></div>`), Positioner5[FILENAME], [[24, 1]]);
function Positioner5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Positioner5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getPositionerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Positioner5, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2113();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Positioner5, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Positioner5,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Positioner5 = hmr(Positioner5);
  import.meta.hot.accept((module) => {
    Positioner5[HMR].update(module.default);
  });
}
var positioner_default5 = Positioner5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/root-context.svelte
Root_context11[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/root-context.svelte";
function Root_context11($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context11);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => menu), "render", Root_context11, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context11 = hmr(Root_context11);
  import.meta.hot.accept((module) => {
    Root_context11[HMR].update(module.default);
  });
}
var root_context_default11 = Root_context11;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/modules/trigger-item-context.js
var TriggerItemContext = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/root-provider.svelte
Root_provider11[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/root-provider.svelte";
function Root_provider11($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider11);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const parentMenu = RootContext11.consume();
  const children = tag(user_derived(() => $$props.children), "children"), menu = tag(user_derived(() => $$props.value), "menu");
  user_effect(() => untrack(() => {
    if (!parentMenu) {
      return;
    }
    get(menu)().setParent(parentMenu().service);
    parentMenu().setChild(get(menu)().service);
  }));
  RootContext11.provide(() => get(menu)());
  TriggerItemContext.provide(() => parentMenu?.().getTriggerItemProps(get(menu)()));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root_provider11, 35, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider11 = hmr(Root_provider11);
  import.meta.hot.accept((module) => {
    Root_provider11[HMR].update(module.default);
  });
}
var root_provider_default11 = Root_provider11;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/modules/provider.svelte.js
function useMenu(props25) {
  const service = useMachine(machine11, props25);
  const menu = tag(user_derived(() => connect11(service, normalizeProps)), "menu");
  return () => ({
    ...get(menu),
    get service() {
      return service;
    }
  });
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/root.svelte
Root12[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/root.svelte";
function Root12($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root12);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const parentMenu = RootContext11.consume();
  const $$d = user_derived(() => splitProps12(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), menuProps = tag(user_derived(() => get($$array)[0]), "menuProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const children = tag(user_derived(() => get(componentProps).children), "children");
  const menu = useMenu(() => ({ ...get(menuProps), id }));
  user_effect(() => untrack(() => {
    if (!parentMenu) {
      return;
    }
    menu().setParent(parentMenu().service);
    parentMenu().setChild(menu().service);
  }));
  RootContext11.provide(() => menu());
  TriggerItemContext.provide(() => parentMenu?.().getTriggerItemProps(menu()));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root12, 43, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root12 = hmr(Root12);
  import.meta.hot.accept((module) => {
    Root12[HMR].update(module.default);
  });
}
var root_default12 = Root12;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/separator.svelte
Separator[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/separator.svelte";
var root_2114 = add_locations(from_html(`<hr/>`), Separator[FILENAME], [[24, 1]]);
function Separator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Separator);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getSeparatorProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Separator, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var hr = root_2114();
      attribute_effect(hr, () => ({ ...get(attributes) }));
      append($$anchor2, hr);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Separator,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Separator = hmr(Separator);
  import.meta.hot.accept((module) => {
    Separator[HMR].update(module.default);
  });
}
var separator_default = Separator;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/trigger-item.svelte
Trigger_item[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/trigger-item.svelte";
var root_2115 = add_locations(from_html(`<div><!></div>`), Trigger_item[FILENAME], [[29, 1]]);
function Trigger_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger_item);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const triggerItemProps = TriggerItemContext.consume();
  const $$d = user_derived(() => splitItemProps6(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(triggerItemProps(), get(rest))), "attributes");
  ItemContext5.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger_item, 27, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2115();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger_item, 30, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger_item,
      26,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger_item = hmr(Trigger_item);
  import.meta.hot.accept((module) => {
    Trigger_item[HMR].update(module.default);
  });
}
var trigger_item_default = Trigger_item;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/trigger.svelte
Trigger7[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/anatomy/trigger.svelte";
var root_2116 = add_locations(from_html(`<button><!></button>`), Trigger7[FILENAME], [[24, 1]]);
function Trigger7($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger7);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const menu = RootContext11.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(menu().getTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger7, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2116();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger7, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger7,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger7 = hmr(Trigger7);
  import.meta.hot.accept((module) => {
    Trigger7[HMR].update(module.default);
  });
}
var trigger_default7 = Trigger7;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/menu/modules/anatomy.js
var Menu = Object.assign(root_default12, {
  Provider: root_provider_default11,
  Context: root_context_default11,
  Trigger: trigger_default7,
  ContextTrigger: context_trigger_default,
  Indicator: indicator_default3,
  Positioner: positioner_default5,
  Content: content_default7,
  ItemGroup: item_group_default5,
  ItemGroupLabel: item_group_label_default3,
  Item: item_default6,
  OptionItem: option_item_default,
  TriggerItem: trigger_item_default,
  ItemText: item_text_default3,
  ItemIndicator: item_indicator_default4,
  Separator: separator_default,
  Arrow: arrow_default,
  ArrowTip: arrow_tip_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/modules/root-context.js
var RootContext12 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/content.svelte
Content8[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/content.svelte";
var root_2117 = add_locations(from_html(`<div><!></div>`), Content8[FILENAME], [[33, 1]]);
function Content8($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content8);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const navigation = RootContext12.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "content",
        "data-layout": navigation().layout
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content8, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2117();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content8, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content8,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content8 = hmr(Content8);
  import.meta.hot.accept((module) => {
    Content8[HMR].update(module.default);
  });
}
var content_default8 = Content8;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/footer.svelte
Footer[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/footer.svelte";
var root_2118 = add_locations(from_html(`<footer><!></footer>`), Footer[FILENAME], [[33, 1]]);
function Footer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Footer);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const navigation = RootContext12.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "footer",
        "data-layout": navigation().layout
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Footer, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var footer = root_2118();
      attribute_effect(footer, () => ({ ...get(attributes) }));
      var node_2 = child(footer);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Footer, 34, 2);
      reset(footer);
      append($$anchor2, footer);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Footer,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Footer = hmr(Footer);
  import.meta.hot.accept((module) => {
    Footer[HMR].update(module.default);
  });
}
var footer_default = Footer;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/group.svelte
Group[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/group.svelte";
var root_2119 = add_locations(from_html(`<div><!></div>`), Group[FILENAME], [[33, 1]]);
function Group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Group);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const navigation = RootContext12.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "group",
        "data-layout": navigation().layout
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Group, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2119();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Group, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Group,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Group = hmr(Group);
  import.meta.hot.accept((module) => {
    Group[HMR].update(module.default);
  });
}
var group_default = Group;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/header.svelte
Header2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/header.svelte";
var root_2120 = add_locations(from_html(`<header><!></header>`), Header2[FILENAME], [[33, 1]]);
function Header2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Header2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const navigation = RootContext12.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "header",
        "data-layout": navigation().layout
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Header2, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var header = root_2120();
      attribute_effect(header, () => ({ ...get(attributes) }));
      var node_2 = child(header);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Header2, 34, 2);
      reset(header);
      append($$anchor2, header);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Header2,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Header2 = hmr(Header2);
  import.meta.hot.accept((module) => {
    Header2[HMR].update(module.default);
  });
}
var header_default2 = Header2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/label.svelte
Label5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/label.svelte";
var root_2121 = add_locations(from_html(`<div><!></div>`), Label5[FILENAME], [[33, 1]]);
function Label5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const navigation = RootContext12.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "label",
        "data-layout": navigation().layout
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label5, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2121();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label5, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label5,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label5 = hmr(Label5);
  import.meta.hot.accept((module) => {
    Label5[HMR].update(module.default);
  });
}
var label_default5 = Label5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/menu.svelte
Menu2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/menu.svelte";
var root_2122 = add_locations(from_html(`<div><!></div>`), Menu2[FILENAME], [[33, 1]]);
function Menu2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const navigation = RootContext12.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "menu",
        "data-layout": navigation().layout
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Menu2, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2122();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Menu2, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menu2,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Menu2 = hmr(Menu2);
  import.meta.hot.accept((module) => {
    Menu2[HMR].update(module.default);
  });
}
var menu_default = Menu2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/trigger-anchor.svelte
Trigger_anchor[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/trigger-anchor.svelte";
var root_2123 = add_locations(from_html(`<a><!></a>`), Trigger_anchor[FILENAME], [[33, 1]]);
function Trigger_anchor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger_anchor);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const navigation = RootContext12.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "trigger-anchor",
        "data-layout": navigation().layout
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger_anchor, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var a = root_2123();
      attribute_effect(a, () => ({ ...get(attributes) }));
      var node_2 = child(a);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger_anchor, 34, 2);
      reset(a);
      append($$anchor2, a);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger_anchor,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger_anchor = hmr(Trigger_anchor);
  import.meta.hot.accept((module) => {
    Trigger_anchor[HMR].update(module.default);
  });
}
var trigger_anchor_default = Trigger_anchor;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/trigger.svelte
Trigger8[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/trigger.svelte";
var root_2124 = add_locations(from_html(`<button><!></button>`), Trigger8[FILENAME], [[34, 1]]);
function Trigger8($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger8);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const navigation = RootContext12.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "trigger",
        "data-layout": navigation().layout,
        type: "button"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger8, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2124();
      attribute_effect(button, () => ({ type: "button", ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger8, 35, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger8,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger8 = hmr(Trigger8);
  import.meta.hot.accept((module) => {
    Trigger8[HMR].update(module.default);
  });
}
var trigger_default8 = Trigger8;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/trigger-text.svelte
Trigger_text[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/trigger-text.svelte";
var root_2125 = add_locations(from_html(`<span><!></span>`), Trigger_text[FILENAME], [[33, 1]]);
function Trigger_text($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger_text);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const navigation = RootContext12.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "trigger-text",
        "data-layout": navigation().layout
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger_text, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2125();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger_text, 34, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger_text,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger_text = hmr(Trigger_text);
  import.meta.hot.accept((module) => {
    Trigger_text[HMR].update(module.default);
  });
}
var trigger_text_default = Trigger_text;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/root.svelte
Root13[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/anatomy/root.svelte";
var root_2126 = add_locations(from_html(`<div><!></div>`), Root13[FILENAME], [[39, 1]]);
function Root13($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root13);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const layout = tag(user_derived(() => fallback($$props.layout, "bar")), "layout"), element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["layout", "element", "children"])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        "data-scope": "navigation",
        "data-part": "root",
        "data-layout": get(layout)
      },
      get(rest)
    )),
    "attributes"
  );
  RootContext12.provide(() => ({ layout: get(layout) }));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root13, 37, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2126();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root13, 40, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root13,
      36,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root13 = hmr(Root13);
  import.meta.hot.accept((module) => {
    Root13[HMR].update(module.default);
  });
}
var root_default13 = Root13;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/navigation/modules/anatomy.js
var Navigation = Object.assign(root_default13, {
  Header: header_default2,
  Content: content_default8,
  Group: group_default,
  Label: label_default5,
  Menu: menu_default,
  Trigger: trigger_default8,
  TriggerAnchor: trigger_anchor_default,
  TriggerText: trigger_text_default,
  Footer: footer_default
});

// node_modules/@zag-js/pagination/dist/index.mjs
var anatomy12 = createAnatomy("pagination").parts(
  "root",
  "item",
  "ellipsis",
  "firstTrigger",
  "prevTrigger",
  "nextTrigger",
  "lastTrigger"
);
var parts12 = anatomy12.build();
var getRootId9 = (ctx) => ctx.ids?.root ?? `pagination:${ctx.id}`;
var getFirstTriggerId = (ctx) => ctx.ids?.firstTrigger ?? `pagination:${ctx.id}:first`;
var getPrevTriggerId3 = (ctx) => ctx.ids?.prevTrigger ?? `pagination:${ctx.id}:prev`;
var getNextTriggerId3 = (ctx) => ctx.ids?.nextTrigger ?? `pagination:${ctx.id}:next`;
var getLastTriggerId = (ctx) => ctx.ids?.lastTrigger ?? `pagination:${ctx.id}:last`;
var getEllipsisId = (ctx, index) => ctx.ids?.ellipsis?.(index) ?? `pagination:${ctx.id}:ellipsis:${index}`;
var getItemId7 = (ctx, page) => ctx.ids?.item?.(page) ?? `pagination:${ctx.id}:item:${page}`;
var range = (start, end) => {
  let length = end - start + 1;
  return Array.from({ length }, (_, idx) => idx + start);
};
var transform = (items) => {
  return items.map((value) => {
    if (isNumber(value)) return { type: "page", value };
    return { type: "ellipsis" };
  });
};
var ELLIPSIS = "ellipsis";
var getRange = (ctx) => {
  const { page, totalPages, siblingCount, boundaryCount = 1 } = ctx;
  if (totalPages <= 0) return [];
  if (totalPages === 1) return [1];
  const firstPageIndex = 1;
  const lastPageIndex = totalPages;
  const leftSiblingIndex = Math.max(page - siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(page + siblingCount, lastPageIndex);
  const totalPageNumbers = Math.min(siblingCount * 2 + 3 + boundaryCount * 2, totalPages);
  if (totalPages <= totalPageNumbers) {
    return range(firstPageIndex, lastPageIndex);
  }
  const itemCount = totalPageNumbers - 1 - boundaryCount;
  const showLeftEllipsis = leftSiblingIndex > firstPageIndex + boundaryCount + 1 && Math.abs(leftSiblingIndex - firstPageIndex) > boundaryCount + 1;
  const showRightEllipsis = rightSiblingIndex < lastPageIndex - boundaryCount - 1 && Math.abs(lastPageIndex - rightSiblingIndex) > boundaryCount + 1;
  let pages = [];
  if (!showLeftEllipsis && showRightEllipsis) {
    const leftRange = range(1, itemCount);
    pages.push(...leftRange, ELLIPSIS);
    pages.push(...range(lastPageIndex - boundaryCount + 1, lastPageIndex));
  } else if (showLeftEllipsis && !showRightEllipsis) {
    pages.push(...range(firstPageIndex, firstPageIndex + boundaryCount - 1));
    pages.push(ELLIPSIS);
    const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
    pages.push(...rightRange);
  } else if (showLeftEllipsis && showRightEllipsis) {
    pages.push(...range(firstPageIndex, firstPageIndex + boundaryCount - 1));
    pages.push(ELLIPSIS);
    const middleRange = range(leftSiblingIndex, rightSiblingIndex);
    pages.push(...middleRange);
    pages.push(ELLIPSIS);
    pages.push(...range(lastPageIndex - boundaryCount + 1, lastPageIndex));
  } else {
    pages.push(...range(firstPageIndex, lastPageIndex));
  }
  for (let i = 0; i < pages.length; i++) {
    if (pages[i] === ELLIPSIS) {
      const prevPage = isNumber(pages[i - 1]) ? pages[i - 1] : 0;
      const nextPage = isNumber(pages[i + 1]) ? pages[i + 1] : totalPages + 1;
      if (nextPage - prevPage === 2) {
        pages[i] = prevPage + 1;
      }
    }
  }
  return pages;
};
var getTransformedRange = (ctx) => transform(getRange(ctx));
function connect12(service, normalize2) {
  const { send, scope, prop, computed, context } = service;
  const totalPages = computed("totalPages");
  const page = context.get("page");
  const pageSize = context.get("pageSize");
  const translations = prop("translations");
  const count = prop("count");
  const getPageUrl = prop("getPageUrl");
  const type = prop("type");
  const previousPage = computed("previousPage");
  const nextPage = computed("nextPage");
  const pageRange = computed("pageRange");
  const isFirstPage = page === 1;
  const isLastPage = page === totalPages;
  const pages = getTransformedRange({
    page,
    totalPages,
    siblingCount: prop("siblingCount"),
    boundaryCount: prop("boundaryCount")
  });
  return {
    count,
    page,
    pageSize,
    totalPages,
    pages,
    previousPage,
    nextPage,
    pageRange,
    slice(data) {
      return data.slice(pageRange.start, pageRange.end);
    },
    setPageSize(size2) {
      send({ type: "SET_PAGE_SIZE", size: size2 });
    },
    setPage(page2) {
      send({ type: "SET_PAGE", page: page2 });
    },
    goToNextPage() {
      send({ type: "NEXT_PAGE" });
    },
    goToPrevPage() {
      send({ type: "PREVIOUS_PAGE" });
    },
    goToFirstPage() {
      send({ type: "FIRST_PAGE" });
    },
    goToLastPage() {
      send({ type: "LAST_PAGE" });
    },
    getRootProps() {
      return normalize2.element({
        id: getRootId9(scope),
        ...parts12.root.attrs,
        dir: prop("dir"),
        "aria-label": translations.rootLabel
      });
    },
    getEllipsisProps(props25) {
      return normalize2.element({
        id: getEllipsisId(scope, props25.index),
        ...parts12.ellipsis.attrs,
        dir: prop("dir")
      });
    },
    getItemProps(props25) {
      const index = props25.value;
      const isCurrentPage = index === page;
      return normalize2.element({
        id: getItemId7(scope, index),
        ...parts12.item.attrs,
        dir: prop("dir"),
        "data-index": index,
        "data-selected": dataAttr(isCurrentPage),
        "aria-current": isCurrentPage ? "page" : void 0,
        "aria-label": translations.itemLabel?.({ page: index, totalPages }),
        onClick() {
          send({ type: "SET_PAGE", page: index });
        },
        ...type === "button" && { type: "button" },
        ...type === "link" && getPageUrl && {
          href: getPageUrl({ page: index, pageSize })
        }
      });
    },
    getPrevTriggerProps() {
      return normalize2.element({
        id: getPrevTriggerId3(scope),
        ...parts12.prevTrigger.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(isFirstPage),
        "aria-label": translations.prevTriggerLabel,
        onClick() {
          send({ type: "PREVIOUS_PAGE" });
        },
        ...type === "button" && { disabled: isFirstPage, type: "button" },
        ...type === "link" && getPageUrl && previousPage && {
          href: getPageUrl({ page: previousPage, pageSize })
        }
      });
    },
    getFirstTriggerProps() {
      return normalize2.element({
        id: getFirstTriggerId(scope),
        ...parts12.firstTrigger.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(isFirstPage),
        "aria-label": translations.firstTriggerLabel,
        onClick() {
          send({ type: "FIRST_PAGE" });
        },
        ...type === "button" && { disabled: isFirstPage, type: "button" },
        ...type === "link" && getPageUrl && {
          href: getPageUrl({ page: 1, pageSize })
        }
      });
    },
    getNextTriggerProps() {
      return normalize2.element({
        id: getNextTriggerId3(scope),
        ...parts12.nextTrigger.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(isLastPage),
        "aria-label": translations.nextTriggerLabel,
        onClick() {
          send({ type: "NEXT_PAGE" });
        },
        ...type === "button" && { disabled: isLastPage, type: "button" },
        ...type === "link" && getPageUrl && nextPage && {
          href: getPageUrl({ page: nextPage, pageSize })
        }
      });
    },
    getLastTriggerProps() {
      return normalize2.element({
        id: getLastTriggerId(scope),
        ...parts12.lastTrigger.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(isLastPage),
        "aria-label": translations.lastTriggerLabel,
        onClick() {
          send({ type: "LAST_PAGE" });
        },
        ...type === "button" && { disabled: isLastPage, type: "button" },
        ...type === "link" && getPageUrl && {
          href: getPageUrl({ page: totalPages, pageSize })
        }
      });
    }
  };
}
var machine12 = createMachine({
  props({ props: props25 }) {
    return {
      defaultPageSize: 10,
      siblingCount: 1,
      boundaryCount: 1,
      defaultPage: 1,
      type: "button",
      count: 1,
      ...props25,
      translations: {
        rootLabel: "pagination",
        firstTriggerLabel: "first page",
        prevTriggerLabel: "previous page",
        nextTriggerLabel: "next page",
        lastTriggerLabel: "last page",
        itemLabel({ page, totalPages }) {
          const isLastPage = totalPages > 1 && page === totalPages;
          return `${isLastPage ? "last page, " : ""}page ${page}`;
        },
        ...props25.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable: bindable2, getContext: getContext2 }) {
    return {
      page: bindable2(() => ({
        value: prop("page"),
        defaultValue: prop("defaultPage"),
        onChange(value) {
          const context = getContext2();
          prop("onPageChange")?.({ page: value, pageSize: context.get("pageSize") });
        }
      })),
      pageSize: bindable2(() => ({
        value: prop("pageSize"),
        defaultValue: prop("defaultPageSize"),
        onChange(value) {
          prop("onPageSizeChange")?.({ pageSize: value });
        }
      }))
    };
  },
  watch({ track: track2, context, action }) {
    track2([() => context.get("pageSize")], () => {
      action(["setPageIfNeeded"]);
    });
  },
  computed: {
    totalPages: memo(
      ({ prop, context }) => [context.get("pageSize"), prop("count")],
      ([pageSize, count]) => Math.ceil(count / pageSize)
    ),
    pageRange: memo(
      ({ context, prop }) => [context.get("page"), context.get("pageSize"), prop("count")],
      ([page, pageSize, count]) => {
        const start = (page - 1) * pageSize;
        return { start, end: Math.min(start + pageSize, count) };
      }
    ),
    previousPage: ({ context }) => context.get("page") === 1 ? null : context.get("page") - 1,
    nextPage: ({ context, computed }) => context.get("page") === computed("totalPages") ? null : context.get("page") + 1,
    isValidPage: ({ context, computed }) => context.get("page") >= 1 && context.get("page") <= computed("totalPages")
  },
  on: {
    SET_PAGE: {
      guard: "isValidPage",
      actions: ["setPage"]
    },
    SET_PAGE_SIZE: {
      actions: ["setPageSize"]
    },
    FIRST_PAGE: {
      actions: ["goToFirstPage"]
    },
    LAST_PAGE: {
      actions: ["goToLastPage"]
    },
    PREVIOUS_PAGE: {
      guard: "canGoToPrevPage",
      actions: ["goToPrevPage"]
    },
    NEXT_PAGE: {
      guard: "canGoToNextPage",
      actions: ["goToNextPage"]
    }
  },
  states: {
    idle: {}
  },
  implementations: {
    guards: {
      isValidPage: ({ event, computed }) => event.page >= 1 && event.page <= computed("totalPages"),
      isValidCount: ({ context, event }) => context.get("page") > event.count,
      canGoToNextPage: ({ context, computed }) => context.get("page") < computed("totalPages"),
      canGoToPrevPage: ({ context }) => context.get("page") > 1
    },
    actions: {
      setPage({ context, event, computed }) {
        const page = clampPage(event.page, computed("totalPages"));
        context.set("page", page);
      },
      setPageSize({ context, event }) {
        context.set("pageSize", event.size);
      },
      goToFirstPage({ context }) {
        context.set("page", 1);
      },
      goToLastPage({ context, computed }) {
        context.set("page", computed("totalPages"));
      },
      goToPrevPage({ context, computed }) {
        context.set("page", (prev2) => clampPage(prev2 - 1, computed("totalPages")));
      },
      goToNextPage({ context, computed }) {
        context.set("page", (prev2) => clampPage(prev2 + 1, computed("totalPages")));
      },
      setPageIfNeeded({ context, computed }) {
        if (computed("isValidPage")) return;
        context.set("page", 1);
      }
    }
  }
});
var clampPage = (page, totalPages) => Math.min(Math.max(page, 1), totalPages);
var props12 = createProps()([
  "boundaryCount",
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onPageChange",
  "onPageSizeChange",
  "page",
  "defaultPage",
  "pageSize",
  "defaultPageSize",
  "siblingCount",
  "translations",
  "type",
  "getPageUrl"
]);
var splitProps13 = createSplitProps(props12);
var itemProps7 = createProps()(["value", "type"]);
var splitItemProps7 = createSplitProps(itemProps7);
var ellipsisProps = createProps()(["index"]);
var splitEllipsisProps = createSplitProps(ellipsisProps);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/modules/root-context.js
var RootContext13 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/ellipsis.svelte
Ellipsis[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/ellipsis.svelte";
var root_2127 = add_locations(from_html(`<span><!></span>`), Ellipsis[FILENAME], [[26, 1]]);
function Ellipsis($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Ellipsis);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const pagination = RootContext13.consume();
  const $$d = user_derived(() => splitEllipsisProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), ellipsisProps2 = tag(user_derived(() => get($$array)[0]), "ellipsisProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(pagination().getEllipsisProps(get(ellipsisProps2)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Ellipsis, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2127();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Ellipsis, 27, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Ellipsis,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Ellipsis = hmr(Ellipsis);
  import.meta.hot.accept((module) => {
    Ellipsis[HMR].update(module.default);
  });
}
var ellipsis_default = Ellipsis;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/first-trigger.svelte
First_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/first-trigger.svelte";
var root_2128 = add_locations(from_html(`<button><!></button>`), First_trigger[FILENAME], [[31, 1]]);
function First_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, First_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const pagination = RootContext13.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2({ onclick: () => pagination().goToFirstPage() }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", First_trigger, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2128();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", First_trigger, 32, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      First_trigger,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  First_trigger = hmr(First_trigger);
  import.meta.hot.accept((module) => {
    First_trigger[HMR].update(module.default);
  });
}
var first_trigger_default = First_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/item.svelte
Item7[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/item.svelte";
var root_2129 = add_locations(from_html(`<a><!></a>`), Item7[FILENAME], [[26, 1]]);
function Item7($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item7);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const pagination = RootContext13.consume();
  const $$d = user_derived(() => splitItemProps7(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(pagination().getItemProps(get(itemProps13)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item7, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var a = root_2129();
      attribute_effect(a, () => ({ ...get(attributes) }));
      var node_2 = child(a);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item7, 27, 2);
      reset(a);
      append($$anchor2, a);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item7,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item7 = hmr(Item7);
  import.meta.hot.accept((module) => {
    Item7[HMR].update(module.default);
  });
}
var item_default7 = Item7;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/last-trigger.svelte
Last_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/last-trigger.svelte";
var root_2130 = add_locations(from_html(`<button><!></button>`), Last_trigger[FILENAME], [[31, 1]]);
function Last_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Last_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const pagination = RootContext13.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2({ onclick: () => pagination().goToLastPage() }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Last_trigger, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2130();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Last_trigger, 32, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Last_trigger,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Last_trigger = hmr(Last_trigger);
  import.meta.hot.accept((module) => {
    Last_trigger[HMR].update(module.default);
  });
}
var last_trigger_default = Last_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/next-trigger.svelte
Next_trigger3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/next-trigger.svelte";
var root_2131 = add_locations(from_html(`<button><!></button>`), Next_trigger3[FILENAME], [[24, 1]]);
function Next_trigger3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Next_trigger3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const pagination = RootContext13.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(pagination().getNextTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Next_trigger3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2131();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Next_trigger3, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Next_trigger3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Next_trigger3 = hmr(Next_trigger3);
  import.meta.hot.accept((module) => {
    Next_trigger3[HMR].update(module.default);
  });
}
var next_trigger_default3 = Next_trigger3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/prev-trigger.svelte
Prev_trigger3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/prev-trigger.svelte";
var root_2132 = add_locations(from_html(`<button><!></button>`), Prev_trigger3[FILENAME], [[24, 1]]);
function Prev_trigger3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Prev_trigger3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const pagination = RootContext13.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(pagination().getPrevTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Prev_trigger3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2132();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Prev_trigger3, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Prev_trigger3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Prev_trigger3 = hmr(Prev_trigger3);
  import.meta.hot.accept((module) => {
    Prev_trigger3[HMR].update(module.default);
  });
}
var prev_trigger_default3 = Prev_trigger3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/root-context.svelte
Root_context12[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/root-context.svelte";
function Root_context12($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context12);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const pagination = RootContext13.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => pagination), "render", Root_context12, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context12 = hmr(Root_context12);
  import.meta.hot.accept((module) => {
    Root_context12[HMR].update(module.default);
  });
}
var root_context_default12 = Root_context12;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/root-provider.svelte
Root_provider12[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/root-provider.svelte";
var root_2133 = add_locations(from_html(`<div><!></div>`), Root_provider12[FILENAME], [[27, 1]]);
function Root_provider12($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider12);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), pagination = tag(user_derived(() => $$props.value), "pagination"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(pagination)().getRootProps(), get(rest))), "attributes");
  RootContext13.provide(() => get(pagination)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider12, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2133();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider12, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider12,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider12 = hmr(Root_provider12);
  import.meta.hot.accept((module) => {
    Root_provider12[HMR].update(module.default);
  });
}
var root_provider_default12 = Root_provider12;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/modules/provider.svelte.js
function usePagination(props25) {
  const service = useMachine(machine12, props25);
  const pagination = tag(user_derived(() => connect12(service, normalizeProps)), "pagination");
  return () => get(pagination);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/root.svelte
Root14[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/anatomy/root.svelte";
var root_2134 = add_locations(from_html(`<div><!></div>`), Root14[FILENAME], [[34, 1]]);
function Root14($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root14);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps13(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), paginationProps = tag(user_derived(() => get($$array)[0]), "paginationProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const pagination = usePagination(() => ({ ...get(paginationProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(pagination().getRootProps(), get(rest))), "attributes");
  RootContext13.provide(() => pagination());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root14, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2134();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root14, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root14,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root14 = hmr(Root14);
  import.meta.hot.accept((module) => {
    Root14[HMR].update(module.default);
  });
}
var root_default14 = Root14;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/pagination/modules/anatomy.js
var Pagination = Object.assign(root_default14, {
  Provider: root_provider_default12,
  Context: root_context_default12,
  FirstTrigger: first_trigger_default,
  PrevTrigger: prev_trigger_default3,
  Item: item_default7,
  Ellipsis: ellipsis_default,
  NextTrigger: next_trigger_default3,
  LastTrigger: last_trigger_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/modules/root-context.js
var RootContext14 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/anchor.svelte
Anchor[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/anchor.svelte";
var root_2135 = add_locations(from_html(`<div><!></div>`), Anchor[FILENAME], [[24, 1]]);
function Anchor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Anchor);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(popover().getAnchorProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Anchor, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2135();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Anchor, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Anchor,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Anchor = hmr(Anchor);
  import.meta.hot.accept((module) => {
    Anchor[HMR].update(module.default);
  });
}
var anchor_default = Anchor;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/arrow-tip.svelte
Arrow_tip2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/arrow-tip.svelte";
var root_2136 = add_locations(from_html(`<div><!></div>`), Arrow_tip2[FILENAME], [[24, 1]]);
function Arrow_tip2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow_tip2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(popover().getArrowTipProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Arrow_tip2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2136();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Arrow_tip2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Arrow_tip2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Arrow_tip2 = hmr(Arrow_tip2);
  import.meta.hot.accept((module) => {
    Arrow_tip2[HMR].update(module.default);
  });
}
var arrow_tip_default2 = Arrow_tip2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/arrow.svelte
Arrow2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/arrow.svelte";
var root_2137 = add_locations(from_html(`<div><!></div>`), Arrow2[FILENAME], [[24, 1]]);
function Arrow2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(popover().getArrowProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Arrow2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2137();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Arrow2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Arrow2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Arrow2 = hmr(Arrow2);
  import.meta.hot.accept((module) => {
    Arrow2[HMR].update(module.default);
  });
}
var arrow_default2 = Arrow2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/close-trigger.svelte
Close_trigger3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/close-trigger.svelte";
var root_2138 = add_locations(from_html(`<button><!></button>`), Close_trigger3[FILENAME], [[24, 1]]);
function Close_trigger3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Close_trigger3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(popover().getCloseTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Close_trigger3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2138();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Close_trigger3, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Close_trigger3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Close_trigger3 = hmr(Close_trigger3);
  import.meta.hot.accept((module) => {
    Close_trigger3[HMR].update(module.default);
  });
}
var close_trigger_default3 = Close_trigger3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/content.svelte
Content9[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/content.svelte";
var root_2139 = add_locations(from_html(`<div><!></div>`), Content9[FILENAME], [[24, 1]]);
function Content9($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content9);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(popover().getContentProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content9, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2139();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content9, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content9,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content9 = hmr(Content9);
  import.meta.hot.accept((module) => {
    Content9[HMR].update(module.default);
  });
}
var content_default9 = Content9;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/description.svelte
Description2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/description.svelte";
var root_2140 = add_locations(from_html(`<div><!></div>`), Description2[FILENAME], [[24, 1]]);
function Description2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Description2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(popover().getDescriptionProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Description2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2140();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Description2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Description2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Description2 = hmr(Description2);
  import.meta.hot.accept((module) => {
    Description2[HMR].update(module.default);
  });
}
var description_default2 = Description2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/positioner.svelte
Positioner6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/positioner.svelte";
var root_2141 = add_locations(from_html(`<div><!></div>`), Positioner6[FILENAME], [[24, 1]]);
function Positioner6($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Positioner6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(popover().getPositionerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Positioner6, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2141();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Positioner6, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Positioner6,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Positioner6 = hmr(Positioner6);
  import.meta.hot.accept((module) => {
    Positioner6[HMR].update(module.default);
  });
}
var positioner_default6 = Positioner6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/root-context.svelte
Root_context13[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/root-context.svelte";
function Root_context13($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context13);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => popover), "render", Root_context13, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context13 = hmr(Root_context13);
  import.meta.hot.accept((module) => {
    Root_context13[HMR].update(module.default);
  });
}
var root_context_default13 = Root_context13;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/root-provider.svelte
Root_provider13[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/root-provider.svelte";
function Root_provider13($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider13);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const children = tag(user_derived(() => $$props.children), "children"), popover = tag(user_derived(() => $$props.value), "popover");
  RootContext14.provide(() => get(popover)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root_provider13, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider13 = hmr(Root_provider13);
  import.meta.hot.accept((module) => {
    Root_provider13[HMR].update(module.default);
  });
}
var root_provider_default13 = Root_provider13;

// node_modules/@zag-js/popover/dist/index.mjs
var anatomy13 = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts13 = anatomy13.build();
var getAnchorId = (scope) => scope.ids?.anchor ?? `popover:${scope.id}:anchor`;
var getTriggerId8 = (scope) => scope.ids?.trigger ?? `popover:${scope.id}:trigger`;
var getContentId8 = (scope) => scope.ids?.content ?? `popover:${scope.id}:content`;
var getPositionerId6 = (scope) => scope.ids?.positioner ?? `popover:${scope.id}:popper`;
var getArrowId2 = (scope) => scope.ids?.arrow ?? `popover:${scope.id}:arrow`;
var getTitleId3 = (scope) => scope.ids?.title ?? `popover:${scope.id}:title`;
var getDescriptionId2 = (scope) => scope.ids?.description ?? `popover:${scope.id}:desc`;
var getCloseTriggerId2 = (scope) => scope.ids?.closeTrigger ?? `popover:${scope.id}:close`;
var getAnchorEl = (scope) => scope.getById(getAnchorId(scope));
var getTriggerEl6 = (scope) => scope.getById(getTriggerId8(scope));
var getContentEl8 = (scope) => scope.getById(getContentId8(scope));
var getPositionerEl6 = (scope) => scope.getById(getPositionerId6(scope));
var getTitleEl2 = (scope) => scope.getById(getTitleId3(scope));
var getDescriptionEl2 = (scope) => scope.getById(getDescriptionId2(scope));
function connect13(service, normalize2) {
  const { state: state3, context, send, computed, prop, scope } = service;
  const open = state3.matches("open");
  const currentPlacement = context.get("currentPlacement");
  const portalled = computed("currentPortalled");
  const rendered = context.get("renderedElements");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: currentPlacement
  });
  return {
    portalled,
    open,
    setOpen(nextOpen) {
      const open2 = state3.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize2.element({
        id: getArrowId2(scope),
        ...parts13.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts13.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getAnchorProps() {
      return normalize2.element({
        ...parts13.anchor.attrs,
        dir: prop("dir"),
        id: getAnchorId(scope)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts13.trigger.attrs,
        dir: prop("dir"),
        type: "button",
        "data-placement": currentPlacement,
        id: getTriggerId8(scope),
        "aria-haspopup": "dialog",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": getContentId8(scope),
        onPointerDown(event) {
          if (!isLeftClick(event)) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "TOGGLE" });
        },
        onBlur(event) {
          send({ type: "TRIGGER_BLUR", target: event.relatedTarget });
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts13.indicator.attrs,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: getPositionerId6(scope),
        ...parts13.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts13.content.attrs,
        dir: prop("dir"),
        id: getContentId8(scope),
        tabIndex: -1,
        role: "dialog",
        "aria-modal": ariaAttr(prop("modal")),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-expanded": dataAttr(open),
        "aria-labelledby": rendered.title ? getTitleId3(scope) : void 0,
        "aria-describedby": rendered.description ? getDescriptionId2(scope) : void 0,
        "data-placement": currentPlacement
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts13.title.attrs,
        id: getTitleId3(scope),
        dir: prop("dir")
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts13.description.attrs,
        id: getDescriptionId2(scope),
        dir: prop("dir")
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts13.closeTrigger.attrs,
        dir: prop("dir"),
        id: getCloseTriggerId2(scope),
        type: "button",
        "aria-label": "close",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send({ type: "CLOSE" });
        }
      });
    }
  };
}
var machine13 = createMachine({
  props({ props: props25 }) {
    return {
      closeOnInteractOutside: true,
      closeOnEscape: true,
      autoFocus: true,
      modal: false,
      portalled: true,
      ...props25,
      positioning: {
        placement: "bottom",
        ...props25.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable: bindable2 }) {
    return {
      currentPlacement: bindable2(() => ({
        defaultValue: void 0
      })),
      renderedElements: bindable2(() => ({
        defaultValue: { title: true, description: true }
      }))
    };
  },
  computed: {
    currentPortalled: ({ prop }) => !!prop("modal") || !!prop("portalled")
  },
  watch({ track: track2, prop, action }) {
    track2([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  entry: ["checkRenderedElements"],
  states: {
    closed: {
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["setInitialFocus"]
        },
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ]
      }
    },
    open: {
      effects: [
        "trapFocus",
        "preventScroll",
        "hideContentBelow",
        "trackPositioning",
        "trackDismissableElement",
        "proxyTabFocus"
      ],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["setFinalFocus"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose", "setFinalFocus"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackPositioning({ context, prop, scope }) {
        context.set("currentPlacement", prop("positioning").placement);
        const anchorEl = getAnchorEl(scope) ?? getTriggerEl6(scope);
        const getPositionerEl22 = () => getPositionerEl6(scope);
        return getPlacement(anchorEl, getPositionerEl22, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackDismissableElement({ send, prop, scope }) {
        const getContentEl22 = () => getContentEl8(scope);
        let restoreFocus = true;
        return trackDismissableElement(getContentEl22, {
          type: "popover",
          pointerBlocking: prop("modal"),
          exclude: getTriggerEl6(scope),
          defer: true,
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (prop("closeOnEscape")) return;
            event.preventDefault();
          },
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (event.defaultPrevented) return;
            restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          onPointerDownOutside: prop("onPointerDownOutside"),
          onFocusOutside: prop("onFocusOutside"),
          persistentElements: prop("persistentElements"),
          onRequestDismiss: prop("onRequestDismiss"),
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      proxyTabFocus({ prop, scope }) {
        if (prop("modal") || !prop("portalled")) return;
        const getContentEl22 = () => getContentEl8(scope);
        return proxyTabFocus(getContentEl22, {
          triggerElement: getTriggerEl6(scope),
          defer: true,
          getShadowRoot: true,
          onFocus(el) {
            el.focus({ preventScroll: true });
          }
        });
      },
      hideContentBelow({ prop, scope }) {
        if (!prop("modal")) return;
        const getElements4 = () => [getContentEl8(scope), getTriggerEl6(scope)];
        return ariaHidden(getElements4, { defer: true });
      },
      preventScroll({ prop, scope }) {
        if (!prop("modal")) return;
        return preventBodyScroll(scope.getDoc());
      },
      trapFocus({ prop, scope }) {
        if (!prop("modal")) return;
        const contentEl = () => getContentEl8(scope);
        return trapFocus(contentEl, {
          initialFocus: () => getInitialFocus({
            root: getContentEl8(scope),
            getInitialEl: prop("initialFocusEl"),
            enabled: prop("autoFocus")
          }),
          getShadowRoot: true
        });
      }
    },
    actions: {
      reposition({ event, prop, scope, context }) {
        const anchorEl = getAnchorEl(scope) ?? getTriggerEl6(scope);
        const getPositionerEl22 = () => getPositionerEl6(scope);
        getPlacement(anchorEl, getPositionerEl22, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      checkRenderedElements({ context, scope }) {
        raf(() => {
          Object.assign(context.get("renderedElements"), {
            title: !!getTitleEl2(scope),
            description: !!getDescriptionEl2(scope)
          });
        });
      },
      setInitialFocus({ prop, scope }) {
        if (prop("modal")) return;
        raf(() => {
          const element2 = getInitialFocus({
            root: getContentEl8(scope),
            getInitialEl: prop("initialFocusEl"),
            enabled: prop("autoFocus")
          });
          element2?.focus({ preventScroll: true });
        });
      },
      setFinalFocus({ event, scope }) {
        const restoreFocus = event.restoreFocus ?? event.previousEvent?.restoreFocus;
        if (restoreFocus != null && !restoreFocus) return;
        raf(() => {
          const element2 = getTriggerEl6(scope);
          element2?.focus({ preventScroll: true });
        });
      },
      invokeOnOpen({ prop, flush: flush2 }) {
        flush2(() => {
          prop("onOpenChange")?.({ open: true });
        });
      },
      invokeOnClose({ prop, flush: flush2 }) {
        flush2(() => {
          prop("onOpenChange")?.({ open: false });
        });
      },
      toggleVisibility({ event, send, prop }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
var props13 = createProps()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onRequestDismiss",
  "defaultOpen",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
var splitProps14 = createSplitProps(props13);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/modules/provider.svelte.js
function usePopover(props25) {
  const service = useMachine(machine13, props25);
  const popover = tag(user_derived(() => connect13(service, normalizeProps)), "popover");
  return () => get(popover);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/root.svelte
Root15[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/root.svelte";
function Root15($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root15);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps14(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), popoverProps = tag(user_derived(() => get($$array)[0]), "popoverProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const children = tag(user_derived(() => get(componentProps).children), "children");
  const popover = usePopover(() => ({ ...get(popoverProps), id }));
  RootContext14.provide(() => popover());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root15, 27, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root15 = hmr(Root15);
  import.meta.hot.accept((module) => {
    Root15[HMR].update(module.default);
  });
}
var root_default15 = Root15;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/title.svelte
Title3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/title.svelte";
var root_2142 = add_locations(from_html(`<div><!></div>`), Title3[FILENAME], [[24, 1]]);
function Title3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Title3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(popover().getTitleProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Title3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2142();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Title3, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Title3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Title3 = hmr(Title3);
  import.meta.hot.accept((module) => {
    Title3[HMR].update(module.default);
  });
}
var title_default3 = Title3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/trigger.svelte
Trigger9[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/anatomy/trigger.svelte";
var root_2143 = add_locations(from_html(`<button><!></button>`), Trigger9[FILENAME], [[24, 1]]);
function Trigger9($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger9);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const popover = RootContext14.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(popover().getTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger9, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2143();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger9, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger9,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger9 = hmr(Trigger9);
  import.meta.hot.accept((module) => {
    Trigger9[HMR].update(module.default);
  });
}
var trigger_default9 = Trigger9;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/popover/modules/anatomy.js
var Popover = Object.assign(root_default15, {
  Provider: root_provider_default13,
  Context: root_context_default13,
  Anchor: anchor_default,
  Trigger: trigger_default9,
  Positioner: positioner_default6,
  Content: content_default9,
  Arrow: arrow_default2,
  ArrowTip: arrow_tip_default2,
  Title: title_default3,
  Description: description_default2,
  CloseTrigger: close_trigger_default3
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/portal/anatomy/root.svelte
Root16[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/portal/anatomy/root.svelte";
function Root16($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root16);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const context = getAllContexts();
  const children = tag(user_derived(() => $$props.children), "children"), disabled = tag(user_derived(() => fallback($$props.disabled, false)), "disabled"), target = tag(user_derived(() => fallback($$props.target, () => strict_equals(typeof window, "undefined") ? void 0 : document.body, true)), "target");
  user_effect(() => {
    if (get(disabled) || !get(target)) {
      return;
    }
    const instance = mount(get(children), { target: get(target), context });
    return () => unmount(instance);
  });
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(children)), "render", Root16, 42, 1);
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(disabled) || !get(target)) $$render(consequent);
      }),
      "if",
      Root16,
      41,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root16 = hmr(Root16);
  import.meta.hot.accept((module) => {
    Root16[HMR].update(module.default);
  });
}
var root_default16 = Root16;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/portal/modules/anatomy.js
var Portal = root_default16;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/modules/root-context.js
var RootContext15 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/circle-range.svelte
Circle_range[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/circle-range.svelte";
var root_2144 = add_locations(from_svg(`<circle></circle>`), Circle_range[FILENAME], [[32, 1]]);
function Circle_range($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Circle_range);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const progress = RootContext15.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(progress().getCircleRangeProps(), { "stroke-linecap": "round" }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Circle_range, 30, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var circle = root_2144();
      attribute_effect(circle, () => ({ ...get(attributes) }));
      append($$anchor2, circle);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Circle_range,
      29,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Circle_range = hmr(Circle_range);
  import.meta.hot.accept((module) => {
    Circle_range[HMR].update(module.default);
  });
}
var circle_range_default = Circle_range;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/circle-track.svelte
Circle_track[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/circle-track.svelte";
var root_2145 = add_locations(from_svg(`<circle></circle>`), Circle_track[FILENAME], [[24, 1]]);
function Circle_track($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Circle_track);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const progress = RootContext15.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(progress().getCircleTrackProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Circle_track, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var circle = root_2145();
      attribute_effect(circle, () => ({ ...get(attributes) }));
      append($$anchor2, circle);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Circle_track,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Circle_track = hmr(Circle_track);
  import.meta.hot.accept((module) => {
    Circle_track[HMR].update(module.default);
  });
}
var circle_track_default = Circle_track;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/circle.svelte
Circle[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/circle.svelte";
var root_2146 = add_locations(from_svg(`<svg><!></svg>`), Circle[FILENAME], [[24, 1]]);
function Circle($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Circle);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const progress = RootContext15.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(progress().getCircleProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Circle, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var svg = root_2146();
      attribute_effect(svg, () => ({ ...get(attributes) }));
      var node_2 = child(svg);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Circle, 25, 2);
      reset(svg);
      append($$anchor2, svg);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Circle,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Circle = hmr(Circle);
  import.meta.hot.accept((module) => {
    Circle[HMR].update(module.default);
  });
}
var circle_default = Circle;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/label.svelte
Label6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/label.svelte";
var root_2147 = add_locations(from_html(`<div><!></div>`), Label6[FILENAME], [[24, 1]]);
function Label6($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const progress = RootContext15.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(progress().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label6, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2147();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label6, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label6,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label6 = hmr(Label6);
  import.meta.hot.accept((module) => {
    Label6[HMR].update(module.default);
  });
}
var label_default6 = Label6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/range.svelte
Range[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/range.svelte";
var root_2148 = add_locations(from_html(`<div><!></div>`), Range[FILENAME], [[24, 1]]);
function Range($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Range);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const progress = RootContext15.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(progress().getRangeProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Range, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2148();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Range, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Range,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Range = hmr(Range);
  import.meta.hot.accept((module) => {
    Range[HMR].update(module.default);
  });
}
var range_default = Range;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/root-context.svelte
Root_context14[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/root-context.svelte";
function Root_context14($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context14);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const progress = RootContext15.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => progress), "render", Root_context14, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context14 = hmr(Root_context14);
  import.meta.hot.accept((module) => {
    Root_context14[HMR].update(module.default);
  });
}
var root_context_default14 = Root_context14;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/root-provider.svelte
Root_provider14[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/root-provider.svelte";
var root_2149 = add_locations(from_html(`<div><!></div>`), Root_provider14[FILENAME], [[27, 1]]);
function Root_provider14($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider14);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), avatar = tag(user_derived(() => $$props.value), "avatar"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(avatar)().getRootProps(), get(rest))), "attributes");
  RootContext15.provide(() => get(avatar)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider14, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2149();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider14, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider14,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider14 = hmr(Root_provider14);
  import.meta.hot.accept((module) => {
    Root_provider14[HMR].update(module.default);
  });
}
var root_provider_default14 = Root_provider14;

// node_modules/@zag-js/progress/dist/index.mjs
var anatomy14 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts14 = anatomy14.build();
var getRootId10 = (ctx) => ctx.ids?.root ?? `progress-${ctx.id}`;
var getTrackId = (ctx) => ctx.ids?.track ?? `progress-${ctx.id}-track`;
var getLabelId5 = (ctx) => ctx.ids?.label ?? `progress-${ctx.id}-label`;
var getCircleId = (ctx) => ctx.ids?.circle ?? `progress-${ctx.id}-circle`;
function connect14(service, normalize2) {
  const { context, computed, prop, send, scope } = service;
  const percent = computed("percent");
  const percentAsString = computed("isIndeterminate") ? "" : computed("formatter").format(percent / 100);
  const max3 = prop("max");
  const min3 = prop("min");
  const orientation = prop("orientation");
  const translations = prop("translations");
  const indeterminate = computed("isIndeterminate");
  const value = context.get("value");
  const valueAsString = translations?.value({ value, max: max3, percent, min: min3, formatter: computed("formatter") }) ?? "";
  const progressState = getProgressState(value, max3);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max3,
    "aria-valuemin": min3,
    "aria-valuemax": max3,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps2 = getCircleProps(service);
  return {
    value,
    valueAsString,
    min: min3,
    max: max3,
    percent,
    percentAsString,
    indeterminate,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max3 });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: min3 });
    },
    getRootProps() {
      return normalize2.element({
        dir: prop("dir"),
        ...parts14.root.attrs,
        id: getRootId10(scope),
        "data-max": max3,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        dir: prop("dir"),
        id: getLabelId5(scope),
        ...parts14.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize2.element({
        dir: prop("dir"),
        "aria-live": "polite",
        ...parts14.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize2.element({
        dir: prop("dir"),
        id: getTrackId(scope),
        ...parts14.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize2.element({
        dir: prop("dir"),
        ...parts14.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [computed("isHorizontal") ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize2.element({
        dir: prop("dir"),
        id: getCircleId(scope),
        ...parts14.circle.attrs,
        ...progressbarProps,
        ...circleProps2.root
      });
    },
    getCircleTrackProps() {
      return normalize2.element({
        dir: prop("dir"),
        "data-orientation": orientation,
        ...parts14.circleTrack.attrs,
        ...circleProps2.track
      });
    },
    getCircleRangeProps() {
      return normalize2.element({
        dir: prop("dir"),
        ...parts14.circleRange.attrs,
        ...circleProps2.range,
        "data-state": progressState
      });
    },
    getViewProps(props25) {
      return normalize2.element({
        dir: prop("dir"),
        ...parts14.view.attrs,
        "data-state": props25.state,
        hidden: props25.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
var circleProps = {
  style: {
    "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
    cx: "calc(var(--size) / 2)",
    cy: "calc(var(--size) / 2)",
    r: "var(--radius)",
    fill: "transparent",
    strokeWidth: "var(--thickness)"
  }
};
var rootProps = {
  style: {
    width: "var(--size)",
    height: "var(--size)"
  }
};
function getCircleProps(service) {
  const { context, computed } = service;
  return {
    root: rootProps,
    track: circleProps,
    range: {
      opacity: context.get("value") === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": computed("percent"),
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: computed("isIndeterminate") ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
var machine14 = createMachine({
  props({ props: props25 }) {
    const min3 = props25.min ?? 0;
    const max3 = props25.max ?? 100;
    return {
      orientation: "horizontal",
      ...props25,
      max: max3,
      min: min3,
      defaultValue: props25.defaultValue !== void 0 ? props25.defaultValue : midValue(min3, max3),
      formatOptions: {
        style: "percent",
        ...props25.formatOptions
      },
      translations: {
        value: ({ value, percent, formatter }) => {
          if (value === null) return "loading...";
          if (formatter) {
            const formatOptions = formatter.resolvedOptions();
            const num = formatOptions.style === "percent" ? percent / 100 : value;
            return formatter.format(num);
          }
          return value.toString();
        },
        ...props25.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  entry: ["validateContext"],
  context({ bindable: bindable2, prop }) {
    return {
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      }))
    };
  },
  computed: {
    isIndeterminate: ({ context }) => context.get("value") === null,
    percent({ context, prop }) {
      const value = context.get("value");
      if (!isNumber(value)) return -1;
      return getValuePercent(value, prop("min"), prop("max")) * 100;
    },
    formatter: memo(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      ([locale, formatOptions]) => new Intl.NumberFormat(locale, formatOptions)
    ),
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal"
  },
  states: {
    idle: {
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setValue: ({ context, event, prop }) => {
        const value = event.value === null ? null : Math.max(0, Math.min(event.value, prop("max")));
        context.set("value", value);
      },
      validateContext: ({ context, prop }) => {
        const max3 = prop("max");
        const min3 = prop("min");
        const value = context.get("value");
        if (value == null) return;
        if (!isValidNumber(max3)) {
          throw new Error(`[progress] The max value passed \`${max3}\` is not a valid number`);
        }
        if (!isValidMax(value, max3)) {
          throw new Error(`[progress] The value passed \`${value}\` exceeds the max value \`${max3}\``);
        }
        if (!isValidMin(value, min3)) {
          throw new Error(`[progress] The value passed \`${value}\` exceeds the min value \`${min3}\``);
        }
      }
    }
  }
});
var isValidNumber = (max3) => isNumber(max3) && !isNaN(max3);
var isValidMax = (value, max3) => isValidNumber(value) && value <= max3;
var isValidMin = (value, min3) => isValidNumber(value) && value >= min3;
var midValue = (min3, max3) => min3 + (max3 - min3) / 2;
var props14 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value",
  "onValueChange",
  "defaultValue",
  "formatOptions",
  "locale"
]);
var splitProps15 = createSplitProps(props14);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/modules/provider.svelte.js
function useProgress(props25) {
  const service = useMachine(machine14, props25);
  const progress = tag(user_derived(() => connect14(service, normalizeProps)), "progress");
  return () => get(progress);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/root.svelte
Root17[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/root.svelte";
var root_2150 = add_locations(from_html(`<div><!></div>`), Root17[FILENAME], [[34, 1]]);
function Root17($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root17);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps15(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), progressProps = tag(user_derived(() => get($$array)[0]), "progressProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const avatar = useProgress(() => ({ ...get(progressProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(avatar().getRootProps(), get(rest))), "attributes");
  RootContext15.provide(() => avatar());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root17, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2150();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root17, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root17,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root17 = hmr(Root17);
  import.meta.hot.accept((module) => {
    Root17[HMR].update(module.default);
  });
}
var root_default17 = Root17;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/track.svelte
Track[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/track.svelte";
var root_2151 = add_locations(from_html(`<div><!></div>`), Track[FILENAME], [[24, 1]]);
function Track($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Track);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const progress = RootContext15.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(progress().getTrackProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Track, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2151();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Track, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Track,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Track = hmr(Track);
  import.meta.hot.accept((module) => {
    Track[HMR].update(module.default);
  });
}
var track_default = Track;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/value-text.svelte
Value_text[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/anatomy/value-text.svelte";
var root_2152 = add_locations(from_html(`<span><!></span>`), Value_text[FILENAME], [[24, 1]]);
function Value_text($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Value_text);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const progress = RootContext15.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(progress().getValueTextProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Value_text, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var span = root_2152();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Value_text, 26, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var text2 = text();
          template_effect(($0) => set_text(text2, $0), [() => progress().percentAsString]);
          append($$anchor3, text2);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if (get(children)) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Value_text,
          25,
          2
        );
      }
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Value_text,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Value_text = hmr(Value_text);
  import.meta.hot.accept((module) => {
    Value_text[HMR].update(module.default);
  });
}
var value_text_default = Value_text;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/progress/modules/anatomy.js
var Progress = Object.assign(root_default17, {
  Provider: root_provider_default14,
  Context: root_context_default14,
  Label: label_default6,
  ValueText: value_text_default,
  Track: track_default,
  Range: range_default,
  Circle: circle_default,
  CircleTrack: circle_track_default,
  CircleRange: circle_range_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/modules/root-context.js
var RootContext16 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/control.svelte
Control5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/control.svelte";
var root_2153 = add_locations(from_html(`<div><!></div>`), Control5[FILENAME], [[24, 1]]);
function Control5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const ratingGroup = RootContext16.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(ratingGroup().getControlProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Control5, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2153();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Control5, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Control5,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Control5 = hmr(Control5);
  import.meta.hot.accept((module) => {
    Control5[HMR].update(module.default);
  });
}
var control_default5 = Control5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/hidden-input.svelte
Hidden_input2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/hidden-input.svelte";
var root_2154 = add_locations(from_html(`<input/>`), Hidden_input2[FILENAME], [[24, 1]]);
function Hidden_input2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Hidden_input2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const ratingGroup = RootContext16.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(ratingGroup().getHiddenInputProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Hidden_input2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_2154();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Hidden_input2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Hidden_input2 = hmr(Hidden_input2);
  import.meta.hot.accept((module) => {
    Hidden_input2[HMR].update(module.default);
  });
}
var hidden_input_default2 = Hidden_input2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/star-empty.svelte
Star_empty[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/star-empty.svelte";
var root6 = add_locations(
  from_svg(`<svg><path stroke-linecap="round" stroke-linejoin="round" d="M11.48 3.499a.562.562 0 0 1 1.04 0l2.125 5.111a.563.563 0 0 0 .475.345
       l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 0 0-.182.557
       l1.285 5.385a.562.562 0 0 1-.84.61l-4.725-2.885a.562.562 0 0 0-.586 0
       L6.982 20.54a.562.562 0 0 1-.84-.61l1.285-5.386a.562.562 0 0 0-.182-.557
       l-4.204-3.602a.562.562 0 0 1 .321-.988l5.518-.442a.563.563 0 0 0 .475-.345
       L11.48 3.5Z"></path></svg>`),
  Star_empty[FILENAME],
  [[29, 0, [[30, 1]]]]
);
function Star_empty($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Star_empty);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const rest = tag(user_derived(() => exclude_from_object(props25, [])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        height: "24",
        width: "24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "1.5"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var svg = root6();
  attribute_effect(svg, () => ({ ...get(attributes) }));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Star_empty = hmr(Star_empty);
  import.meta.hot.accept((module) => {
    Star_empty[HMR].update(module.default);
  });
}
var star_empty_default = Star_empty;

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/star-full.svelte
Star_full[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/star-full.svelte";
var root7 = add_locations(
  from_svg(`<svg><path fill-rule="evenodd" clip-rule="evenodd" d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.006 
       5.404.434c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 
       1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 
       7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273 
       -4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.434 
       2.082-5.005Z"></path></svg>`),
  Star_full[FILENAME],
  [[27, 0, [[28, 1]]]]
);
function Star_full($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Star_full);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const rest = tag(user_derived(() => exclude_from_object(props25, [])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        height: "24",
        width: "24",
        fill: "currentColor"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var svg = root7();
  attribute_effect(svg, () => ({ ...get(attributes) }));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Star_full = hmr(Star_full);
  import.meta.hot.accept((module) => {
    Star_full[HMR].update(module.default);
  });
}
var star_full_default = Star_full;

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/star-half.svelte
Star_half[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/star-half.svelte";
var root8 = add_locations(
  from_svg(`<svg><defs><linearGradient id="half-fill" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="50%" stop-color="currentColor"></stop><stop offset="50%" stop-color="transparent"></stop></linearGradient></defs><path fill="url(#half-fill)" stroke-linecap="round" stroke-linejoin="round" d="M11.48 3.499a.562.562 0 0 1 1.04 0l2.125 5.111a.563.563 0 0 0 .475.345
       l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 0 0-.182.557
       l1.285 5.385a.562.562 0 0 1-.84.61l-4.725-2.885a.562.562 0 0 0-.586 0
       L6.982 20.54a.562.562 0 0 1-.84-.61l1.285-5.386a.562.562 0 0 0-.182-.557
       l-4.204-3.602a.562.562 0 0 1 .321-.988l5.518-.442a.563.563 0 0 0 .475-.345
       L11.48 3.5Z"></path></svg>`),
  Star_half[FILENAME],
  [[29, 0, [[30, 1, [[31, 2, [[32, 3], [33, 3]]]]], [36, 1]]]]
);
function Star_half($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Star_half);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const rest = tag(user_derived(() => exclude_from_object(props25, [])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        height: "24",
        width: "24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "1.5"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var svg = root8();
  attribute_effect(svg, () => ({ ...get(attributes) }));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  Star_half = hmr(Star_half);
  import.meta.hot.accept((module) => {
    Star_half[HMR].update(module.default);
  });
}
var star_half_default = Star_half;

// node_modules/@zag-js/rating-group/dist/index.mjs
var anatomy15 = createAnatomy("rating-group").parts("root", "label", "item", "control");
var parts15 = anatomy15.build();
var getRootId11 = (ctx) => ctx.ids?.root ?? `rating:${ctx.id}`;
var getLabelId6 = (ctx) => ctx.ids?.label ?? `rating:${ctx.id}:label`;
var getHiddenInputId2 = (ctx) => ctx.ids?.hiddenInput ?? `rating:${ctx.id}:input`;
var getControlId3 = (ctx) => ctx.ids?.control ?? `rating:${ctx.id}:control`;
var getItemId8 = (ctx, id) => ctx.ids?.item?.(id) ?? `rating:${ctx.id}:item:${id}`;
var getControlEl3 = (ctx) => ctx.getById(getControlId3(ctx));
var getRadioEl = (ctx, value) => {
  const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
  return query(getControlEl3(ctx), selector);
};
var getHiddenInputEl2 = (ctx) => ctx.getById(getHiddenInputId2(ctx));
var dispatchChangeEvent = (ctx, value) => {
  const inputEl = getHiddenInputEl2(ctx);
  if (!inputEl) return;
  dispatchInputValueEvent(inputEl, { value });
};
function connect15(service, normalize2) {
  const { context, send, prop, scope, computed } = service;
  const interactive = computed("isInteractive");
  const disabled = computed("isDisabled");
  const readOnly = !!prop("readOnly");
  const required = !!prop("required");
  const value = context.get("value");
  const hoveredValue = context.get("hoveredValue");
  const translations = prop("translations");
  function getItemState(props25) {
    const currentValue = computed("isHovering") ? hoveredValue : value;
    const equal = Math.ceil(currentValue) === props25.index;
    const highlighted = props25.index <= currentValue || equal;
    const half = equal && Math.abs(currentValue - props25.index) === 0.5;
    return {
      highlighted,
      half,
      checked: equal || value <= 0 && props25.index === 1
    };
  }
  return {
    hovering: computed("isHovering"),
    value,
    hoveredValue,
    count: prop("count"),
    items: Array.from({ length: prop("count") }).map((_, index) => index + 1),
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts15.root.attrs,
        dir: prop("dir"),
        id: getRootId11(scope)
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        name: prop("name"),
        form: prop("form"),
        type: "text",
        hidden: true,
        disabled,
        readOnly,
        required: prop("required"),
        id: getHiddenInputId2(scope),
        defaultValue: value
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts15.label.attrs,
        dir: prop("dir"),
        id: getLabelId6(scope),
        "data-disabled": dataAttr(disabled),
        "data-required": dataAttr(required),
        htmlFor: getHiddenInputId2(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          event.preventDefault();
          const radioEl = getRadioEl(scope, Math.max(1, context.get("value")));
          radioEl?.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        id: getControlId3(scope),
        ...parts15.control.attrs,
        dir: prop("dir"),
        role: "radiogroup",
        "aria-orientation": "horizontal",
        "aria-labelledby": getLabelId6(scope),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        onPointerMove(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send({ type: "GROUP_POINTER_OVER" });
        },
        onPointerLeave(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send({ type: "GROUP_POINTER_LEAVE" });
        }
      });
    },
    getItemState,
    getItemProps(props25) {
      const { index } = props25;
      const itemState = getItemState(props25);
      const valueText = translations.ratingValueText(index);
      return normalize2.element({
        ...parts15.item.attrs,
        dir: prop("dir"),
        id: getItemId8(scope, index.toString()),
        role: "radio",
        tabIndex: (() => {
          if (readOnly) return itemState.checked ? 0 : void 0;
          if (disabled) return void 0;
          return itemState.checked ? 0 : -1;
        })(),
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "aria-setsize": prop("count"),
        "aria-checked": itemState.checked,
        "data-checked": dataAttr(itemState.checked),
        "aria-posinset": index,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-half": dataAttr(itemState.half),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          event.preventDefault();
        },
        onPointerMove(event) {
          if (!interactive) return;
          const point = getEventPoint(event);
          const relativePoint = getRelativePoint(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: prop("dir")
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowLeft() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT" });
            },
            ArrowUp() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowDown() {
              send({ type: "ARROW_RIGHT" });
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        },
        onClick() {
          if (!interactive) return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS" });
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "BLUR" });
        }
      });
    }
  };
}
var machine15 = createMachine({
  props({ props: props25 }) {
    return {
      name: "rating",
      count: 5,
      dir: "ltr",
      defaultValue: -1,
      ...props25,
      translations: {
        ratingValueText: (index) => `${index} stars`,
        ...props25.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable: bindable2 }) {
    return {
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      hoveredValue: bindable2(() => ({
        defaultValue: -1,
        onChange(value) {
          prop("onHoverChange")?.({ hoveredValue: value });
        }
      })),
      fieldsetDisabled: bindable2(() => ({
        defaultValue: false
      }))
    };
  },
  watch({ track: track2, action, prop, context }) {
    track2([() => prop("allowHalf")], () => {
      action(["roundValueIfNeeded"]);
    });
    track2([() => context.get("value")], () => {
      action(["dispatchChangeEvent"]);
    });
  },
  computed: {
    isDisabled: ({ context, prop }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    isInteractive: ({ computed, prop }) => !(computed("isDisabled") || prop("readOnly")),
    isHovering: ({ context }) => context.get("hoveredValue") > -1
  },
  effects: ["trackFormControlState"],
  on: {
    SET_VALUE: {
      actions: ["setValue"]
    },
    CLEAR_VALUE: {
      actions: ["clearValue"]
    }
  },
  states: {
    idle: {
      entry: ["clearHoveredValue"],
      on: {
        GROUP_POINTER_OVER: {
          target: "hover"
        },
        FOCUS: {
          target: "focus"
        },
        CLICK: {
          actions: ["setValue", "focusActiveRadio"]
        }
      }
    },
    focus: {
      on: {
        POINTER_OVER: {
          actions: ["setHoveredValue"]
        },
        GROUP_POINTER_LEAVE: {
          actions: ["clearHoveredValue"]
        },
        BLUR: {
          target: "idle"
        },
        SPACE: {
          guard: "isValueEmpty",
          actions: ["setValue"]
        },
        CLICK: {
          actions: ["setValue", "focusActiveRadio"]
        },
        ARROW_LEFT: {
          actions: ["setPrevValue", "focusActiveRadio"]
        },
        ARROW_RIGHT: {
          actions: ["setNextValue", "focusActiveRadio"]
        },
        HOME: {
          actions: ["setValueToMin", "focusActiveRadio"]
        },
        END: {
          actions: ["setValueToMax", "focusActiveRadio"]
        }
      }
    },
    hover: {
      on: {
        POINTER_OVER: {
          actions: ["setHoveredValue"]
        },
        GROUP_POINTER_LEAVE: [
          {
            guard: "isRadioFocused",
            target: "focus",
            actions: ["clearHoveredValue"]
          },
          {
            target: "idle",
            actions: ["clearHoveredValue"]
          }
        ],
        CLICK: {
          actions: ["setValue", "focusActiveRadio"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isInteractive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
      isHoveredValueEmpty: ({ context }) => context.get("hoveredValue") === -1,
      isValueEmpty: ({ context }) => context.get("value") <= 0,
      isRadioFocused: ({ scope }) => !!getControlEl3(scope)?.contains(scope.getActiveElement())
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return trackFormControl(getHiddenInputEl2(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      }
    },
    actions: {
      clearHoveredValue({ context }) {
        context.set("hoveredValue", -1);
      },
      focusActiveRadio({ scope, context }) {
        raf(() => getRadioEl(scope, context.get("value"))?.focus());
      },
      setPrevValue({ context, prop }) {
        const factor = prop("allowHalf") ? 0.5 : 1;
        context.set("value", Math.max(0, context.get("value") - factor));
      },
      setNextValue({ context, prop }) {
        const factor = prop("allowHalf") ? 0.5 : 1;
        const value = context.get("value") === -1 ? 0 : context.get("value");
        context.set("value", Math.min(prop("count"), value + factor));
      },
      setValueToMin({ context }) {
        context.set("value", 1);
      },
      setValueToMax({ context, prop }) {
        context.set("value", prop("count"));
      },
      setValue({ context, event }) {
        const hoveredValue = context.get("hoveredValue");
        const value = hoveredValue === -1 ? event.value : hoveredValue;
        context.set("value", value);
      },
      clearValue({ context }) {
        context.set("value", -1);
      },
      setHoveredValue({ context, prop, event }) {
        const half = prop("allowHalf") && event.isMidway;
        const factor = half ? 0.5 : 0;
        context.set("hoveredValue", event.index - factor);
      },
      roundValueIfNeeded({ context, prop }) {
        if (prop("allowHalf")) return;
        context.set("value", Math.round(context.get("value")));
      },
      dispatchChangeEvent({ context, scope }) {
        dispatchChangeEvent(scope, context.get("value"));
      }
    }
  }
});
var props15 = createProps()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value",
  "defaultValue"
]);
var splitProps16 = createSplitProps(props15);
var itemProps8 = createProps()(["index"]);
var splitItemProps8 = createSplitProps(itemProps8);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/item.svelte
Item8[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/item.svelte";
var starEmpty = wrap_snippet(Item8, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => star_empty_default(node, {}), "component", Item8, 50, 1, { componentTag: "StarEmpty" });
  append($$anchor, fragment);
});
var starHalf = wrap_snippet(Item8, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment_1 = comment();
  var node_1 = first_child(fragment_1);
  add_svelte_meta(() => star_half_default(node_1, {}), "component", Item8, 54, 1, { componentTag: "StarHalf" });
  append($$anchor, fragment_1);
});
var starFull = wrap_snippet(Item8, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment_2 = comment();
  var node_2 = first_child(fragment_2);
  add_svelte_meta(() => star_full_default(node_2, {}), "component", Item8, 58, 1, { componentTag: "StarFull" });
  append($$anchor, fragment_2);
});
var root_5 = add_locations(from_html(`<div><!></div>`), Item8[FILENAME], [[64, 1]]);
function Item8($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item8);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const ratingGroup = RootContext16.consume();
  const $$d = user_derived(() => splitItemProps8(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), empty = tag(user_derived(() => fallback(get(componentProps).empty, starEmpty)), "empty"), half = tag(user_derived(() => fallback(get(componentProps).half, starHalf)), "half"), full = tag(user_derived(() => fallback(get(componentProps).full, starFull)), "full"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children", "empty", "half", "full"])), "rest");
  const itemState = tag(user_derived(() => ratingGroup().getItemState(get(itemProps13))), "itemState");
  const attributes = tag(user_derived(() => mergeProps2(ratingGroup().getItemProps(get(itemProps13)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_3 = comment();
  var node_3 = first_child(fragment_3);
  {
    var consequent = ($$anchor2) => {
      var fragment_4 = comment();
      var node_4 = first_child(fragment_4);
      add_svelte_meta(() => snippet(node_4, () => get(element2), () => get(attributes)), "render", Item8, 62, 1);
      append($$anchor2, fragment_4);
    };
    var alternate_3 = ($$anchor2) => {
      var div = root_5();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_5 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          add_svelte_meta(() => snippet(node_6, () => get(children)), "render", Item8, 66, 3);
          append($$anchor3, fragment_5);
        };
        var alternate_2 = ($$anchor3) => {
          var fragment_6 = comment();
          var node_7 = first_child(fragment_6);
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_7 = comment();
              var node_8 = first_child(fragment_7);
              add_svelte_meta(() => snippet(node_8, () => get(empty) ?? noop), "render", Item8, 68, 3);
              append($$anchor4, fragment_7);
            };
            var alternate_1 = ($$anchor4) => {
              var fragment_8 = comment();
              var node_9 = first_child(fragment_8);
              {
                var consequent_3 = ($$anchor5) => {
                  var fragment_9 = comment();
                  var node_10 = first_child(fragment_9);
                  add_svelte_meta(() => snippet(node_10, () => get(half) ?? noop), "render", Item8, 70, 3);
                  append($$anchor5, fragment_9);
                };
                var alternate = ($$anchor5) => {
                  var fragment_10 = comment();
                  var node_11 = first_child(fragment_10);
                  add_svelte_meta(() => snippet(node_11, () => get(full) ?? noop), "render", Item8, 72, 3);
                  append($$anchor5, fragment_10);
                };
                add_svelte_meta(
                  () => if_block(
                    node_9,
                    ($$render) => {
                      if (get(itemState).half) $$render(consequent_3);
                      else $$render(alternate, false);
                    },
                    true
                  ),
                  "if",
                  Item8,
                  69,
                  2
                );
              }
              append($$anchor4, fragment_8);
            };
            add_svelte_meta(
              () => if_block(
                node_7,
                ($$render) => {
                  if (!get(itemState).highlighted) $$render(consequent_2);
                  else $$render(alternate_1, false);
                },
                true
              ),
              "if",
              Item8,
              67,
              2
            );
          }
          append($$anchor3, fragment_6);
        };
        add_svelte_meta(
          () => if_block(node_5, ($$render) => {
            if (get(children)) $$render(consequent_1);
            else $$render(alternate_2, false);
          }),
          "if",
          Item8,
          65,
          2
        );
      }
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node_3, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate_3, false);
      }),
      "if",
      Item8,
      61,
      0
    );
  }
  append($$anchor, fragment_3);
  return pop($$exports);
}
if (import.meta.hot) {
  Item8 = hmr(Item8);
  import.meta.hot.accept((module) => {
    Item8[HMR].update(module.default);
  });
}
var item_default8 = Item8;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/label.svelte
Label7[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/label.svelte";
var root_2155 = add_locations(from_html(`<label><!></label>`), Label7[FILENAME], [[24, 1]]);
function Label7($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label7);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const ratingGroup = RootContext16.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(ratingGroup().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label7, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_2155();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label7, 25, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label7,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label7 = hmr(Label7);
  import.meta.hot.accept((module) => {
    Label7[HMR].update(module.default);
  });
}
var label_default7 = Label7;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/root-context.svelte
Root_context15[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/root-context.svelte";
function Root_context15($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context15);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const ratingGroup = RootContext16.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => ratingGroup), "render", Root_context15, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context15 = hmr(Root_context15);
  import.meta.hot.accept((module) => {
    Root_context15[HMR].update(module.default);
  });
}
var root_context_default15 = Root_context15;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/root-provider.svelte
Root_provider15[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/root-provider.svelte";
var root_2156 = add_locations(from_html(`<div><!></div>`), Root_provider15[FILENAME], [[27, 1]]);
function Root_provider15($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider15);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), ratingGroup = tag(user_derived(() => $$props.value), "ratingGroup"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(ratingGroup)().getRootProps(), get(rest))), "attributes");
  RootContext16.provide(() => get(ratingGroup)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider15, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2156();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider15, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider15,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider15 = hmr(Root_provider15);
  import.meta.hot.accept((module) => {
    Root_provider15[HMR].update(module.default);
  });
}
var root_provider_default15 = Root_provider15;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/modules/provider.svelte.js
function useRatingGroup(props25) {
  const service = useMachine(machine15, props25);
  const ratingGroup = tag(user_derived(() => connect15(service, normalizeProps)), "ratingGroup");
  return () => get(ratingGroup);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/root.svelte
Root18[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/anatomy/root.svelte";
var root_2157 = add_locations(from_html(`<div><!></div>`), Root18[FILENAME], [[34, 1]]);
function Root18($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root18);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps16(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), ratingGroupProps = tag(user_derived(() => get($$array)[0]), "ratingGroupProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const ratingGroup = useRatingGroup(() => ({ ...get(ratingGroupProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(ratingGroup().getRootProps(), get(rest))), "attributes");
  RootContext16.provide(() => ratingGroup());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root18, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2157();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root18, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root18,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root18 = hmr(Root18);
  import.meta.hot.accept((module) => {
    Root18[HMR].update(module.default);
  });
}
var root_default18 = Root18;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/rating-group/modules/anatomy.js
var RatingGroup = Object.assign(root_default18, {
  Provider: root_provider_default15,
  Context: root_context_default15,
  Label: label_default7,
  Control: control_default5,
  Item: item_default8,
  HiddenInput: hidden_input_default2
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/control.svelte
Control6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/control.svelte";
var root_2158 = add_locations(from_html(`<div><!></div>`), Control6[FILENAME], [[29, 1]]);
function Control6($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2({ "data-scope": "radio-group", "data-part": "control" }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Control6, 27, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2158();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Control6, 30, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Control6,
      26,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Control6 = hmr(Control6);
  import.meta.hot.accept((module) => {
    Control6[HMR].update(module.default);
  });
}
var control_default6 = Control6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/modules/root-context.js
var RootContext17 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/indicator.svelte
Indicator4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/indicator.svelte";
var root_2159 = add_locations(from_html(`<div></div>`), Indicator4[FILENAME], [[24, 1]]);
function Indicator4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Indicator4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const segmentedControl = RootContext17.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(segmentedControl().getIndicatorProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Indicator4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2159();
      attribute_effect(div, () => ({ ...get(attributes) }));
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Indicator4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Indicator4 = hmr(Indicator4);
  import.meta.hot.accept((module) => {
    Indicator4[HMR].update(module.default);
  });
}
var indicator_default4 = Indicator4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/modules/item-context.js
var ItemContext6 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/item-hidden-input.svelte
Item_hidden_input[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/item-hidden-input.svelte";
var root_2160 = add_locations(from_html(`<input/>`), Item_hidden_input[FILENAME], [[26, 1]]);
function Item_hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_hidden_input);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const segmentedcontrol = RootContext17.consume();
  const itemProps13 = ItemContext6.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(segmentedcontrol().getItemHiddenInputProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_hidden_input, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_2160();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_hidden_input,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_hidden_input = hmr(Item_hidden_input);
  import.meta.hot.accept((module) => {
    Item_hidden_input[HMR].update(module.default);
  });
}
var item_hidden_input_default = Item_hidden_input;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/item-text.svelte
Item_text4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/item-text.svelte";
var root_2161 = add_locations(from_html(`<span><!></span>`), Item_text4[FILENAME], [[26, 1]]);
function Item_text4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_text4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const segmentedcontrol = RootContext17.consume();
  const itemProps13 = ItemContext6.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(segmentedcontrol().getItemTextProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_text4, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2161();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_text4, 27, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_text4,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_text4 = hmr(Item_text4);
  import.meta.hot.accept((module) => {
    Item_text4[HMR].update(module.default);
  });
}
var item_text_default4 = Item_text4;

// node_modules/@zag-js/radio-group/dist/index.mjs
var anatomy16 = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts16 = anatomy16.build();
var getRootId12 = (ctx) => ctx.ids?.root ?? `radio-group:${ctx.id}`;
var getLabelId7 = (ctx) => ctx.ids?.label ?? `radio-group:${ctx.id}:label`;
var getItemId9 = (ctx, value) => ctx.ids?.item?.(value) ?? `radio-group:${ctx.id}:radio:${value}`;
var getItemHiddenInputId = (ctx, value) => ctx.ids?.itemHiddenInput?.(value) ?? `radio-group:${ctx.id}:radio:input:${value}`;
var getItemControlId = (ctx, value) => ctx.ids?.itemControl?.(value) ?? `radio-group:${ctx.id}:radio:control:${value}`;
var getItemLabelId = (ctx, value) => ctx.ids?.itemLabel?.(value) ?? `radio-group:${ctx.id}:radio:label:${value}`;
var getIndicatorId2 = (ctx) => ctx.ids?.indicator ?? `radio-group:${ctx.id}:indicator`;
var getRootEl4 = (ctx) => ctx.getById(getRootId12(ctx));
var getItemHiddenInputEl = (ctx, value) => ctx.getById(getItemHiddenInputId(ctx, value));
var getIndicatorEl2 = (ctx) => ctx.getById(getIndicatorId2(ctx));
var getFirstEnabledInputEl = (ctx) => getRootEl4(ctx)?.querySelector("input:not(:disabled)");
var getFirstEnabledAndCheckedInputEl = (ctx) => getRootEl4(ctx)?.querySelector("input:not(:disabled):checked");
var getInputEls2 = (ctx) => {
  const ownerId = CSS.escape(getRootId12(ctx));
  const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
  return queryAll(getRootEl4(ctx), selector);
};
var getRadioEl2 = (ctx, value) => {
  if (!value) return;
  return ctx.getById(getItemId9(ctx, value));
};
var getOffsetRect = (el) => ({
  x: el?.offsetLeft ?? 0,
  y: el?.offsetTop ?? 0,
  width: el?.offsetWidth ?? 0,
  height: el?.offsetHeight ?? 0
});
function connect16(service, normalize2) {
  const { context, send, computed, prop, scope } = service;
  const groupDisabled = computed("isDisabled");
  const groupInvalid = prop("invalid");
  const readOnly = prop("readOnly");
  function getItemState(props25) {
    return {
      value: props25.value,
      invalid: !!props25.invalid || !!groupInvalid,
      disabled: !!props25.disabled || groupDisabled,
      checked: context.get("value") === props25.value,
      focused: context.get("focusedValue") === props25.value,
      focusVisible: context.get("focusVisibleValue") === props25.value,
      hovered: context.get("hoveredValue") === props25.value,
      active: context.get("activeValue") === props25.value
    };
  }
  function getItemDataAttrs(props25) {
    const itemState = getItemState(props25);
    return {
      "data-focus": dataAttr(itemState.focused),
      "data-focus-visible": dataAttr(itemState.focusVisible),
      "data-disabled": dataAttr(itemState.disabled),
      "data-readonly": dataAttr(readOnly),
      "data-state": itemState.checked ? "checked" : "unchecked",
      "data-hover": dataAttr(itemState.hovered),
      "data-invalid": dataAttr(itemState.invalid),
      "data-orientation": prop("orientation"),
      "data-ssr": dataAttr(context.get("ssr"))
    };
  }
  const focus = () => {
    const nodeToFocus = getFirstEnabledAndCheckedInputEl(scope) ?? getFirstEnabledInputEl(scope);
    nodeToFocus?.focus();
  };
  return {
    focus,
    value: context.get("value"),
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    getRootProps() {
      return normalize2.element({
        ...parts16.root.attrs,
        role: "radiogroup",
        id: getRootId12(scope),
        "aria-labelledby": getLabelId7(scope),
        "aria-required": prop("required") || void 0,
        "aria-disabled": groupDisabled || void 0,
        "aria-readonly": readOnly || void 0,
        "data-orientation": prop("orientation"),
        "data-disabled": dataAttr(groupDisabled),
        "data-invalid": dataAttr(groupInvalid),
        "data-required": dataAttr(prop("required")),
        "aria-orientation": prop("orientation"),
        dir: prop("dir"),
        style: {
          position: "relative"
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts16.label.attrs,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-disabled": dataAttr(groupDisabled),
        "data-invalid": dataAttr(groupInvalid),
        "data-required": dataAttr(prop("required")),
        id: getLabelId7(scope),
        onClick: focus
      });
    },
    getItemState,
    getItemProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.label({
        ...parts16.item.attrs,
        dir: prop("dir"),
        id: getItemId9(scope, props25.value),
        htmlFor: getItemHiddenInputId(scope, props25.value),
        ...getItemDataAttrs(props25),
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.hovered) return;
          send({ type: "SET_HOVERED", value: props25.value, hovered: true });
        },
        onPointerLeave() {
          if (itemState.disabled) return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (itemState.disabled) return;
          if (!isLeftClick(event)) return;
          if (itemState.focused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props25.value, active: true });
        },
        onPointerUp() {
          if (itemState.disabled) return;
          send({ type: "SET_ACTIVE", value: null });
        },
        onClick() {
          if (!itemState.disabled && isSafari()) {
            getItemHiddenInputEl(scope, props25.value)?.focus();
          }
        }
      });
    },
    getItemTextProps(props25) {
      return normalize2.element({
        ...parts16.itemText.attrs,
        dir: prop("dir"),
        id: getItemLabelId(scope, props25.value),
        ...getItemDataAttrs(props25)
      });
    },
    getItemControlProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts16.itemControl.attrs,
        dir: prop("dir"),
        id: getItemControlId(scope, props25.value),
        "data-active": dataAttr(itemState.active),
        "aria-hidden": true,
        ...getItemDataAttrs(props25)
      });
    },
    getItemHiddenInputProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.input({
        "data-ownedby": getRootId12(scope),
        id: getItemHiddenInputId(scope, props25.value),
        type: "radio",
        name: prop("name") || prop("id"),
        form: prop("form"),
        value: props25.value,
        required: prop("required"),
        "aria-invalid": itemState.invalid || void 0,
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          if (event.currentTarget.checked) {
            send({ type: "SET_VALUE", value: props25.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null, focused: false, focusVisible: false });
        },
        onFocus() {
          const focusVisible = isFocusVisible();
          send({ type: "SET_FOCUSED", value: props25.value, focused: true, focusVisible });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props25.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: itemState.disabled || readOnly,
        defaultChecked: itemState.checked,
        style: visuallyHiddenStyle
      });
    },
    getIndicatorProps() {
      const rect = context.get("indicatorRect");
      const rectIsEmpty = rect == null || rect.width === 0 && rect.height === 0 && rect.x === 0 && rect.y === 0;
      return normalize2.element({
        id: getIndicatorId2(scope),
        ...parts16.indicator.attrs,
        dir: prop("dir"),
        hidden: context.get("value") == null || rectIsEmpty,
        "data-disabled": dataAttr(groupDisabled),
        "data-orientation": prop("orientation"),
        style: {
          "--transition-property": "left, top, width, height",
          "--left": toPx(rect?.x),
          "--top": toPx(rect?.y),
          "--width": toPx(rect?.width),
          "--height": toPx(rect?.height),
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: "var(--transition-duration, 150ms)",
          transitionTimingFunction: "var(--transition-timing-function)",
          [prop("orientation") === "horizontal" ? "left" : "top"]: prop("orientation") === "horizontal" ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not5 } = createGuards();
var machine16 = createMachine({
  props({ props: props25 }) {
    return {
      orientation: "vertical",
      ...props25
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable: bindable2 }) {
    return {
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      activeValue: bindable2(() => ({
        defaultValue: null
      })),
      focusedValue: bindable2(() => ({
        defaultValue: null
      })),
      focusVisibleValue: bindable2(() => ({
        defaultValue: null
      })),
      hoveredValue: bindable2(() => ({
        defaultValue: null
      })),
      indicatorRect: bindable2(() => ({
        defaultValue: null
      })),
      fieldsetDisabled: bindable2(() => ({
        defaultValue: false
      })),
      ssr: bindable2(() => ({
        defaultValue: true
      }))
    };
  },
  refs() {
    return {
      indicatorCleanup: null,
      focusVisibleValue: null
    };
  },
  computed: {
    isDisabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled")
  },
  entry: ["syncIndicatorRect", "syncSsr"],
  exit: ["cleanupObserver"],
  effects: ["trackFormControlState", "trackFocusVisible"],
  watch({ track: track2, action, context }) {
    track2([() => context.get("value")], () => {
      action(["syncIndicatorRect", "syncInputElements"]);
    });
  },
  on: {
    SET_VALUE: [
      {
        guard: not5("isTrusted"),
        actions: ["setValue", "dispatchChangeEvent"]
      },
      {
        actions: ["setValue"]
      }
    ],
    SET_HOVERED: {
      actions: ["setHovered"]
    },
    SET_ACTIVE: {
      actions: ["setActive"]
    },
    SET_FOCUSED: {
      actions: ["setFocused"]
    }
  },
  states: {
    idle: {}
  },
  implementations: {
    guards: {
      isTrusted: ({ event }) => !!event.isTrusted
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return trackFormControl(getRootEl4(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      trackFocusVisible({ scope }) {
        return trackFocusVisible({ root: scope.getRootNode?.() });
      }
    },
    actions: {
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      setHovered({ context, event }) {
        context.set("hoveredValue", event.value);
      },
      setActive({ context, event }) {
        context.set("activeValue", event.value);
      },
      setFocused({ context, event }) {
        context.set("focusedValue", event.value);
        const focusVisibleValue = event.value != null && event.focusVisible ? event.value : null;
        context.set("focusVisibleValue", focusVisibleValue);
      },
      syncInputElements({ context, scope }) {
        const inputs = getInputEls2(scope);
        inputs.forEach((input) => {
          input.checked = input.value === context.get("value");
        });
      },
      cleanupObserver({ refs }) {
        refs.get("indicatorCleanup")?.();
      },
      syncSsr({ context }) {
        context.set("ssr", false);
      },
      syncIndicatorRect({ context, scope, refs }) {
        refs.get("indicatorCleanup")?.();
        if (!getIndicatorEl2(scope)) return;
        const value = context.get("value");
        const radioEl = getRadioEl2(scope, value);
        if (value == null || !radioEl) {
          context.set("indicatorRect", null);
          return;
        }
        const exec = () => {
          context.set("indicatorRect", getOffsetRect(radioEl));
        };
        exec();
        const indicatorCleanup = resizeObserverBorderBox.observe(radioEl, exec);
        refs.set("indicatorCleanup", indicatorCleanup);
      },
      dispatchChangeEvent({ context, scope }) {
        const inputEls = getInputEls2(scope);
        inputEls.forEach((inputEl) => {
          const checked = inputEl.value === context.get("value");
          if (checked === inputEl.checked) return;
          dispatchInputCheckedEvent(inputEl, { checked });
        });
      }
    }
  }
});
var props16 = createProps()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "required",
  "value",
  "defaultValue"
]);
var splitProps17 = createSplitProps(props16);
var itemProps9 = createProps()(["value", "disabled", "invalid"]);
var splitItemProps9 = createSplitProps(itemProps9);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/item.svelte
Item9[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/item.svelte";
var root_2162 = add_locations(from_html(`<label><!></label>`), Item9[FILENAME], [[30, 1]]);
function Item9($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item9);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const segmentedControl = RootContext17.consume();
  const $$d = user_derived(() => splitItemProps9(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(segmentedControl().getItemProps(get(itemProps13)), get(rest))), "attributes");
  ItemContext6.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item9, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_2162();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item9, 31, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item9,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item9 = hmr(Item9);
  import.meta.hot.accept((module) => {
    Item9[HMR].update(module.default);
  });
}
var item_default9 = Item9;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/label.svelte
Label8[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/label.svelte";
var root_2163 = add_locations(from_html(`<span><!></span>`), Label8[FILENAME], [[24, 1]]);
function Label8($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label8);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const segmentedControl = RootContext17.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(segmentedControl().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label8, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2163();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label8, 24, 23);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label8,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label8 = hmr(Label8);
  import.meta.hot.accept((module) => {
    Label8[HMR].update(module.default);
  });
}
var label_default8 = Label8;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/root-context.svelte
Root_context16[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/root-context.svelte";
function Root_context16($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context16);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const segmentedControl = RootContext17.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => segmentedControl), "render", Root_context16, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context16 = hmr(Root_context16);
  import.meta.hot.accept((module) => {
    Root_context16[HMR].update(module.default);
  });
}
var root_context_default16 = Root_context16;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/root-provider.svelte
Root_provider16[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/root-provider.svelte";
var root_2164 = add_locations(from_html(`<div><!></div>`), Root_provider16[FILENAME], [[27, 1]]);
function Root_provider16($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider16);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), segmentedControl = tag(user_derived(() => $$props.value), "segmentedControl"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(segmentedControl)().getRootProps(), get(rest))), "attributes");
  RootContext17.provide(() => get(segmentedControl)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider16, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2164();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider16, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider16,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider16 = hmr(Root_provider16);
  import.meta.hot.accept((module) => {
    Root_provider16[HMR].update(module.default);
  });
}
var root_provider_default16 = Root_provider16;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/modules/provider.svelte.js
function useSegmentedControl(props25) {
  const service = useMachine(machine16, () => ({
    orientation: "horizontal",
    ...strict_equals(typeof props25, "function") ? props25() : props25
  }));
  const segmentedControl = tag(user_derived(() => connect16(service, normalizeProps)), "segmentedControl");
  return () => get(segmentedControl);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/root.svelte
Root19[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/anatomy/root.svelte";
var root_2165 = add_locations(from_html(`<div><!></div>`), Root19[FILENAME], [[34, 1]]);
function Root19($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root19);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps17(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), segmentedControlProps = tag(user_derived(() => get($$array)[0]), "segmentedControlProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const segmentedControl = useSegmentedControl(() => ({ ...get(segmentedControlProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(segmentedControl().getRootProps(), get(rest))), "attributes");
  RootContext17.provide(() => segmentedControl());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root19, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2165();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root19, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root19,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root19 = hmr(Root19);
  import.meta.hot.accept((module) => {
    Root19[HMR].update(module.default);
  });
}
var root_default19 = Root19;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/segmented-control/modules/anatomy.js
var SegmentedControl = Object.assign(root_default19, {
  Provider: root_provider_default16,
  Context: root_context_default16,
  Label: label_default8,
  Control: control_default6,
  Indicator: indicator_default4,
  Item: item_default9,
  ItemText: item_text_default4,
  ItemHiddenInput: item_hidden_input_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/modules/root-context.js
var RootContext18 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/control.svelte
Control7[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/control.svelte";
var root_2166 = add_locations(from_html(`<div><!></div>`), Control7[FILENAME], [[24, 1]]);
function Control7($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control7);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(slider().getControlProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Control7, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2166();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Control7, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Control7,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Control7 = hmr(Control7);
  import.meta.hot.accept((module) => {
    Control7[HMR].update(module.default);
  });
}
var control_default7 = Control7;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/modules/thumb-context.js
var ThumbContext = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/hidden-input.svelte
Hidden_input3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/hidden-input.svelte";
var root_2167 = add_locations(from_html(`<input/>`), Hidden_input3[FILENAME], [[26, 1]]);
function Hidden_input3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Hidden_input3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const thumbProps2 = ThumbContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(slider().getHiddenInputProps(thumbProps2()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Hidden_input3, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_2167();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Hidden_input3,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Hidden_input3 = hmr(Hidden_input3);
  import.meta.hot.accept((module) => {
    Hidden_input3[HMR].update(module.default);
  });
}
var hidden_input_default3 = Hidden_input3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/label.svelte
Label9[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/label.svelte";
var root_2168 = add_locations(from_html(`<label><!></label>`), Label9[FILENAME], [[24, 1]]);
function Label9($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label9);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(slider().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label9, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_2168();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label9, 25, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label9,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label9 = hmr(Label9);
  import.meta.hot.accept((module) => {
    Label9[HMR].update(module.default);
  });
}
var label_default9 = Label9;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/marker-group.svelte
Marker_group[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/marker-group.svelte";
var root_2169 = add_locations(from_html(`<div><!></div>`), Marker_group[FILENAME], [[24, 1]]);
function Marker_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Marker_group);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(slider().getMarkerGroupProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Marker_group, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2169();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Marker_group, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Marker_group,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Marker_group = hmr(Marker_group);
  import.meta.hot.accept((module) => {
    Marker_group[HMR].update(module.default);
  });
}
var marker_group_default = Marker_group;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/marker.svelte
Marker[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/marker.svelte";
var root_2170 = add_locations(from_html(`<div><!></div>`), Marker[FILENAME], [[25, 1]]);
function Marker($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Marker);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), value = tag(user_derived(() => $$props.value), "value"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(slider().getMarkerProps({ value: get(value) }), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Marker, 23, 1);
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var div = root_2170();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => get(children)), "render", Marker, 27, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, get(value)));
          append($$anchor3, text2);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if (get(children)) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Marker,
          26,
          2
        );
      }
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Marker,
      22,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Marker = hmr(Marker);
  import.meta.hot.accept((module) => {
    Marker[HMR].update(module.default);
  });
}
var marker_default = Marker;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/range.svelte
Range2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/range.svelte";
var root_2171 = add_locations(from_html(`<div><!></div>`), Range2[FILENAME], [[24, 1]]);
function Range2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Range2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(slider().getRangeProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Range2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2171();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Range2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Range2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Range2 = hmr(Range2);
  import.meta.hot.accept((module) => {
    Range2[HMR].update(module.default);
  });
}
var range_default2 = Range2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/root-context.svelte
Root_context17[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/root-context.svelte";
function Root_context17($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context17);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => slider), "render", Root_context17, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context17 = hmr(Root_context17);
  import.meta.hot.accept((module) => {
    Root_context17[HMR].update(module.default);
  });
}
var root_context_default17 = Root_context17;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/root-provider.svelte
Root_provider17[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/root-provider.svelte";
var root_2172 = add_locations(from_html(`<div><!></div>`), Root_provider17[FILENAME], [[27, 1]]);
function Root_provider17($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider17);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), slider = tag(user_derived(() => $$props.value), "slider"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(slider)().getRootProps(), get(rest))), "attributes");
  RootContext18.provide(() => get(slider)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider17, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2172();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider17, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider17,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider17 = hmr(Root_provider17);
  import.meta.hot.accept((module) => {
    Root_provider17[HMR].update(module.default);
  });
}
var root_provider_default17 = Root_provider17;

// node_modules/@zag-js/slider/dist/index.mjs
var anatomy17 = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker",
  "draggingIndicator"
);
var parts17 = anatomy17.build();
var getRootId13 = (ctx) => ctx.ids?.root ?? `slider:${ctx.id}`;
var getThumbId = (ctx, index) => ctx.ids?.thumb?.(index) ?? `slider:${ctx.id}:thumb:${index}`;
var getHiddenInputId3 = (ctx, index) => ctx.ids?.hiddenInput?.(index) ?? `slider:${ctx.id}:input:${index}`;
var getControlId4 = (ctx) => ctx.ids?.control ?? `slider:${ctx.id}:control`;
var getTrackId2 = (ctx) => ctx.ids?.track ?? `slider:${ctx.id}:track`;
var getRangeId = (ctx) => ctx.ids?.range ?? `slider:${ctx.id}:range`;
var getLabelId8 = (ctx) => ctx.ids?.label ?? `slider:${ctx.id}:label`;
var getValueTextId = (ctx) => ctx.ids?.valueText ?? `slider:${ctx.id}:value-text`;
var getMarkerId = (ctx, value) => ctx.ids?.marker?.(value) ?? `slider:${ctx.id}:marker:${value}`;
var getRootEl5 = (ctx) => ctx.getById(getRootId13(ctx));
var getThumbEl = (ctx, index) => ctx.getById(getThumbId(ctx, index));
var getThumbEls = (ctx) => queryAll(getControlEl4(ctx), "[role=slider]");
var getFirstThumbEl = (ctx) => getThumbEls(ctx)[0];
var getHiddenInputEl3 = (ctx, index) => ctx.getById(getHiddenInputId3(ctx, index));
var getControlEl4 = (ctx) => ctx.getById(getControlId4(ctx));
var getPointValue = (params, point) => {
  const { prop, scope, refs } = params;
  const controlEl = getControlEl4(scope);
  if (!controlEl) return;
  const offset2 = refs.get("thumbDragOffset");
  const adjustedPoint = {
    x: point.x - (offset2?.x ?? 0),
    y: point.y - (offset2?.y ?? 0)
  };
  const relativePoint = getRelativePoint(adjustedPoint, controlEl);
  const percent = relativePoint.getPercentValue({
    orientation: prop("orientation"),
    dir: prop("dir"),
    inverted: { y: true }
  });
  return getPercentValue(percent, prop("min"), prop("max"), prop("step"));
};
var dispatchChangeEvent2 = (ctx, value) => {
  value.forEach((value2, index) => {
    const inputEl = getHiddenInputEl3(ctx, index);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: value2 });
  });
};
var getOffsetRect2 = (el) => ({
  left: el?.offsetLeft ?? 0,
  top: el?.offsetTop ?? 0,
  width: el?.offsetWidth ?? 0,
  height: el?.offsetHeight ?? 0
});
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(params) {
  const { prop, computed } = params;
  const valuePercent = computed("valuePercent");
  const [firstPercent, lastPercent] = getBounds(valuePercent);
  if (valuePercent.length === 1) {
    if (prop("origin") === "center") {
      const isNegative = valuePercent[0] < 50;
      const start = isNegative ? `${valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - valuePercent[0]}%`;
      return { start, end };
    }
    if (prop("origin") === "end") {
      return { start: `${lastPercent}%`, end: "0%" };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(params) {
  const { computed } = params;
  const isVertical = computed("isVertical");
  const isRtl = computed("isRtl");
  if (isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(params, value) {
  const { context, prop } = params;
  const { height = 0 } = context.get("thumbSize") ?? {};
  const getValue = getValueTransformer([prop("min"), prop("max")], [-height / 2, height / 2]);
  return parseFloat(getValue(value).toFixed(2));
}
function getHorizontalThumbOffset(params, value) {
  const { computed, context, prop } = params;
  const { width = 0 } = context.get("thumbSize") ?? {};
  const isRtl = computed("isRtl");
  if (isRtl) {
    const getValue2 = getValueTransformer([prop("max"), prop("min")], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(value).toFixed(2));
  }
  const getValue = getValueTransformer([prop("min"), prop("max")], [-width / 2, width / 2]);
  return parseFloat(getValue(value).toFixed(2));
}
function getOffset(params, percent, value) {
  const { computed, prop } = params;
  if (prop("thumbAlignment") === "center") return `${percent}%`;
  const offset2 = computed("isVertical") ? getVerticalThumbOffset(params, value) : getHorizontalThumbOffset(params, value);
  return `calc(${percent}% - ${offset2}px)`;
}
function getThumbOffset(params, value) {
  const { prop } = params;
  const percent = getValuePercent(value, prop("min"), prop("max")) * 100;
  return getOffset(params, percent, value);
}
function getVisibility(params) {
  const { computed, prop } = params;
  let visibility = "visible";
  if (prop("thumbAlignment") === "contain" && !computed("hasMeasuredThumbSize")) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(params, index) {
  const { computed, context } = params;
  const placementProp = computed("isVertical") ? "bottom" : "insetInlineStart";
  const focusedIndex = context.get("focusedIndex");
  return {
    visibility: getVisibility(params),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`,
    zIndex: focusedIndex === index ? 1 : void 0
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle(params) {
  const { context, computed } = params;
  const isVertical = computed("isVertical");
  const isRtl = computed("isRtl");
  const range2 = getRangeOffsets(params);
  const thumbSize = context.get("thumbSize");
  const offsetStyles = context.get("value").reduce((styles, value, index) => {
    const offset2 = getThumbOffset(params, value);
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset2 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-width": toPx(thumbSize?.width),
    "--slider-thumb-height": toPx(thumbSize?.height),
    "--slider-thumb-transform": isVertical ? "translateY(50%)" : isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range2.start,
    "--slider-range-end": range2.end
  };
}
function getMarkerStyle(params, value) {
  const { computed } = params;
  const isHorizontal = computed("isHorizontal");
  const isRtl = computed("isRtl");
  return {
    visibility: getVisibility(params),
    position: "absolute",
    pointerEvents: "none",
    [isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset(params, value),
    translate: "var(--translate-x) var(--translate-y)",
    "--translate-x": isHorizontal ? isRtl ? "50%" : "-50%" : "0%",
    "--translate-y": !isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
function normalizeValues(params, nextValues) {
  return nextValues.map((value, index) => {
    return constrainValue2(params, value, index);
  });
}
function getRangeAtIndex(params, index) {
  const { context, prop } = params;
  const step = prop("step") * prop("minStepsBetweenThumbs");
  return getValueRanges(context.get("value"), prop("min"), prop("max"), step)[index];
}
function constrainValue2(params, value, index) {
  const { prop } = params;
  const range2 = getRangeAtIndex(params, index);
  const snapValue = snapValueToStep(value, prop("min"), prop("max"), prop("step"));
  return clampValue(snapValue, range2.min, range2.max);
}
function decrement(params, index, step) {
  const { context, prop } = params;
  const idx = index ?? context.get("focusedIndex");
  const range2 = getRangeAtIndex(params, idx);
  const nextValues = getPreviousStepValue(idx, {
    ...range2,
    step: step ?? prop("step"),
    values: context.get("value")
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function increment(params, index, step) {
  const { context, prop } = params;
  const idx = index ?? context.get("focusedIndex");
  const range2 = getRangeAtIndex(params, idx);
  const nextValues = getNextStepValue(idx, {
    ...range2,
    step: step ?? prop("step"),
    values: context.get("value")
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function getClosestIndex(params, pointValue) {
  const { context } = params;
  const values = context.get("value");
  let closestIndex = 0;
  let minDistance = Math.abs(values[0] - pointValue);
  for (let i = 1; i < values.length; i++) {
    const distance = Math.abs(values[i] - pointValue);
    if (distance <= minDistance) {
      closestIndex = i;
      minDistance = distance;
    }
  }
  return selectMovableThumb(params, closestIndex);
}
function selectMovableThumb(params, index) {
  const { context, prop } = params;
  const values = context.get("value");
  const max3 = prop("max");
  const thumbValue = values[index];
  if (thumbValue === max3) {
    let movableIndex = index;
    while (movableIndex > 0 && values[movableIndex - 1] === max3) {
      movableIndex -= 1;
    }
    return movableIndex;
  }
  return index;
}
function connect17(service, normalize2) {
  const { state: state3, send, context, prop, computed, scope } = service;
  const ariaLabel = prop("aria-label");
  const ariaLabelledBy = prop("aria-labelledby");
  const sliderValue = context.get("value");
  const focusedIndex = context.get("focusedIndex");
  const focused = state3.matches("focus");
  const dragging = state3.matches("dragging");
  const disabled = computed("isDisabled");
  const invalid = prop("invalid");
  const interactive = computed("isInteractive");
  const isHorizontal = prop("orientation") === "horizontal";
  const isVertical = prop("orientation") === "vertical";
  function getValuePercentFn(value) {
    return getValuePercent(value, prop("min"), prop("max"));
  }
  function getPercentValueFn(percent) {
    return getPercentValue(percent, prop("min"), prop("max"), prop("step"));
  }
  return {
    value: sliderValue,
    dragging,
    focused,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    getThumbValue(index) {
      return sliderValue[index];
    },
    setThumbValue(index, value) {
      send({ type: "SET_VALUE", index, value });
    },
    getValuePercent: getValuePercentFn,
    getPercentValue: getPercentValueFn,
    getThumbPercent(index) {
      return getValuePercentFn(sliderValue[index]);
    },
    setThumbPercent(index, percent) {
      const value = getPercentValueFn(percent);
      send({ type: "SET_VALUE", index, value });
    },
    getThumbMin(index) {
      return getRangeAtIndex(service, index).min;
    },
    getThumbMax(index) {
      return getRangeAtIndex(service, index).max;
    },
    increment(index) {
      send({ type: "INCREMENT", index });
    },
    decrement(index) {
      send({ type: "DECREMENT", index });
    },
    focus() {
      if (!interactive) return;
      send({ type: "FOCUS", index: 0 });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts17.label.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        id: getLabelId8(scope),
        htmlFor: getHiddenInputId3(scope, 0),
        onClick(event) {
          if (!interactive) return;
          event.preventDefault();
          getFirstThumbEl(scope)?.focus();
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getRootProps() {
      return normalize2.element({
        ...parts17.root.attrs,
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-dragging": dataAttr(dragging),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: getRootId13(scope),
        dir: prop("dir"),
        style: getRootStyle(service)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts17.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: getValueTextId(scope)
      });
    },
    getTrackProps() {
      return normalize2.element({
        ...parts17.track.attrs,
        dir: prop("dir"),
        id: getTrackId2(scope),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-orientation": prop("orientation"),
        "data-focus": dataAttr(focused),
        style: { position: "relative" }
      });
    },
    getThumbProps(props25) {
      const { index = 0, name } = props25;
      const value = sliderValue[index];
      const range2 = getRangeAtIndex(service, index);
      const valueText = prop("getAriaValueText")?.({ value, index });
      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
      return normalize2.element({
        ...parts17.thumb.attrs,
        dir: prop("dir"),
        "data-index": index,
        "data-name": name,
        id: getThumbId(scope, index),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-focus": dataAttr(focused && focusedIndex === index),
        "data-dragging": dataAttr(dragging && focusedIndex === index),
        draggable: false,
        "aria-disabled": ariaAttr(disabled),
        "aria-label": _ariaLabel,
        "aria-labelledby": _ariaLabelledBy ?? getLabelId8(scope),
        "aria-orientation": prop("orientation"),
        "aria-valuemax": range2.max,
        "aria-valuemin": range2.min,
        "aria-valuenow": sliderValue[index],
        "aria-valuetext": valueText,
        role: "slider",
        tabIndex: disabled ? void 0 : 0,
        style: getThumbStyle(service, index),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          const thumbEl = event.currentTarget;
          const rect = thumbEl.getBoundingClientRect();
          const midpoint = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          };
          const offset2 = {
            x: event.clientX - midpoint.x,
            y: event.clientY - midpoint.y
          };
          send({ type: "THUMB_POINTER_DOWN", index, offset: offset2 });
          event.stopPropagation();
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "BLUR" });
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS", index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event) * prop("step");
          const keyMap2 = {
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_INC", step, src: "ArrowUp" });
            },
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_DEC", step, src: "ArrowDown" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_DEC", step, src: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_INC", step, src: "ArrowRight" });
            },
            PageUp() {
              send({ type: "ARROW_INC", step, src: "PageUp" });
            },
            PageDown() {
              send({ type: "ARROW_DEC", step, src: "PageDown" });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    getHiddenInputProps(props25) {
      const { index = 0, name } = props25;
      return normalize2.input({
        name: name ?? (prop("name") ? prop("name") + (sliderValue.length > 1 ? "[]" : "") : void 0),
        form: prop("form"),
        type: "text",
        hidden: true,
        defaultValue: sliderValue[index],
        id: getHiddenInputId3(scope, index)
      });
    },
    getRangeProps() {
      return normalize2.element({
        id: getRangeId(scope),
        ...parts17.range.attrs,
        dir: prop("dir"),
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        style: getRangeStyle(service)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts17.control.attrs,
        dir: prop("dir"),
        id: getControlId4(scope),
        "data-dragging": dataAttr(dragging),
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        style: getControlStyle(),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          send({ type: "POINTER_DOWN", point });
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getMarkerGroupProps() {
      return normalize2.element({
        ...parts17.markerGroup.attrs,
        role: "presentation",
        dir: prop("dir"),
        "aria-hidden": true,
        "data-orientation": prop("orientation"),
        style: getMarkerGroupStyle()
      });
    },
    getMarkerProps(props25) {
      const style = getMarkerStyle(service, props25.value);
      let markerState;
      if (props25.value < first(sliderValue)) {
        markerState = "under-value";
      } else if (props25.value > last(sliderValue)) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize2.element({
        ...parts17.marker.attrs,
        id: getMarkerId(scope, props25.value),
        role: "presentation",
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-value": props25.value,
        "data-disabled": dataAttr(disabled),
        "data-state": markerState,
        style
      });
    },
    getDraggingIndicatorProps(props25) {
      const { index = 0 } = props25;
      const isDragging = index === focusedIndex && dragging;
      return normalize2.element({
        ...parts17.draggingIndicator.attrs,
        role: "presentation",
        dir: prop("dir"),
        hidden: !isDragging,
        "data-orientation": prop("orientation"),
        "data-state": isDragging ? "open" : "closed",
        style: getThumbStyle(service, index)
      });
    }
  };
}
var isEqualSize = (a, b) => {
  return a?.width === b?.width && a?.height === b?.height;
};
var normalize = (value, min3, max3, step, minStepsBetweenThumbs) => {
  const ranges = getValueRanges(value, min3, max3, minStepsBetweenThumbs * step);
  return ranges.map((range2) => {
    const snapValue = snapValueToStep(range2.value, range2.min, range2.max, step);
    const rangeValue = clampValue(snapValue, range2.min, range2.max);
    if (!isValueWithinRange(rangeValue, min3, max3)) {
      throw new Error(
        "[zag-js/slider] The configured `min`, `max`, `step` or `minStepsBetweenThumbs` values are invalid"
      );
    }
    return rangeValue;
  });
};
var machine17 = createMachine({
  props({ props: props25 }) {
    const min3 = props25.min ?? 0;
    const max3 = props25.max ?? 100;
    const step = props25.step ?? 1;
    const defaultValue = props25.defaultValue ?? [min3];
    const minStepsBetweenThumbs = props25.minStepsBetweenThumbs ?? 0;
    return {
      dir: "ltr",
      thumbAlignment: "contain",
      origin: "start",
      orientation: "horizontal",
      minStepsBetweenThumbs,
      ...props25,
      defaultValue: normalize(defaultValue, min3, max3, step, minStepsBetweenThumbs),
      value: props25.value ? normalize(props25.value, min3, max3, step, minStepsBetweenThumbs) : void 0,
      max: max3,
      step,
      min: min3
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable: bindable2, getContext: getContext2 }) {
    return {
      thumbSize: bindable2(() => ({
        defaultValue: prop("thumbSize") || null
      })),
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        hash(a) {
          return a.join(",");
        },
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      focusedIndex: bindable2(() => ({
        defaultValue: -1,
        onChange(value) {
          const ctx = getContext2();
          prop("onFocusChange")?.({ focusedIndex: value, value: ctx.get("value") });
        }
      })),
      fieldsetDisabled: bindable2(() => ({
        defaultValue: false
      }))
    };
  },
  refs() {
    return {
      thumbDragOffset: null
    };
  },
  computed: {
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal",
    isVertical: ({ prop }) => prop("orientation") === "vertical",
    isRtl: ({ prop }) => prop("orientation") === "horizontal" && prop("dir") === "rtl",
    isDisabled: ({ context, prop }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    isInteractive: ({ prop, computed }) => !(prop("readOnly") || computed("isDisabled")),
    hasMeasuredThumbSize: ({ context }) => context.get("thumbSize") != null,
    valuePercent: memo(
      ({ context, prop }) => [context.get("value"), prop("min"), prop("max")],
      ([value, min3, max3]) => value.map((value2) => 100 * getValuePercent(value2, min3, max3))
    )
  },
  watch({ track: track2, action, context, computed, send }) {
    track2([() => context.hash("value")], () => {
      action(["syncInputElements", "dispatchChangeEvent"]);
    });
    track2([() => computed("isDisabled")], () => {
      if (computed("isDisabled")) {
        send({ type: "POINTER_CANCEL" });
      }
    });
  },
  effects: ["trackFormControlState", "trackThumbSize"],
  on: {
    SET_VALUE: [
      {
        guard: "hasIndex",
        actions: ["setValueAtIndex", "invokeOnChangeEnd"]
      },
      {
        actions: ["setValue", "invokeOnChangeEnd"]
      }
    ],
    INCREMENT: {
      actions: ["incrementThumbAtIndex", "invokeOnChangeEnd"]
    },
    DECREMENT: {
      actions: ["decrementThumbAtIndex", "invokeOnChangeEnd"]
    }
  },
  states: {
    idle: {
      on: {
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
        },
        FOCUS: {
          target: "focus",
          actions: ["setFocusedIndex"]
        },
        THUMB_POINTER_DOWN: {
          target: "dragging",
          actions: ["setFocusedIndex", "setThumbDragOffset", "focusActiveThumb"]
        }
      }
    },
    focus: {
      entry: ["focusActiveThumb"],
      on: {
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
        },
        THUMB_POINTER_DOWN: {
          target: "dragging",
          actions: ["setFocusedIndex", "setThumbDragOffset", "focusActiveThumb"]
        },
        ARROW_DEC: {
          actions: ["decrementThumbAtIndex", "invokeOnChangeEnd"]
        },
        ARROW_INC: {
          actions: ["incrementThumbAtIndex", "invokeOnChangeEnd"]
        },
        HOME: {
          actions: ["setFocusedThumbToMin", "invokeOnChangeEnd"]
        },
        END: {
          actions: ["setFocusedThumbToMax", "invokeOnChangeEnd"]
        },
        BLUR: {
          target: "idle",
          actions: ["clearFocusedIndex"]
        }
      }
    },
    dragging: {
      entry: ["focusActiveThumb"],
      effects: ["trackPointerMove"],
      on: {
        POINTER_UP: {
          target: "focus",
          actions: ["invokeOnChangeEnd", "clearThumbDragOffset"]
        },
        POINTER_MOVE: {
          actions: ["setPointerValue"]
        },
        POINTER_CANCEL: {
          target: "idle",
          actions: ["clearFocusedIndex", "clearThumbDragOffset"]
        }
      }
    }
  },
  implementations: {
    guards: {
      hasIndex: ({ event }) => event.index != null
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return trackFormControl(getRootEl5(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      trackPointerMove({ scope, send }) {
        return trackPointerMove(scope.getDoc(), {
          onPointerMove(info) {
            send({ type: "POINTER_MOVE", point: info.point });
          },
          onPointerUp() {
            send({ type: "POINTER_UP" });
          }
        });
      },
      trackThumbSize({ context, scope, prop }) {
        if (prop("thumbAlignment") !== "contain" || prop("thumbSize")) return;
        const exec = (el) => {
          const rect = getOffsetRect2(el);
          const size2 = pick(rect, ["width", "height"]);
          if (isEqualSize(context.get("thumbSize"), size2)) return;
          context.set("thumbSize", size2);
        };
        const thumbEls = getThumbEls(scope);
        thumbEls.forEach(exec);
        const cleanups = thumbEls.map((el) => resizeObserverBorderBox.observe(el, () => exec(el)));
        return callAll(...cleanups);
      }
    },
    actions: {
      dispatchChangeEvent({ context, scope }) {
        dispatchChangeEvent2(scope, context.get("value"));
      },
      syncInputElements({ context, scope }) {
        context.get("value").forEach((value, index) => {
          const inputEl = getHiddenInputEl3(scope, index);
          setElementValue(inputEl, value.toString());
        });
      },
      invokeOnChangeEnd({ prop, context }) {
        queueMicrotask(() => {
          prop("onValueChangeEnd")?.({ value: context.get("value") });
        });
      },
      setClosestThumbIndex(params) {
        const { context, event } = params;
        const pointValue = getPointValue(params, event.point);
        if (pointValue == null) return;
        const focusedIndex = getClosestIndex(params, pointValue);
        context.set("focusedIndex", focusedIndex);
      },
      setFocusedIndex(params) {
        const { context, event } = params;
        const movableIndex = selectMovableThumb(params, event.index);
        context.set("focusedIndex", movableIndex);
      },
      clearFocusedIndex({ context }) {
        context.set("focusedIndex", -1);
      },
      setThumbDragOffset(params) {
        const { refs, event } = params;
        refs.set("thumbDragOffset", event.offset ?? null);
      },
      clearThumbDragOffset({ refs }) {
        refs.set("thumbDragOffset", null);
      },
      setPointerValue(params) {
        queueMicrotask(() => {
          const { context, event } = params;
          const pointValue = getPointValue(params, event.point);
          if (pointValue == null) return;
          const focusedIndex = context.get("focusedIndex");
          const value = constrainValue2(params, pointValue, focusedIndex);
          context.set("value", (prev2) => setValueAtIndex(prev2, focusedIndex, value));
        });
      },
      focusActiveThumb({ scope, context }) {
        raf(() => {
          const thumbEl = getThumbEl(scope, context.get("focusedIndex"));
          thumbEl?.focus({ preventScroll: true });
        });
      },
      decrementThumbAtIndex(params) {
        const { context, event } = params;
        const value = decrement(params, event.index, event.step);
        context.set("value", value);
      },
      incrementThumbAtIndex(params) {
        const { context, event } = params;
        const value = increment(params, event.index, event.step);
        context.set("value", value);
      },
      setFocusedThumbToMin(params) {
        const { context } = params;
        const index = context.get("focusedIndex");
        const { min: min3 } = getRangeAtIndex(params, index);
        context.set("value", (prev2) => setValueAtIndex(prev2, index, min3));
      },
      setFocusedThumbToMax(params) {
        const { context } = params;
        const index = context.get("focusedIndex");
        const { max: max3 } = getRangeAtIndex(params, index);
        context.set("value", (prev2) => setValueAtIndex(prev2, index, max3));
      },
      setValueAtIndex(params) {
        const { context, event } = params;
        const value = constrainValue2(params, event.value, event.index);
        context.set("value", (prev2) => setValueAtIndex(prev2, event.index, value));
      },
      setValue(params) {
        const { context, event } = params;
        const value = normalizeValues(params, event.value);
        context.set("value", value);
      }
    }
  }
});
var props17 = createProps()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value",
  "defaultValue"
]);
var splitProps18 = createSplitProps(props17);
var thumbProps = createProps()(["index", "name"]);
var splitThumbProps = createSplitProps(thumbProps);
var markerProps = createProps()(["value"]);
var splitMarkerProps = createSplitProps(markerProps);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/modules/provider.svelte.js
function useSlider(props25) {
  const service = useMachine(machine17, props25);
  const slider = tag(user_derived(() => connect17(service, normalizeProps)), "slider");
  return () => get(slider);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/root.svelte
Root20[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/root.svelte";
var root_2173 = add_locations(from_html(`<div><!></div>`), Root20[FILENAME], [[35, 1]]);
function Root20($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root20);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps18(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), sliderProps = tag(user_derived(() => get($$array)[0]), "sliderProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const slider = useSlider(() => ({ ...get(sliderProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(slider().getRootProps(), get(rest))), "attributes");
  RootContext18.provide(() => slider());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root20, 33, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2173();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root20, 36, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root20,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root20 = hmr(Root20);
  import.meta.hot.accept((module) => {
    Root20[HMR].update(module.default);
  });
}
var root_default20 = Root20;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/thumb.svelte
Thumb[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/thumb.svelte";
var root_2174 = add_locations(from_html(`<div><!></div>`), Thumb[FILENAME], [[29, 1]]);
function Thumb($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Thumb);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const $$d = user_derived(() => splitThumbProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), thumbProps2 = tag(user_derived(() => get($$array)[0]), "thumbProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(slider().getThumbProps(get(thumbProps2)), get(rest))), "attributes");
  ThumbContext.provide(() => get(thumbProps2));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Thumb, 27, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2174();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Thumb, 30, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Thumb,
      26,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Thumb = hmr(Thumb);
  import.meta.hot.accept((module) => {
    Thumb[HMR].update(module.default);
  });
}
var thumb_default = Thumb;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/track.svelte
Track2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/track.svelte";
var root_2175 = add_locations(from_html(`<div><!></div>`), Track2[FILENAME], [[24, 1]]);
function Track2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Track2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(slider().getTrackProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Track2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2175();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Track2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Track2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Track2 = hmr(Track2);
  import.meta.hot.accept((module) => {
    Track2[HMR].update(module.default);
  });
}
var track_default2 = Track2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/value-text.svelte
Value_text2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/anatomy/value-text.svelte";
var root_2176 = add_locations(from_html(`<output><!></output>`), Value_text2[FILENAME], [[24, 1]]);
function Value_text2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Value_text2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const slider = RootContext18.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(slider().getValueTextProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Value_text2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var output = root_2176();
      attribute_effect(output, () => ({ ...get(attributes) }));
      var node_2 = child(output);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Value_text2, 25, 2);
      reset(output);
      append($$anchor2, output);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Value_text2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Value_text2 = hmr(Value_text2);
  import.meta.hot.accept((module) => {
    Value_text2[HMR].update(module.default);
  });
}
var value_text_default2 = Value_text2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/slider/modules/anatomy.js
var Slider = Object.assign(root_default20, {
  Provider: root_provider_default17,
  Context: root_context_default17,
  Label: label_default9,
  ValueText: value_text_default2,
  Control: control_default7,
  Track: track_default2,
  Range: range_default2,
  Thumb: thumb_default,
  HiddenInput: hidden_input_default3,
  MarkerGroup: marker_group_default,
  Marker: marker_default
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/modules/root-context.js
var RootContext19 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/content.svelte
Content10[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/content.svelte";
var root_2177 = add_locations(from_html(`<div><!></div>`), Content10[FILENAME], [[26, 1]]);
function Content10($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content10);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const steps = RootContext19.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), index = tag(user_derived(() => $$props.index), "index"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "index"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(steps().getContentProps({ index: get(index) }), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content10, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2177();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content10, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content10,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content10 = hmr(Content10);
  import.meta.hot.accept((module) => {
    Content10[HMR].update(module.default);
  });
}
var content_default10 = Content10;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/modules/item-context.js
var ItemContext7 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/indicator.svelte
Indicator5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/indicator.svelte";
var root_2178 = add_locations(from_html(`<div><!></div>`), Indicator5[FILENAME], [[26, 1]]);
function Indicator5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Indicator5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const steps = RootContext19.consume();
  const itemProps13 = ItemContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(steps().getIndicatorProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Indicator5, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2178();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Indicator5, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Indicator5,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Indicator5 = hmr(Indicator5);
  import.meta.hot.accept((module) => {
    Indicator5[HMR].update(module.default);
  });
}
var indicator_default5 = Indicator5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/item.svelte
Item10[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/item.svelte";
var root_2179 = add_locations(from_html(`<div><!></div>`), Item10[FILENAME], [[30, 1]]);
function Item10($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item10);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const steps = RootContext19.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), index = tag(user_derived(() => $$props.index), "index"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "index"])), "rest");
  const itemProps13 = tag(user_derived(() => ({ index: get(index) })), "itemProps");
  const attributes = tag(user_derived(() => mergeProps2(steps().getItemProps(get(itemProps13)), get(rest))), "attributes");
  ItemContext7.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item10, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2179();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item10, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item10,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item10 = hmr(Item10);
  import.meta.hot.accept((module) => {
    Item10[HMR].update(module.default);
  });
}
var item_default10 = Item10;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/list.svelte
List[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/list.svelte";
var root_2180 = add_locations(from_html(`<div><!></div>`), List[FILENAME], [[24, 1]]);
function List($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, List);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const steps = RootContext19.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(steps().getListProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", List, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2180();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", List, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      List,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  List = hmr(List);
  import.meta.hot.accept((module) => {
    List[HMR].update(module.default);
  });
}
var list_default = List;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/next-trigger.svelte
Next_trigger4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/next-trigger.svelte";
var root_2181 = add_locations(from_html(`<button><!></button>`), Next_trigger4[FILENAME], [[24, 1]]);
function Next_trigger4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Next_trigger4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const steps = RootContext19.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(steps().getNextTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Next_trigger4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2181();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Next_trigger4, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Next_trigger4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Next_trigger4 = hmr(Next_trigger4);
  import.meta.hot.accept((module) => {
    Next_trigger4[HMR].update(module.default);
  });
}
var next_trigger_default4 = Next_trigger4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/prev-trigger.svelte
Prev_trigger4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/prev-trigger.svelte";
var root_2182 = add_locations(from_html(`<button><!></button>`), Prev_trigger4[FILENAME], [[24, 1]]);
function Prev_trigger4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Prev_trigger4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const steps = RootContext19.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(steps().getPrevTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Prev_trigger4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2182();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Prev_trigger4, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Prev_trigger4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Prev_trigger4 = hmr(Prev_trigger4);
  import.meta.hot.accept((module) => {
    Prev_trigger4[HMR].update(module.default);
  });
}
var prev_trigger_default4 = Prev_trigger4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/root-context.svelte
Root_context18[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/root-context.svelte";
function Root_context18($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context18);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const steps = RootContext19.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => steps), "render", Root_context18, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context18 = hmr(Root_context18);
  import.meta.hot.accept((module) => {
    Root_context18[HMR].update(module.default);
  });
}
var root_context_default18 = Root_context18;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/root-provider.svelte
Root_provider18[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/root-provider.svelte";
var root_2183 = add_locations(from_html(`<div><!></div>`), Root_provider18[FILENAME], [[27, 1]]);
function Root_provider18($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider18);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), steps = tag(user_derived(() => $$props.value), "steps"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(steps)().getRootProps(), get(rest))), "attributes");
  RootContext19.provide(() => get(steps)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider18, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2183();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider18, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider18,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider18 = hmr(Root_provider18);
  import.meta.hot.accept((module) => {
    Root_provider18[HMR].update(module.default);
  });
}
var root_provider_default18 = Root_provider18;

// node_modules/@zag-js/steps/dist/index.mjs
var anatomy18 = createAnatomy("steps").parts(
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "nextTrigger",
  "prevTrigger",
  "progress"
);
var parts18 = anatomy18.build();
var getRootId14 = (ctx) => ctx.ids?.root ?? `steps:${ctx.id}`;
var getListId = (ctx) => ctx.ids?.list ?? `steps:${ctx.id}:list`;
var getTriggerId9 = (ctx, index) => ctx.ids?.triggerId?.(index) ?? `steps:${ctx.id}:trigger:${index}`;
var getContentId9 = (ctx, index) => ctx.ids?.contentId?.(index) ?? `steps:${ctx.id}:content:${index}`;
function connect18(service, normalize2) {
  const { context, send, computed, prop, scope } = service;
  const step = context.get("step");
  const count = prop("count");
  const percent = computed("percent");
  const hasNextStep = computed("hasNextStep");
  const hasPrevStep = computed("hasPrevStep");
  const getItemState = (props25) => ({
    triggerId: getTriggerId9(scope, props25.index),
    contentId: getContentId9(scope, props25.index),
    current: props25.index === step,
    completed: props25.index < step,
    incomplete: props25.index > step,
    index: props25.index,
    first: props25.index === 0,
    last: props25.index === count - 1
  });
  const goToNextStep = () => {
    send({ type: "STEP.NEXT", src: "next.trigger.click" });
  };
  const goToPrevStep = () => {
    send({ type: "STEP.PREV", src: "prev.trigger.click" });
  };
  const resetStep = () => {
    send({ type: "STEP.RESET", src: "reset.trigger.click" });
  };
  const setStep = (value) => {
    send({ type: "STEP.SET", value, src: "api.setValue" });
  };
  return {
    value: step,
    count,
    percent,
    hasNextStep,
    hasPrevStep,
    isCompleted: computed("completed"),
    goToNextStep,
    goToPrevStep,
    resetStep,
    getItemState,
    setStep,
    getRootProps() {
      return normalize2.element({
        ...parts18.root.attrs,
        id: getRootId14(scope),
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        style: {
          "--percent": `${percent}%`
        }
      });
    },
    getListProps() {
      const arr = fromLength(count);
      const triggerIds = arr.map((_, index) => getTriggerId9(scope, index));
      return normalize2.element({
        ...parts18.list.attrs,
        dir: prop("dir"),
        id: getListId(scope),
        role: "tablist",
        "aria-owns": triggerIds.join(" "),
        "aria-orientation": prop("orientation"),
        "data-orientation": prop("orientation")
      });
    },
    getItemProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts18.item.attrs,
        dir: prop("dir"),
        "aria-current": itemState.current ? "step" : void 0,
        "data-orientation": prop("orientation")
      });
    },
    getTriggerProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.button({
        ...parts18.trigger.attrs,
        id: itemState.triggerId,
        role: "tab",
        dir: prop("dir"),
        tabIndex: !prop("linear") || itemState.current ? 0 : -1,
        "aria-selected": itemState.current,
        "aria-controls": itemState.contentId,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": prop("orientation"),
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (prop("linear")) return;
          send({ type: "STEP.SET", value: props25.index, src: "trigger.click" });
        }
      });
    },
    getContentProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts18.content.attrs,
        dir: prop("dir"),
        id: itemState.contentId,
        role: "tabpanel",
        tabIndex: 0,
        hidden: !itemState.current,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": prop("orientation"),
        "aria-labelledby": itemState.triggerId
      });
    },
    getIndicatorProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts18.indicator.attrs,
        dir: prop("dir"),
        "aria-hidden": true,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getSeparatorProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts18.separator.attrs,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getNextTriggerProps() {
      return normalize2.button({
        ...parts18.nextTrigger.attrs,
        dir: prop("dir"),
        type: "button",
        disabled: !hasNextStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToNextStep();
        }
      });
    },
    getPrevTriggerProps() {
      return normalize2.button({
        dir: prop("dir"),
        ...parts18.prevTrigger.attrs,
        type: "button",
        disabled: !hasPrevStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToPrevStep();
        }
      });
    },
    getProgressProps() {
      return normalize2.element({
        dir: prop("dir"),
        ...parts18.progress.attrs,
        role: "progressbar",
        "aria-valuenow": percent,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuetext": `${percent}% complete`,
        "data-complete": dataAttr(percent === 100)
      });
    }
  };
}
var machine18 = createMachine({
  props({ props: props25 }) {
    return {
      defaultStep: 0,
      count: 1,
      linear: false,
      orientation: "horizontal",
      ...props25
    };
  },
  context({ prop, bindable: bindable2 }) {
    return {
      step: bindable2(() => ({
        defaultValue: prop("defaultStep"),
        value: prop("step"),
        onChange(value) {
          prop("onStepChange")?.({ step: value });
          const completed = value == prop("count");
          if (completed) prop("onStepComplete")?.();
        }
      }))
    };
  },
  computed: {
    percent: memo(
      ({ context, prop }) => [context.get("step"), prop("count")],
      ([step, count]) => step / count * 100
    ),
    hasNextStep: ({ context, prop }) => context.get("step") < prop("count"),
    hasPrevStep: ({ context }) => context.get("step") > 0,
    completed: ({ context, prop }) => context.get("step") === prop("count")
  },
  initialState() {
    return "idle";
  },
  entry: ["validateStep"],
  states: {
    idle: {
      on: {
        "STEP.SET": {
          actions: ["setStep"]
        },
        "STEP.NEXT": {
          actions: ["goToNextStep"]
        },
        "STEP.PREV": {
          actions: ["goToPrevStep"]
        },
        "STEP.RESET": {
          actions: ["resetStep"]
        }
      }
    }
  },
  implementations: {
    actions: {
      goToNextStep({ context, prop }) {
        const value = Math.min(context.get("step") + 1, prop("count"));
        context.set("step", value);
      },
      goToPrevStep({ context }) {
        const value = Math.max(context.get("step") - 1, 0);
        context.set("step", value);
      },
      resetStep({ context }) {
        context.set("step", 0);
      },
      setStep({ context, event }) {
        context.set("step", event.value);
      },
      validateStep({ context, prop }) {
        validateStep(prop("count"), context.get("step"));
      }
    }
  }
});
var validateStep = (count, step) => {
  if (!isValueWithinRange(step, 0, count)) {
    throw new RangeError(`[zag-js/steps] step index ${step} is out of bounds`);
  }
};
var props18 = createProps()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "linear",
  "onStepChange",
  "onStepComplete",
  "orientation",
  "step",
  "defaultStep"
]);
var splitProps19 = createSplitProps(props18);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/modules/provider.svelte.js
function useSteps(props25) {
  const service = useMachine(machine18, props25);
  const steps = tag(user_derived(() => connect18(service, normalizeProps)), "steps");
  return () => get(steps);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/root.svelte
Root21[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/root.svelte";
var root_2184 = add_locations(from_html(`<div><!></div>`), Root21[FILENAME], [[34, 1]]);
function Root21($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root21);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps19(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), stepsProps = tag(user_derived(() => get($$array)[0]), "stepsProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const steps = useSteps(() => ({ ...get(stepsProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(steps().getRootProps(), get(rest))), "attributes");
  RootContext19.provide(() => steps());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root21, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2184();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root21, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root21,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root21 = hmr(Root21);
  import.meta.hot.accept((module) => {
    Root21[HMR].update(module.default);
  });
}
var root_default21 = Root21;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/separator.svelte
Separator2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/separator.svelte";
var root_2185 = add_locations(from_html(`<div><!></div>`), Separator2[FILENAME], [[26, 1]]);
function Separator2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Separator2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const steps = RootContext19.consume();
  const itemProps13 = ItemContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(steps().getSeparatorProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Separator2, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2185();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Separator2, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Separator2,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Separator2 = hmr(Separator2);
  import.meta.hot.accept((module) => {
    Separator2[HMR].update(module.default);
  });
}
var separator_default2 = Separator2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/trigger.svelte
Trigger10[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/anatomy/trigger.svelte";
var root_2186 = add_locations(from_html(`<button><!></button>`), Trigger10[FILENAME], [[26, 1]]);
function Trigger10($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger10);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const steps = RootContext19.consume();
  const itemProps13 = ItemContext7.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(steps().getTriggerProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger10, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2186();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger10, 27, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger10,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger10 = hmr(Trigger10);
  import.meta.hot.accept((module) => {
    Trigger10[HMR].update(module.default);
  });
}
var trigger_default10 = Trigger10;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/steps/modules/anatomy.js
var Steps = Object.assign(root_default21, {
  Provider: root_provider_default18,
  Context: root_context_default18,
  List: list_default,
  Item: item_default10,
  Trigger: trigger_default10,
  Indicator: indicator_default5,
  Separator: separator_default2,
  Content: content_default10,
  PrevTrigger: prev_trigger_default4,
  NextTrigger: next_trigger_default4
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/modules/root-context.js
var RootContext20 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/control.svelte
Control8[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/control.svelte";
var root_2187 = add_locations(from_html(`<span><!></span>`), Control8[FILENAME], [[24, 1]]);
function Control8($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control8);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const switch_ = RootContext20.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(switch_().getControlProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Control8, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2187();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Control8, 25, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Control8,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Control8 = hmr(Control8);
  import.meta.hot.accept((module) => {
    Control8[HMR].update(module.default);
  });
}
var control_default8 = Control8;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/hidden-input.svelte
Hidden_input4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/hidden-input.svelte";
var root_2188 = add_locations(from_html(`<input/>`), Hidden_input4[FILENAME], [[24, 1]]);
function Hidden_input4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Hidden_input4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const switch_ = RootContext20.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(switch_().getHiddenInputProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Hidden_input4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_2188();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Hidden_input4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Hidden_input4 = hmr(Hidden_input4);
  import.meta.hot.accept((module) => {
    Hidden_input4[HMR].update(module.default);
  });
}
var hidden_input_default4 = Hidden_input4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/label.svelte
Label10[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/label.svelte";
var root_2189 = add_locations(from_html(`<span><!></span>`), Label10[FILENAME], [[24, 1]]);
function Label10($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label10);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const switch_ = RootContext20.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(switch_().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label10, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2189();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label10, 25, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label10,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label10 = hmr(Label10);
  import.meta.hot.accept((module) => {
    Label10[HMR].update(module.default);
  });
}
var label_default10 = Label10;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/root-context.svelte
Root_context19[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/root-context.svelte";
function Root_context19($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context19);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const switch_ = RootContext20.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => switch_), "render", Root_context19, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context19 = hmr(Root_context19);
  import.meta.hot.accept((module) => {
    Root_context19[HMR].update(module.default);
  });
}
var root_context_default19 = Root_context19;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/root-provider.svelte
Root_provider19[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/root-provider.svelte";
var root_2190 = add_locations(from_html(`<label><!></label>`), Root_provider19[FILENAME], [[27, 1]]);
function Root_provider19($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider19);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), switch_ = tag(user_derived(() => $$props.value), "switch_"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(switch_)().getRootProps(), get(rest))), "attributes");
  RootContext20.provide(() => get(switch_)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider19, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_2190();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider19, 28, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider19,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider19 = hmr(Root_provider19);
  import.meta.hot.accept((module) => {
    Root_provider19[HMR].update(module.default);
  });
}
var root_provider_default19 = Root_provider19;

// node_modules/@zag-js/switch/dist/index.mjs
var anatomy19 = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts19 = anatomy19.build();
var getRootId15 = (ctx) => ctx.ids?.root ?? `switch:${ctx.id}`;
var getLabelId9 = (ctx) => ctx.ids?.label ?? `switch:${ctx.id}:label`;
var getThumbId2 = (ctx) => ctx.ids?.thumb ?? `switch:${ctx.id}:thumb`;
var getControlId5 = (ctx) => ctx.ids?.control ?? `switch:${ctx.id}:control`;
var getHiddenInputId4 = (ctx) => ctx.ids?.hiddenInput ?? `switch:${ctx.id}:input`;
var getRootEl6 = (ctx) => ctx.getById(getRootId15(ctx));
var getHiddenInputEl4 = (ctx) => ctx.getById(getHiddenInputId4(ctx));
function connect19(service, normalize2) {
  const { context, send, prop, scope } = service;
  const disabled = !!prop("disabled");
  const readOnly = !!prop("readOnly");
  const required = !!prop("required");
  const checked = !!context.get("checked");
  const focused = !disabled && context.get("focused");
  const focusVisible = !disabled && context.get("focusVisible");
  const active = !disabled && context.get("active");
  const dataAttrs = {
    "data-active": dataAttr(active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(context.get("hovered")),
    "data-disabled": dataAttr(disabled),
    "data-state": checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(prop("invalid")),
    "data-required": dataAttr(required)
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize2.label({
        ...parts19.root.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getRootId15(scope),
        htmlFor: getHiddenInputId4(scope),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (disabled) return;
          const target = getEventTarget(event);
          if (target === getHiddenInputEl4(scope)) {
            event.stopPropagation();
          }
          if (isSafari()) {
            getHiddenInputEl4(scope)?.focus();
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts19.label.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getLabelId9(scope)
      });
    },
    getThumbProps() {
      return normalize2.element({
        ...parts19.thumb.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getThumbId2(scope),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts19.control.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getControlId5(scope),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: getHiddenInputId4(scope),
        type: "checkbox",
        required: prop("required"),
        defaultChecked: checked,
        disabled,
        "aria-labelledby": getLabelId9(scope),
        "aria-invalid": prop("invalid"),
        name: prop("name"),
        form: prop("form"),
        value: prop("value"),
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not6 } = createGuards();
var machine19 = createMachine({
  props({ props: props25 }) {
    return {
      defaultChecked: false,
      label: "switch",
      value: "on",
      ...props25
    };
  },
  initialState() {
    return "ready";
  },
  context({ prop, bindable: bindable2 }) {
    return {
      checked: bindable2(() => ({
        defaultValue: prop("defaultChecked"),
        value: prop("checked"),
        onChange(value) {
          prop("onCheckedChange")?.({ checked: value });
        }
      })),
      fieldsetDisabled: bindable2(() => ({
        defaultValue: false
      })),
      focusVisible: bindable2(() => ({
        defaultValue: false
      })),
      active: bindable2(() => ({
        defaultValue: false
      })),
      focused: bindable2(() => ({
        defaultValue: false
      })),
      hovered: bindable2(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    isDisabled: ({ context, prop }) => prop("disabled") || context.get("fieldsetDisabled")
  },
  watch({ track: track2, prop, context, action }) {
    track2([() => prop("disabled")], () => {
      action(["removeFocusIfNeeded"]);
    });
    track2([() => context.get("checked")], () => {
      action(["syncInputElement"]);
    });
  },
  effects: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
  on: {
    "CHECKED.TOGGLE": [
      {
        guard: not6("isTrusted"),
        actions: ["toggleChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["toggleChecked"]
      }
    ],
    "CHECKED.SET": [
      {
        guard: not6("isTrusted"),
        actions: ["setChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["setChecked"]
      }
    ],
    "CONTEXT.SET": {
      actions: ["setContext"]
    }
  },
  states: {
    ready: {}
  },
  implementations: {
    guards: {
      isTrusted: ({ event }) => !!event.isTrusted
    },
    effects: {
      trackPressEvent({ computed, scope, context }) {
        if (computed("isDisabled")) return;
        return trackPress({
          pointerNode: getRootEl6(scope),
          keyboardNode: getHiddenInputEl4(scope),
          isValidKey: (event) => event.key === " ",
          onPress: () => context.set("active", false),
          onPressStart: () => context.set("active", true),
          onPressEnd: () => context.set("active", false)
        });
      },
      trackFocusVisible({ computed, scope }) {
        if (computed("isDisabled")) return;
        return trackFocusVisible({ root: scope.getRootNode() });
      },
      trackFormControlState({ context, send, scope }) {
        return trackFormControl(getHiddenInputEl4(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            const checked = context.initial("checked");
            send({ type: "CHECKED.SET", checked: !!checked, src: "form-reset" });
          }
        });
      }
    },
    actions: {
      setContext({ context, event }) {
        for (const key in event.context) {
          context.set(key, event.context[key]);
        }
      },
      syncInputElement({ context, scope }) {
        const inputEl = getHiddenInputEl4(scope);
        if (!inputEl) return;
        setElementChecked(inputEl, !!context.get("checked"));
      },
      removeFocusIfNeeded({ context, prop }) {
        if (prop("disabled")) {
          context.set("focused", false);
        }
      },
      setChecked({ context, event }) {
        context.set("checked", event.checked);
      },
      toggleChecked({ context }) {
        context.set("checked", !context.get("checked"));
      },
      dispatchChangeEvent({ context, scope }) {
        const inputEl = getHiddenInputEl4(scope);
        dispatchInputCheckedEvent(inputEl, { checked: context.get("checked") });
      }
    }
  }
});
var props19 = createProps()([
  "checked",
  "defaultChecked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps20 = createSplitProps(props19);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/modules/provider.svelte.js
function useSwitch(props25) {
  const service = useMachine(machine19, props25);
  const switch_ = tag(user_derived(() => connect19(service, normalizeProps)), "switch_");
  return () => get(switch_);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/root.svelte
Root22[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/root.svelte";
var root_2191 = add_locations(from_html(`<label><!></label>`), Root22[FILENAME], [[34, 1]]);
function Root22($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root22);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps20(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), switchProps = tag(user_derived(() => get($$array)[0]), "switchProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const switch_ = useSwitch(() => ({ ...get(switchProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(switch_().getRootProps(), get(rest))), "attributes");
  RootContext20.provide(() => switch_());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root22, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_2191();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root22, 35, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root22,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root22 = hmr(Root22);
  import.meta.hot.accept((module) => {
    Root22[HMR].update(module.default);
  });
}
var root_default22 = Root22;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/thumb.svelte
Thumb2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/anatomy/thumb.svelte";
var root_2192 = add_locations(from_html(`<span><!></span>`), Thumb2[FILENAME], [[24, 1]]);
function Thumb2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Thumb2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const switch_ = RootContext20.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(switch_().getThumbProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Thumb2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2192();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Thumb2, 25, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Thumb2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Thumb2 = hmr(Thumb2);
  import.meta.hot.accept((module) => {
    Thumb2[HMR].update(module.default);
  });
}
var thumb_default2 = Thumb2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/switch/modules/anatomy.js
var Switch = Object.assign(root_default22, {
  Provider: root_provider_default19,
  Context: root_context_default19,
  Control: control_default8,
  Thumb: thumb_default2,
  Label: label_default10,
  HiddenInput: hidden_input_default4
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/modules/root-context.js
var RootContext21 = createContext();

// node_modules/@zag-js/tabs/dist/index.mjs
var anatomy20 = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts20 = anatomy20.build();
var getRootId16 = (ctx) => ctx.ids?.root ?? `tabs:${ctx.id}`;
var getListId2 = (ctx) => ctx.ids?.list ?? `tabs:${ctx.id}:list`;
var getContentId10 = (ctx, value) => ctx.ids?.content?.(value) ?? `tabs:${ctx.id}:content-${value}`;
var getTriggerId10 = (ctx, value) => ctx.ids?.trigger?.(value) ?? `tabs:${ctx.id}:trigger-${value}`;
var getIndicatorId3 = (ctx) => ctx.ids?.indicator ?? `tabs:${ctx.id}:indicator`;
var getListEl = (ctx) => ctx.getById(getListId2(ctx));
var getContentEl9 = (ctx, value) => ctx.getById(getContentId10(ctx, value));
var getTriggerEl7 = (ctx, value) => value != null ? ctx.getById(getTriggerId10(ctx, value)) : null;
var getIndicatorEl3 = (ctx) => ctx.getById(getIndicatorId3(ctx));
var getElements2 = (ctx) => {
  const ownerId = CSS.escape(getListId2(ctx));
  const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
  return queryAll(getListEl(ctx), selector);
};
var getFirstTriggerEl2 = (ctx) => first(getElements2(ctx));
var getLastTriggerEl2 = (ctx) => last(getElements2(ctx));
var getNextTriggerEl2 = (ctx, opts) => nextById(getElements2(ctx), getTriggerId10(ctx, opts.value), opts.loopFocus);
var getPrevTriggerEl2 = (ctx, opts) => prevById(getElements2(ctx), getTriggerId10(ctx, opts.value), opts.loopFocus);
var getOffsetRect3 = (el) => ({
  x: el?.offsetLeft ?? 0,
  y: el?.offsetTop ?? 0,
  width: el?.offsetWidth ?? 0,
  height: el?.offsetHeight ?? 0
});
var getRectByValue = (ctx, value) => {
  const tab = itemById(getElements2(ctx), getTriggerId10(ctx, value));
  return getOffsetRect3(tab);
};
function connect20(service, normalize2) {
  const { state: state3, send, context, prop, scope } = service;
  const translations = prop("translations");
  const focused = state3.matches("focused");
  const isVertical = prop("orientation") === "vertical";
  const isHorizontal = prop("orientation") === "horizontal";
  const composite = prop("composite");
  function getTriggerState(props25) {
    return {
      selected: context.get("value") === props25.value,
      focused: context.get("focusedValue") === props25.value,
      disabled: !!props25.disabled
    };
  }
  return {
    value: context.get("value"),
    focusedValue: context.get("focusedValue"),
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setIndicatorRect(value) {
      const id = getTriggerId10(scope, value);
      send({ type: "SET_INDICATOR_RECT", id });
    },
    syncTabIndex() {
      send({ type: "SYNC_TAB_INDEX" });
    },
    selectNext(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectNext" });
      send({ type: "ARROW_NEXT", src: "selectNext" });
    },
    selectPrev(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectPrev" });
      send({ type: "ARROW_PREV", src: "selectPrev" });
    },
    focus() {
      const value = context.get("value");
      if (!value) return;
      getTriggerEl7(scope, value)?.focus();
    },
    getRootProps() {
      return normalize2.element({
        ...parts20.root.attrs,
        id: getRootId16(scope),
        "data-orientation": prop("orientation"),
        "data-focus": dataAttr(focused),
        dir: prop("dir")
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts20.list.attrs,
        id: getListId2(scope),
        role: "tablist",
        dir: prop("dir"),
        "data-focus": dataAttr(focused),
        "aria-orientation": prop("orientation"),
        "data-orientation": prop("orientation"),
        "aria-label": translations?.listLabel,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          if (!contains(event.currentTarget, getEventTarget(event))) return;
          const keyMap2 = {
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_NEXT", key: "ArrowDown" });
            },
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_PREV", key: "ArrowUp" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_PREV", key: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_NEXT", key: "ArrowRight" });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          let key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          if (exec) {
            event.preventDefault();
            exec(event);
            return;
          }
        }
      });
    },
    getTriggerState,
    getTriggerProps(props25) {
      const { value, disabled } = props25;
      const triggerState = getTriggerState(props25);
      return normalize2.button({
        ...parts20.trigger.attrs,
        role: "tab",
        type: "button",
        disabled,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-disabled": dataAttr(disabled),
        "aria-disabled": disabled,
        "data-value": value,
        "aria-selected": triggerState.selected,
        "data-selected": dataAttr(triggerState.selected),
        "data-focus": dataAttr(triggerState.focused),
        "aria-controls": triggerState.selected ? getContentId10(scope, value) : void 0,
        "data-ownedby": getListId2(scope),
        "data-ssr": dataAttr(context.get("ssr")),
        id: getTriggerId10(scope, value),
        tabIndex: triggerState.selected && composite ? 0 : -1,
        onFocus() {
          send({ type: "TAB_FOCUS", value });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if (target?.getAttribute("role") !== "tab") {
            send({ type: "TAB_BLUR" });
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (isOpeningInNewTab(event)) return;
          if (disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TAB_CLICK", value });
        }
      });
    },
    getContentProps(props25) {
      const { value } = props25;
      const selected = context.get("value") === value;
      return normalize2.element({
        ...parts20.content.attrs,
        dir: prop("dir"),
        id: getContentId10(scope, value),
        tabIndex: composite ? 0 : -1,
        "aria-labelledby": getTriggerId10(scope, value),
        role: "tabpanel",
        "data-ownedby": getListId2(scope),
        "data-selected": dataAttr(selected),
        "data-orientation": prop("orientation"),
        hidden: !selected
      });
    },
    getIndicatorProps() {
      const rect = context.get("indicatorRect");
      const rectIsEmpty = rect == null || rect.width === 0 && rect.height === 0 && rect.x === 0 && rect.y === 0;
      return normalize2.element({
        id: getIndicatorId3(scope),
        ...parts20.indicator.attrs,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        hidden: rectIsEmpty,
        style: {
          "--transition-property": "left, right, top, bottom, width, height",
          "--left": toPx(rect?.x),
          "--top": toPx(rect?.y),
          "--width": toPx(rect?.width),
          "--height": toPx(rect?.height),
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: "var(--transition-duration, 150ms)",
          transitionTimingFunction: "var(--transition-timing-function)",
          [isHorizontal ? "left" : "top"]: isHorizontal ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { createMachine: createMachine4 } = setup();
var machine20 = createMachine4({
  props({ props: props25 }) {
    return {
      dir: "ltr",
      orientation: "horizontal",
      activationMode: "automatic",
      loopFocus: true,
      composite: true,
      navigate(details) {
        clickIfLink(details.node);
      },
      defaultValue: null,
      ...props25
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable: bindable2 }) {
    return {
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      focusedValue: bindable2(() => ({
        defaultValue: prop("value") || prop("defaultValue"),
        sync: true,
        onChange(value) {
          prop("onFocusChange")?.({ focusedValue: value });
        }
      })),
      ssr: bindable2(() => ({ defaultValue: true })),
      indicatorRect: bindable2(() => ({
        defaultValue: null
      }))
    };
  },
  watch({ context, prop, track: track2, action }) {
    track2([() => context.get("value")], () => {
      action(["syncIndicatorRect", "syncTabIndex", "navigateIfNeeded"]);
    });
    track2([() => prop("dir"), () => prop("orientation")], () => {
      action(["syncIndicatorRect"]);
    });
  },
  on: {
    SET_VALUE: {
      actions: ["setValue"]
    },
    CLEAR_VALUE: {
      actions: ["clearValue"]
    },
    SET_INDICATOR_RECT: {
      actions: ["setIndicatorRect"]
    },
    SYNC_TAB_INDEX: {
      actions: ["syncTabIndex"]
    }
  },
  entry: ["syncIndicatorRect", "syncTabIndex", "syncSsr"],
  exit: ["cleanupObserver"],
  states: {
    idle: {
      on: {
        TAB_FOCUS: {
          target: "focused",
          actions: ["setFocusedValue"]
        },
        TAB_CLICK: {
          target: "focused",
          actions: ["setFocusedValue", "setValue"]
        }
      }
    },
    focused: {
      on: {
        TAB_CLICK: {
          actions: ["setFocusedValue", "setValue"]
        },
        ARROW_PREV: [
          {
            guard: "selectOnFocus",
            actions: ["focusPrevTab", "selectFocusedTab"]
          },
          {
            actions: ["focusPrevTab"]
          }
        ],
        ARROW_NEXT: [
          {
            guard: "selectOnFocus",
            actions: ["focusNextTab", "selectFocusedTab"]
          },
          {
            actions: ["focusNextTab"]
          }
        ],
        HOME: [
          {
            guard: "selectOnFocus",
            actions: ["focusFirstTab", "selectFocusedTab"]
          },
          {
            actions: ["focusFirstTab"]
          }
        ],
        END: [
          {
            guard: "selectOnFocus",
            actions: ["focusLastTab", "selectFocusedTab"]
          },
          {
            actions: ["focusLastTab"]
          }
        ],
        TAB_FOCUS: {
          actions: ["setFocusedValue"]
        },
        TAB_BLUR: {
          target: "idle",
          actions: ["clearFocusedValue"]
        }
      }
    }
  },
  implementations: {
    guards: {
      selectOnFocus: ({ prop }) => prop("activationMode") === "automatic"
    },
    actions: {
      selectFocusedTab({ context, prop }) {
        raf(() => {
          const focusedValue = context.get("focusedValue");
          if (!focusedValue) return;
          const nullable = prop("deselectable") && context.get("value") === focusedValue;
          const value = nullable ? null : focusedValue;
          context.set("value", value);
        });
      },
      setFocusedValue({ context, event, flush: flush2 }) {
        if (event.value == null) return;
        flush2(() => {
          context.set("focusedValue", event.value);
        });
      },
      clearFocusedValue({ context }) {
        context.set("focusedValue", null);
      },
      setValue({ context, event, prop }) {
        const nullable = prop("deselectable") && context.get("value") === context.get("focusedValue");
        context.set("value", nullable ? null : event.value);
      },
      clearValue({ context }) {
        context.set("value", null);
      },
      focusFirstTab({ scope }) {
        raf(() => {
          getFirstTriggerEl2(scope)?.focus();
        });
      },
      focusLastTab({ scope }) {
        raf(() => {
          getLastTriggerEl2(scope)?.focus();
        });
      },
      focusNextTab({ context, prop, scope, event }) {
        const focusedValue = event.value ?? context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getNextTriggerEl2(scope, {
          value: focusedValue,
          loopFocus: prop("loopFocus")
        });
        raf(() => {
          if (prop("composite")) {
            triggerEl?.focus();
          } else if (triggerEl?.dataset.value != null) {
            context.set("focusedValue", triggerEl.dataset.value);
          }
        });
      },
      focusPrevTab({ context, prop, scope, event }) {
        const focusedValue = event.value ?? context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getPrevTriggerEl2(scope, {
          value: focusedValue,
          loopFocus: prop("loopFocus")
        });
        raf(() => {
          if (prop("composite")) {
            triggerEl?.focus();
          } else if (triggerEl?.dataset.value != null) {
            context.set("focusedValue", triggerEl.dataset.value);
          }
        });
      },
      syncTabIndex({ context, scope }) {
        raf(() => {
          const value = context.get("value");
          if (!value) return;
          const contentEl = getContentEl9(scope, value);
          if (!contentEl) return;
          const focusables = getFocusables(contentEl);
          if (focusables.length > 0) {
            contentEl.removeAttribute("tabindex");
          } else {
            contentEl.setAttribute("tabindex", "0");
          }
        });
      },
      cleanupObserver({ refs }) {
        const cleanup = refs.get("indicatorCleanup");
        if (cleanup) cleanup();
      },
      setIndicatorRect({ context, event, scope }) {
        const value = event.id ?? context.get("value");
        const indicatorEl = getIndicatorEl3(scope);
        if (!indicatorEl) return;
        if (!value) return;
        const triggerEl = getTriggerEl7(scope, value);
        if (!triggerEl) return;
        context.set("indicatorRect", getRectByValue(scope, value));
      },
      syncSsr({ context }) {
        context.set("ssr", false);
      },
      syncIndicatorRect({ context, refs, scope }) {
        const cleanup = refs.get("indicatorCleanup");
        if (cleanup) cleanup();
        const indicatorEl = getIndicatorEl3(scope);
        if (!indicatorEl) return;
        const exec = () => {
          const triggerEl = getTriggerEl7(scope, context.get("value"));
          if (!triggerEl) return;
          const rect = getOffsetRect3(triggerEl);
          context.set("indicatorRect", (prev2) => isEqual(prev2, rect) ? prev2 : rect);
        };
        exec();
        const triggerEls = getElements2(scope);
        const indicatorCleanup = callAll(...triggerEls.map((el) => resizeObserverBorderBox.observe(el, exec)));
        refs.set("indicatorCleanup", indicatorCleanup);
      },
      navigateIfNeeded({ context, prop, scope }) {
        const value = context.get("value");
        if (!value) return;
        const triggerEl = getTriggerEl7(scope, value);
        if (isAnchorElement(triggerEl)) {
          prop("navigate")?.({ value, node: triggerEl, href: triggerEl.href });
        }
      }
    }
  }
});
var props20 = createProps()([
  "activationMode",
  "composite",
  "deselectable",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "translations",
  "value",
  "defaultValue"
]);
var splitProps21 = createSplitProps(props20);
var triggerProps = createProps()(["disabled", "value"]);
var splitTriggerProps = createSplitProps(triggerProps);
var contentProps = createProps()(["value"]);
var splitContentProps = createSplitProps(contentProps);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/content.svelte
Content11[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/content.svelte";
var root_2193 = add_locations(from_html(`<div><!></div>`), Content11[FILENAME], [[27, 1]]);
function Content11($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content11);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tabs = RootContext21.consume();
  const $$d = user_derived(() => splitContentProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), contentProps2 = tag(user_derived(() => get($$array)[0]), "contentProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tabs().getContentProps(get(contentProps2)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content11, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2193();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content11, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content11,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content11 = hmr(Content11);
  import.meta.hot.accept((module) => {
    Content11[HMR].update(module.default);
  });
}
var content_default11 = Content11;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/indicator.svelte
Indicator6[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/indicator.svelte";
var root_2194 = add_locations(from_html(`<div></div>`), Indicator6[FILENAME], [[24, 1]]);
function Indicator6($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Indicator6);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tabs = RootContext21.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tabs().getIndicatorProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Indicator6, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2194();
      attribute_effect(div, () => ({ ...get(attributes) }));
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Indicator6,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Indicator6 = hmr(Indicator6);
  import.meta.hot.accept((module) => {
    Indicator6[HMR].update(module.default);
  });
}
var indicator_default6 = Indicator6;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/list.svelte
List2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/list.svelte";
var root_2195 = add_locations(from_html(`<div><!></div>`), List2[FILENAME], [[24, 1]]);
function List2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, List2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tabs = RootContext21.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tabs().getListProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", List2, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2195();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", List2, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      List2,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  List2 = hmr(List2);
  import.meta.hot.accept((module) => {
    List2[HMR].update(module.default);
  });
}
var list_default2 = List2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/root-context.svelte
Root_context20[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/root-context.svelte";
function Root_context20($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context20);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tabs = RootContext21.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => tabs), "render", Root_context20, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context20 = hmr(Root_context20);
  import.meta.hot.accept((module) => {
    Root_context20[HMR].update(module.default);
  });
}
var root_context_default20 = Root_context20;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/root-provider.svelte
Root_provider20[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/root-provider.svelte";
var root_2196 = add_locations(from_html(`<div><!></div>`), Root_provider20[FILENAME], [[26, 1]]);
function Root_provider20($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider20);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), tabs = tag(user_derived(() => $$props.value), "tabs"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(tabs)().getRootProps(), get(rest))), "attributes");
  RootContext21.provide(() => get(tabs)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider20, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2196();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider20, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider20,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider20 = hmr(Root_provider20);
  import.meta.hot.accept((module) => {
    Root_provider20[HMR].update(module.default);
  });
}
var root_provider_default20 = Root_provider20;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/modules/provider.svelte.js
function useTabs(props25) {
  const service = useMachine(machine20, props25);
  const tabs = tag(user_derived(() => connect20(service, normalizeProps)), "tabs");
  return () => get(tabs);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/root.svelte
Root23[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/root.svelte";
var root_2197 = add_locations(from_html(`<div><!></div>`), Root23[FILENAME], [[33, 1]]);
function Root23($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root23);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps21(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), tabsProps = tag(user_derived(() => get($$array)[0]), "tabsProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const tabs = useTabs(() => ({ ...get(tabsProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(tabs().getRootProps(), get(rest))), "attributes");
  RootContext21.provide(() => tabs());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root23, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2197();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root23, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root23,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root23 = hmr(Root23);
  import.meta.hot.accept((module) => {
    Root23[HMR].update(module.default);
  });
}
var root_default23 = Root23;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/trigger.svelte
Trigger11[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/anatomy/trigger.svelte";
var root_2198 = add_locations(from_html(`<button><!></button>`), Trigger11[FILENAME], [[27, 1]]);
function Trigger11($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger11);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tabs = RootContext21.consume();
  const $$d = user_derived(() => splitTriggerProps(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), triggerProps2 = tag(user_derived(() => get($$array)[0]), "triggerProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tabs().getTriggerProps(get(triggerProps2)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger11, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2198();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger11, 28, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger11,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger11 = hmr(Trigger11);
  import.meta.hot.accept((module) => {
    Trigger11[HMR].update(module.default);
  });
}
var trigger_default11 = Trigger11;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tabs/modules/anatomy.js
var Tabs = Object.assign(root_default23, {
  Provider: root_provider_default20,
  Context: root_context_default20,
  List: list_default2,
  Trigger: trigger_default11,
  Indicator: indicator_default6,
  Content: content_default11
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/modules/root-context.js
var RootContext22 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/clear-trigger.svelte
Clear_trigger3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/clear-trigger.svelte";
var root_2199 = add_locations(from_html(`<button><!></button>`), Clear_trigger3[FILENAME], [[24, 1]]);
function Clear_trigger3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Clear_trigger3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getClearTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Clear_trigger3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2199();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Clear_trigger3, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Clear_trigger3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Clear_trigger3 = hmr(Clear_trigger3);
  import.meta.hot.accept((module) => {
    Clear_trigger3[HMR].update(module.default);
  });
}
var clear_trigger_default3 = Clear_trigger3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/control.svelte
Control9[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/control.svelte";
var root_2200 = add_locations(from_html(`<div><!></div>`), Control9[FILENAME], [[24, 1]]);
function Control9($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control9);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getControlProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Control9, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2200();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Control9, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Control9,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Control9 = hmr(Control9);
  import.meta.hot.accept((module) => {
    Control9[HMR].update(module.default);
  });
}
var control_default9 = Control9;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/hidden-input.svelte
Hidden_input5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/hidden-input.svelte";
var root_2201 = add_locations(from_html(`<input/>`), Hidden_input5[FILENAME], [[24, 1]]);
function Hidden_input5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Hidden_input5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getHiddenInputProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Hidden_input5, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_2201();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Hidden_input5,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Hidden_input5 = hmr(Hidden_input5);
  import.meta.hot.accept((module) => {
    Hidden_input5[HMR].update(module.default);
  });
}
var hidden_input_default5 = Hidden_input5;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/input.svelte
Input4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/input.svelte";
var root_2202 = add_locations(from_html(`<input/>`), Input4[FILENAME], [[24, 1]]);
function Input4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Input4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getInputProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Input4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_2202();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Input4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Input4 = hmr(Input4);
  import.meta.hot.accept((module) => {
    Input4[HMR].update(module.default);
  });
}
var input_default4 = Input4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/modules/item-context.js
var ItemContext8 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item-delete-trigger.svelte
Item_delete_trigger2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item-delete-trigger.svelte";
var times2 = wrap_snippet(Item_delete_trigger2, function($$anchor) {
  validate_snippet_args(...arguments);
  next();
  var text2 = text("");
  append($$anchor, text2);
});
var root_311 = add_locations(from_html(`<button><!></button>`), Item_delete_trigger2[FILENAME], [[30, 1]]);
function Item_delete_trigger2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_delete_trigger2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const itemProps13 = ItemContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, times2)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getItemDeleteTriggerProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_delete_trigger2, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_311();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children)), "render", Item_delete_trigger2, 31, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_delete_trigger2,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_delete_trigger2 = hmr(Item_delete_trigger2);
  import.meta.hot.accept((module) => {
    Item_delete_trigger2[HMR].update(module.default);
  });
}
var item_delete_trigger_default2 = Item_delete_trigger2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item-input.svelte
Item_input[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item-input.svelte";
var root_2203 = add_locations(from_html(`<input/>`), Item_input[FILENAME], [[26, 1]]);
function Item_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_input);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const itemProps13 = ItemContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), rest = tag(user_derived(() => exclude_from_object(props25, ["element"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getItemInputProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_input, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_2203();
      attribute_effect(input, () => ({ ...get(attributes) }), void 0, void 0, void 0, void 0, true);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_input,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_input = hmr(Item_input);
  import.meta.hot.accept((module) => {
    Item_input[HMR].update(module.default);
  });
}
var item_input_default = Item_input;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item-preview.svelte
Item_preview[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item-preview.svelte";
var root_2204 = add_locations(from_html(`<div><!></div>`), Item_preview[FILENAME], [[26, 1]]);
function Item_preview($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_preview);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const itemProps13 = ItemContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getItemPreviewProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_preview, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2204();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_preview, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_preview,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_preview = hmr(Item_preview);
  import.meta.hot.accept((module) => {
    Item_preview[HMR].update(module.default);
  });
}
var item_preview_default = Item_preview;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item-text.svelte
Item_text5[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item-text.svelte";
var root_2205 = add_locations(from_html(`<span><!></span>`), Item_text5[FILENAME], [[26, 1]]);
function Item_text5($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item_text5);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const itemProps13 = ItemContext8.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getItemTextProps(itemProps13()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item_text5, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2205();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item_text5, 27, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item_text5,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item_text5 = hmr(Item_text5);
  import.meta.hot.accept((module) => {
    Item_text5[HMR].update(module.default);
  });
}
var item_text_default5 = Item_text5;

// node_modules/@zag-js/auto-resize/dist/index.mjs
function getVisualStyles(node) {
  if (!node) return;
  const style = getComputedStyle2(node);
  return "box-sizing:" + style.boxSizing + ";border-left:" + style.borderLeftWidth + " solid red;border-right:" + style.borderRightWidth + " solid red;font-family:" + style.fontFamily + ";font-feature-settings:" + style.fontFeatureSettings + ";font-kerning:" + style.fontKerning + ";font-size:" + style.fontSize + ";font-stretch:" + style.fontStretch + ";font-style:" + style.fontStyle + ";font-variant:" + style.fontVariant + ";font-variant-caps:" + style.fontVariantCaps + ";font-variant-ligatures:" + style.fontVariantLigatures + ";font-variant-numeric:" + style.fontVariantNumeric + ";font-weight:" + style.fontWeight + ";letter-spacing:" + style.letterSpacing + ";margin-left:" + style.marginLeft + ";margin-right:" + style.marginRight + ";padding-left:" + style.paddingLeft + ";padding-right:" + style.paddingRight + ";text-indent:" + style.textIndent + ";text-transform:" + style.textTransform;
}
function createGhostElement(doc) {
  var el = doc.createElement("div");
  el.id = "ghost";
  el.style.cssText = "display:inline-block;height:0;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:nowrap;";
  doc.body.appendChild(el);
  return el;
}
function autoResizeInput(input) {
  if (!input) return;
  const doc = getDocument(input);
  const win = getWindow(input);
  const ghost = createGhostElement(doc);
  const cssText = getVisualStyles(input);
  if (cssText) ghost.style.cssText += cssText;
  function resize() {
    win.requestAnimationFrame(() => {
      ghost.innerHTML = input.value;
      const rect = win.getComputedStyle(ghost);
      input?.style.setProperty("width", rect.width);
    });
  }
  resize();
  input?.addEventListener("input", resize);
  input?.addEventListener("change", resize);
  return () => {
    doc.body.removeChild(ghost);
    input?.removeEventListener("input", resize);
    input?.removeEventListener("change", resize);
  };
}

// node_modules/@zag-js/tags-input/dist/index.mjs
var anatomy21 = createAnatomy("tagsInput").parts(
  "root",
  "label",
  "control",
  "input",
  "clearTrigger",
  "item",
  "itemPreview",
  "itemInput",
  "itemText",
  "itemDeleteTrigger"
);
var parts21 = anatomy21.build();
var getRootId17 = (ctx) => ctx.ids?.root ?? `tags-input:${ctx.id}`;
var getInputId3 = (ctx) => ctx.ids?.input ?? `tags-input:${ctx.id}:input`;
var getClearTriggerId3 = (ctx) => ctx.ids?.clearBtn ?? `tags-input:${ctx.id}:clear-btn`;
var getHiddenInputId5 = (ctx) => ctx.ids?.hiddenInput ?? `tags-input:${ctx.id}:hidden-input`;
var getLabelId10 = (ctx) => ctx.ids?.label ?? `tags-input:${ctx.id}:label`;
var getControlId6 = (ctx) => ctx.ids?.control ?? `tags-input:${ctx.id}:control`;
var getItemId10 = (ctx, opt) => ctx.ids?.item?.(opt) ?? `tags-input:${ctx.id}:tag:${opt.value}:${opt.index}`;
var getItemDeleteTriggerId2 = (ctx, opt) => ctx.ids?.itemDeleteTrigger?.(opt) ?? `${getItemId10(ctx, opt)}:delete-btn`;
var getItemInputId = (ctx, opt) => ctx.ids?.itemInput?.(opt) ?? `${getItemId10(ctx, opt)}:input`;
var getEditInputId = (id) => `${id}:input`;
var getEditInputEl = (ctx, id) => ctx.getById(getEditInputId(id));
var getItemEls2 = (ctx) => queryAll(getRootEl7(ctx), `[data-part=item]`);
var getTagInputEl = (ctx, opt) => ctx.getById(getItemInputId(ctx, opt));
var getRootEl7 = (ctx) => ctx.getById(getRootId17(ctx));
var getInputEl2 = (ctx) => ctx.getById(getInputId3(ctx));
var getHiddenInputEl5 = (ctx) => ctx.getById(getHiddenInputId5(ctx));
var getTagElements = (ctx) => queryAll(getRootEl7(ctx), `[data-part=item-preview]:not([data-disabled])`);
var getFirstEl2 = (ctx) => getTagElements(ctx)[0];
var getLastEl2 = (ctx) => getTagElements(ctx)[getTagElements(ctx).length - 1];
var getPrevEl2 = (ctx, id) => prevById(getTagElements(ctx), id, false);
var getNextEl2 = (ctx, id) => nextById(getTagElements(ctx), id, false);
var getTagElAtIndex = (ctx, index) => getTagElements(ctx)[index];
var getIndexOfId = (ctx, id) => indexOfId(getTagElements(ctx), id);
var setHoverIntent = (el) => {
  const tagEl = el.closest("[data-part=item-preview]");
  if (!tagEl) return;
  tagEl.dataset.deleteIntent = "";
};
var clearHoverIntent = (el) => {
  const tagEl = el.closest("[data-part=item-preview]");
  if (!tagEl) return;
  delete tagEl.dataset.deleteIntent;
};
var dispatchInputEvent = (ctx, value) => {
  const inputEl = getHiddenInputEl5(ctx);
  if (!inputEl) return;
  dispatchInputValueEvent(inputEl, { value });
};
function connect21(service, normalize2) {
  const { state: state3, send, computed, prop, scope, context } = service;
  const interactive = computed("isInteractive");
  const disabled = !!prop("disabled");
  const readOnly = !!prop("readOnly");
  const required = !!prop("required");
  const invalid = prop("invalid") || computed("isOverflowing");
  const translations = prop("translations");
  const focused = state3.hasTag("focused");
  const editingTag = state3.matches("editing:tag");
  const empty = computed("count") === 0;
  function getItemState(options) {
    const id = getItemId10(scope, options);
    const editedTagId = context.get("editedTagId");
    const highlightedTagId = context.get("highlightedTagId");
    return {
      id,
      editing: editingTag && editedTagId === id,
      highlighted: id === highlightedTagId,
      disabled: Boolean(options.disabled || disabled)
    };
  }
  return {
    empty,
    inputValue: computed("trimmedInputValue"),
    value: context.get("value"),
    valueAsString: computed("valueAsString"),
    count: computed("count"),
    atMax: computed("isAtMax"),
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue(id) {
      if (id) {
        send({ type: "CLEAR_TAG", id });
      } else {
        send({ type: "CLEAR_VALUE" });
      }
    },
    addValue(value) {
      send({ type: "ADD_TAG", value });
    },
    setValueAtIndex(index, value) {
      send({ type: "SET_VALUE_AT_INDEX", index, value });
    },
    setInputValue(value) {
      send({ type: "SET_INPUT_VALUE", value });
    },
    clearInputValue() {
      send({ type: "SET_INPUT_VALUE", value: "" });
    },
    focus() {
      getInputEl2(scope)?.focus();
    },
    getItemState,
    getRootProps() {
      return normalize2.element({
        dir: prop("dir"),
        ...parts21.root.attrs,
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-empty": dataAttr(empty),
        id: getRootId17(scope),
        onPointerDown() {
          if (!interactive) return;
          send({ type: "POINTER_DOWN" });
        }
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts21.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-required": dataAttr(required),
        id: getLabelId10(scope),
        dir: prop("dir"),
        htmlFor: getInputId3(scope)
      });
    },
    getControlProps() {
      return normalize2.element({
        id: getControlId6(scope),
        ...parts21.control.attrs,
        dir: prop("dir"),
        tabIndex: readOnly ? 0 : void 0,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts21.input.attrs,
        dir: prop("dir"),
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-empty": dataAttr(empty),
        maxLength: prop("maxLength"),
        id: getInputId3(scope),
        defaultValue: context.get("inputValue"),
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "none",
        disabled: disabled || readOnly,
        onInput(event) {
          const evt = getNativeEvent(event);
          const value = event.currentTarget.value;
          if (evt.inputType === "insertFromPaste") {
            send({ type: "PASTE", value });
            return;
          }
          if (endsWith(value, prop("delimiter"))) {
            send({ type: "DELIMITER_KEY" });
            return;
          }
          send({ type: "TYPE", value, key: evt.inputType });
        },
        onFocus() {
          queueMicrotask(() => {
            send({ type: "FOCUS" });
          });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const target = event.currentTarget;
          const isCombobox = target.getAttribute("role") === "combobox";
          const isExpanded = target.ariaExpanded === "true";
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowLeft() {
              if (isCombobox && isExpanded) return;
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight(event2) {
              if (context.get("highlightedTagId")) {
                event2.preventDefault();
              }
              if (isCombobox && isExpanded) return;
              send({ type: "ARROW_RIGHT" });
            },
            Escape(event2) {
              event2.preventDefault();
              send({ type: "ESCAPE" });
            },
            Backspace() {
              send({ type: "BACKSPACE" });
            },
            Delete() {
              send({ type: "DELETE" });
            },
            Enter(event2) {
              const hasHighlightedItem = target.getAttribute("aria-activedescendant");
              if (isCombobox && isExpanded && hasHighlightedItem) return;
              send({ type: "ENTER" });
              event2.preventDefault();
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            return;
          }
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        type: "text",
        hidden: true,
        name: prop("name"),
        form: prop("form"),
        disabled,
        readOnly,
        required: prop("required"),
        id: getHiddenInputId5(scope),
        defaultValue: computed("valueAsString")
      });
    },
    getItemProps(props25) {
      return normalize2.element({
        ...parts21.item.attrs,
        dir: prop("dir"),
        "data-value": props25.value,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts21.itemPreview.attrs,
        id: itemState.id,
        dir: prop("dir"),
        hidden: itemState.editing,
        "data-value": props25.value,
        "data-disabled": dataAttr(disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        onPointerDown(event) {
          if (!interactive || itemState.disabled) return;
          if (!isLeftClick(event)) return;
          event.preventDefault();
          send({ type: "POINTER_DOWN_TAG", id: itemState.id });
        },
        onDoubleClick() {
          if (!interactive || itemState.disabled) return;
          send({ type: "DOUBLE_CLICK_TAG", id: itemState.id });
        }
      });
    },
    getItemTextProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts21.itemText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemInputProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.input({
        ...parts21.itemInput.attrs,
        dir: prop("dir"),
        "aria-label": translations?.tagEdited?.(props25.value),
        disabled,
        id: getItemInputId(scope, props25),
        tabIndex: -1,
        hidden: !itemState.editing,
        maxLength: prop("maxLength"),
        defaultValue: itemState.editing ? context.get("editedTagValue") : "",
        onInput(event) {
          send({ type: "TAG_INPUT_TYPE", value: event.currentTarget.value });
        },
        onBlur(event) {
          queueMicrotask(() => {
            send({ type: "TAG_INPUT_BLUR", target: event.relatedTarget, id: itemState.id });
          });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            Enter() {
              send({ type: "TAG_INPUT_ENTER" });
            },
            Escape() {
              send({ type: "TAG_INPUT_ESCAPE" });
            }
          };
          const exec = keyMap2[event.key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        }
      });
    },
    getItemDeleteTriggerProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.button({
        ...parts21.itemDeleteTrigger.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(itemState.disabled),
        "aria-disabled": itemState.disabled,
        "data-highlighted": dataAttr(itemState.highlighted),
        id: getItemDeleteTriggerId2(scope, props25),
        type: "button",
        disabled: itemState.disabled,
        "aria-label": translations?.deleteTagTriggerLabel?.(props25.value),
        tabIndex: -1,
        onPointerDown(event) {
          if (!isLeftClick(event)) return;
          if (!interactive) {
            event.preventDefault();
          }
        },
        onPointerMove(event) {
          if (!interactive) return;
          setHoverIntent(event.currentTarget);
        },
        onPointerLeave(event) {
          if (!interactive) return;
          clearHoverIntent(event.currentTarget);
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "CLICK_DELETE_TAG", id: itemState.id });
        }
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts21.clearTrigger.attrs,
        dir: prop("dir"),
        id: getClearTriggerId3(scope),
        type: "button",
        "data-readonly": dataAttr(readOnly),
        disabled,
        "aria-label": translations?.clearTriggerLabel,
        hidden: empty,
        onClick() {
          if (!interactive) return;
          send({ type: "CLEAR_VALUE" });
        }
      });
    }
  };
}
function endsWith(str, del) {
  if (!del) return false;
  if (typeof del === "string") return str.endsWith(del);
  return new RegExp(`${del.source}$`).test(str);
}
var { and: and6, not: not7, or: or3 } = createGuards();
var machine21 = createMachine({
  props({ props: props25 }) {
    return {
      dir: "ltr",
      addOnPaste: false,
      editable: true,
      validate: () => true,
      delimiter: ",",
      defaultValue: [],
      defaultInputValue: "",
      max: Infinity,
      ...props25,
      translations: {
        clearTriggerLabel: "Clear all tags",
        deleteTagTriggerLabel: (value) => `Delete tag ${value}`,
        tagAdded: (value) => `Added tag ${value}`,
        tagsPasted: (values) => `Pasted ${values.length} tags`,
        tagEdited: (value) => `Editing tag ${value}. Press enter to save or escape to cancel.`,
        tagUpdated: (value) => `Tag update to ${value}`,
        tagDeleted: (value) => `Tag ${value} deleted`,
        tagSelected: (value) => `Tag ${value} selected. Press enter to edit, delete or backspace to remove.`,
        ...props25.translations
      }
    };
  },
  initialState({ prop }) {
    return prop("autoFocus") ? "focused:input" : "idle";
  },
  refs() {
    return {
      liveRegion: null,
      log: { current: null, prev: null }
    };
  },
  context({ bindable: bindable2, prop }) {
    return {
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        hash(value) {
          return value.join(", ");
        },
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      inputValue: bindable2(() => ({
        sync: true,
        defaultValue: prop("defaultInputValue"),
        value: prop("inputValue"),
        onChange(value) {
          prop("onInputValueChange")?.({ inputValue: value });
        }
      })),
      fieldsetDisabled: bindable2(() => ({ defaultValue: false })),
      editedTagValue: bindable2(() => ({ defaultValue: "" })),
      editedTagId: bindable2(() => ({ defaultValue: null })),
      editedTagIndex: bindable2(() => ({
        defaultValue: null,
        sync: true
      })),
      highlightedTagId: bindable2(() => ({
        defaultValue: null,
        sync: true,
        onChange(value) {
          prop("onHighlightChange")?.({ highlightedValue: value });
        }
      }))
    };
  },
  computed: {
    count: ({ context }) => context.get("value").length,
    valueAsString: ({ context }) => context.hash("value"),
    trimmedInputValue: ({ context }) => context.get("inputValue").trim(),
    isDisabled: ({ prop }) => !!prop("disabled"),
    isInteractive: ({ prop }) => !(prop("readOnly") || !!prop("disabled")),
    isAtMax: ({ context, prop }) => context.get("value").length === prop("max"),
    isOverflowing: ({ context, prop }) => context.get("value").length > prop("max")
  },
  watch({ track: track2, context, action, computed, refs }) {
    track2([() => context.get("editedTagValue")], () => {
      action(["syncEditedTagInputValue"]);
    });
    track2([() => context.get("inputValue")], () => {
      action(["syncInputValue"]);
    });
    track2([() => context.get("highlightedTagId")], () => {
      action(["logHighlightedTag"]);
    });
    track2([() => computed("isOverflowing")], () => {
      action(["invokeOnInvalid"]);
    });
    track2([() => JSON.stringify(refs.get("log"))], () => {
      action(["announceLog"]);
    });
  },
  effects: ["trackLiveRegion", "trackFormControlState"],
  exit: ["clearLog"],
  on: {
    DOUBLE_CLICK_TAG: {
      // internal: true,
      guard: "isTagEditable",
      target: "editing:tag",
      actions: ["setEditedId"]
    },
    POINTER_DOWN_TAG: {
      // internal: true,
      target: "navigating:tag",
      actions: ["highlightTag", "focusInput"]
    },
    CLICK_DELETE_TAG: {
      target: "focused:input",
      actions: ["deleteTag"]
    },
    SET_INPUT_VALUE: {
      actions: ["setInputValue"]
    },
    SET_VALUE: {
      actions: ["setValue"]
    },
    CLEAR_TAG: {
      actions: ["deleteTag"]
    },
    SET_VALUE_AT_INDEX: {
      actions: ["setValueAtIndex"]
    },
    CLEAR_VALUE: {
      actions: ["clearTags", "clearInputValue", "focusInput"]
    },
    ADD_TAG: {
      actions: ["addTag"]
    },
    INSERT_TAG: {
      // (!isAtMax || allowOverflow) && !inputValueIsEmpty
      guard: and6(or3(not7("isAtMax"), "allowOverflow"), not7("isInputValueEmpty")),
      actions: ["addTag", "clearInputValue"]
    },
    EXTERNAL_BLUR: [
      { guard: "addOnBlur", actions: ["raiseInsertTagEvent"] },
      { guard: "clearOnBlur", actions: ["clearInputValue"] }
    ]
  },
  states: {
    idle: {
      on: {
        FOCUS: {
          target: "focused:input"
        },
        POINTER_DOWN: {
          guard: not7("hasHighlightedTag"),
          target: "focused:input"
        }
      }
    },
    "focused:input": {
      tags: ["focused"],
      entry: ["focusInput", "clearHighlightedId"],
      effects: ["trackInteractOutside"],
      on: {
        TYPE: {
          actions: ["setInputValue"]
        },
        BLUR: [
          {
            guard: "addOnBlur",
            target: "idle",
            actions: ["raiseInsertTagEvent"]
          },
          {
            guard: "clearOnBlur",
            target: "idle",
            actions: ["clearInputValue"]
          },
          { target: "idle" }
        ],
        ENTER: {
          actions: ["raiseInsertTagEvent"]
        },
        DELIMITER_KEY: {
          actions: ["raiseInsertTagEvent"]
        },
        ARROW_LEFT: {
          guard: and6("hasTags", "isCaretAtStart"),
          target: "navigating:tag",
          actions: ["highlightLastTag"]
        },
        BACKSPACE: {
          target: "navigating:tag",
          guard: and6("hasTags", "isCaretAtStart"),
          actions: ["highlightLastTag"]
        },
        DELETE: {
          guard: "hasHighlightedTag",
          actions: ["deleteHighlightedTag", "highlightTagAtIndex"]
        },
        PASTE: [
          {
            guard: "addOnPaste",
            actions: ["setInputValue", "addTagFromPaste"]
          },
          {
            actions: ["setInputValue"]
          }
        ]
      }
    },
    "navigating:tag": {
      tags: ["focused"],
      effects: ["trackInteractOutside"],
      on: {
        ARROW_RIGHT: [
          {
            guard: and6("hasTags", "isCaretAtStart", not7("isLastTagHighlighted")),
            actions: ["highlightNextTag"]
          },
          { target: "focused:input" }
        ],
        ARROW_LEFT: [
          {
            guard: not7("isCaretAtStart"),
            target: "focused:input"
          },
          {
            actions: ["highlightPrevTag"]
          }
        ],
        BLUR: {
          target: "idle",
          actions: ["clearHighlightedId"]
        },
        ENTER: {
          guard: and6("isTagEditable", "hasHighlightedTag"),
          target: "editing:tag",
          actions: ["setEditedId", "focusEditedTagInput"]
        },
        ARROW_DOWN: {
          target: "focused:input"
        },
        ESCAPE: {
          target: "focused:input"
        },
        TYPE: {
          target: "focused:input",
          actions: ["setInputValue"]
        },
        BACKSPACE: [
          {
            guard: not7("isCaretAtStart"),
            target: "focused:input"
          },
          {
            guard: "isFirstTagHighlighted",
            actions: ["deleteHighlightedTag", "highlightFirstTag"]
          },
          {
            guard: "hasHighlightedTag",
            actions: ["deleteHighlightedTag", "highlightPrevTag"]
          },
          {
            actions: ["highlightLastTag"]
          }
        ],
        DELETE: [
          {
            guard: not7("isCaretAtStart"),
            target: "focused:input"
          },
          {
            target: "focused:input",
            actions: ["deleteHighlightedTag", "highlightTagAtIndex"]
          }
        ],
        PASTE: [
          {
            guard: "addOnPaste",
            target: "focused:input",
            actions: ["setInputValue", "addTagFromPaste"]
          },
          {
            target: "focused:input",
            actions: ["setInputValue"]
          }
        ]
      }
    },
    "editing:tag": {
      tags: ["editing", "focused"],
      entry: ["focusEditedTagInput"],
      effects: ["autoResize"],
      on: {
        TAG_INPUT_TYPE: {
          actions: ["setEditedTagValue"]
        },
        TAG_INPUT_ESCAPE: {
          target: "navigating:tag",
          actions: ["clearEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
        },
        TAG_INPUT_BLUR: [
          {
            guard: "isInputRelatedTarget",
            target: "navigating:tag",
            actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId"]
          },
          {
            target: "idle",
            actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId", "raiseExternalBlurEvent"]
          }
        ],
        TAG_INPUT_ENTER: [
          {
            guard: "isEditedTagEmpty",
            target: "navigating:tag",
            actions: ["deleteHighlightedTag", "focusInput", "clearEditedId", "highlightTagAtIndex"]
          },
          {
            target: "navigating:tag",
            actions: ["submitEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isInputRelatedTarget: ({ scope, event }) => event.relatedTarget === getInputEl2(scope),
      isAtMax: ({ computed }) => computed("isAtMax"),
      hasHighlightedTag: ({ context }) => context.get("highlightedTagId") != null,
      isFirstTagHighlighted: ({ context, scope }) => {
        const value = context.get("value");
        const firstItemId = getItemId10(scope, { value: value[0], index: 0 });
        return firstItemId === context.get("highlightedTagId");
      },
      isEditedTagEmpty: ({ context }) => context.get("editedTagValue").trim() === "",
      isLastTagHighlighted: ({ context, scope }) => {
        const value = context.get("value");
        const lastIndex = value.length - 1;
        const lastItemId = getItemId10(scope, { value: value[lastIndex], index: lastIndex });
        return lastItemId === context.get("highlightedTagId");
      },
      isInputValueEmpty: ({ context }) => context.get("inputValue").trim().length === 0,
      hasTags: ({ context }) => context.get("value").length > 0,
      allowOverflow: ({ prop }) => !!prop("allowOverflow"),
      autoFocus: ({ prop }) => !!prop("autoFocus"),
      addOnBlur: ({ prop }) => prop("blurBehavior") === "add",
      clearOnBlur: ({ prop }) => prop("blurBehavior") === "clear",
      addOnPaste: ({ prop }) => !!prop("addOnPaste"),
      isTagEditable: ({ prop }) => !!prop("editable"),
      isCaretAtStart: ({ scope }) => isCaretAtStart(getInputEl2(scope))
    },
    effects: {
      trackInteractOutside({ scope, prop, send }) {
        return trackInteractOutside(getInputEl2(scope), {
          exclude(target) {
            const itemEls = getItemEls2(scope);
            return itemEls.some((el) => contains(el, target));
          },
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (event.defaultPrevented) return;
            send({ type: "BLUR", src: "interact-outside" });
          }
        });
      },
      trackFormControlState({ context, send, scope }) {
        return trackFormControl(getHiddenInputEl5(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            const value = context.initial("value");
            send({ type: "SET_VALUE", value, src: "form-reset" });
          }
        });
      },
      autoResize({ context, prop, scope }) {
        let fn_cleanup;
        queueMicrotask(() => {
          const editedTagValue = context.get("editedTagValue");
          const editedTagIndex = context.get("editedTagIndex");
          if (!editedTagValue || editedTagIndex == null || !prop("editable")) return;
          const inputEl = getTagInputEl(scope, {
            value: editedTagValue,
            index: editedTagIndex
          });
          fn_cleanup = autoResizeInput(inputEl);
        });
        return () => {
          fn_cleanup?.();
        };
      },
      trackLiveRegion({ scope, refs }) {
        const liveRegion = createLiveRegion({
          level: "assertive",
          document: scope.getDoc()
        });
        refs.set("liveRegion", liveRegion);
        return () => liveRegion.destroy();
      }
    },
    actions: {
      raiseInsertTagEvent({ send }) {
        send({ type: "INSERT_TAG" });
      },
      raiseExternalBlurEvent({ send, event }) {
        send({ type: "EXTERNAL_BLUR", id: event.id });
      },
      dispatchChangeEvent({ scope, computed }) {
        dispatchInputEvent(scope, computed("valueAsString"));
      },
      highlightNextTag({ context, scope }) {
        const highlightedTagId = context.get("highlightedTagId");
        if (highlightedTagId == null) return;
        const next3 = getNextEl2(scope, highlightedTagId);
        context.set("highlightedTagId", next3?.id ?? null);
      },
      highlightFirstTag({ context, scope }) {
        raf(() => {
          const first2 = getFirstEl2(scope);
          context.set("highlightedTagId", first2?.id ?? null);
        });
      },
      highlightLastTag({ context, scope }) {
        const last2 = getLastEl2(scope);
        context.set("highlightedTagId", last2?.id ?? null);
      },
      highlightPrevTag({ context, scope }) {
        const highlightedTagId = context.get("highlightedTagId");
        if (highlightedTagId == null) return;
        const prev2 = getPrevEl2(scope, highlightedTagId);
        context.set("highlightedTagId", prev2?.id ?? null);
      },
      highlightTag({ context, event }) {
        context.set("highlightedTagId", event.id);
      },
      highlightTagAtIndex({ context, scope }) {
        raf(() => {
          const idx = context.get("editedTagIndex");
          if (idx == null) return;
          const tagEl = getTagElAtIndex(scope, idx);
          if (tagEl == null) return;
          context.set("highlightedTagId", tagEl.id);
          context.set("editedTagIndex", null);
        });
      },
      deleteTag({ context, scope, event, refs }) {
        const index = getIndexOfId(scope, event.id);
        const value = context.get("value")[index];
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "delete", value }
        });
        context.set("value", (prev2) => removeAt(prev2, index));
      },
      deleteHighlightedTag({ context, scope, refs }) {
        const highlightedTagId = context.get("highlightedTagId");
        if (highlightedTagId == null) return;
        const index = getIndexOfId(scope, highlightedTagId);
        context.set("editedTagIndex", index);
        const value = context.get("value");
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "delete", value: value[index] }
        });
        context.set("value", (prev2) => removeAt(prev2, index));
      },
      setEditedId({ context, event, scope }) {
        const highlightedTagId = context.get("highlightedTagId");
        const editedTagId = event.id ?? highlightedTagId;
        context.set("editedTagId", editedTagId);
        const index = getIndexOfId(scope, editedTagId);
        const valueAtIndex = context.get("value")[index];
        context.set("editedTagIndex", index);
        context.set("editedTagValue", valueAtIndex);
      },
      clearEditedId({ context }) {
        context.set("editedTagId", null);
      },
      clearEditedTagValue({ context }) {
        context.set("editedTagValue", "");
      },
      setEditedTagValue({ context, event }) {
        context.set("editedTagValue", event.value);
      },
      submitEditedTagValue({ context, scope, refs }) {
        const editedTagId = context.get("editedTagId");
        if (!editedTagId) return;
        const index = getIndexOfId(scope, editedTagId);
        context.set("value", (prev2) => {
          const value = prev2.slice();
          value[index] = context.get("editedTagValue");
          return value;
        });
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "update", value: context.get("editedTagValue") }
        });
      },
      setValueAtIndex({ context, event, refs }) {
        if (event.value) {
          context.set("value", (prev2) => {
            const value = prev2.slice();
            value[event.index] = event.value;
            return value;
          });
          const prevLog = refs.get("log");
          refs.set("log", {
            prev: prevLog.current,
            current: { type: "update", value: event.value }
          });
        } else {
          warn("You need to provide a value for the tag");
        }
      },
      focusEditedTagInput({ context, scope }) {
        raf(() => {
          const editedTagId = context.get("editedTagId");
          if (!editedTagId) return;
          const editTagInputEl = getEditInputEl(scope, editedTagId);
          editTagInputEl?.select();
        });
      },
      setInputValue({ context, event }) {
        context.set("inputValue", event.value);
      },
      clearHighlightedId({ context }) {
        context.set("highlightedTagId", null);
      },
      focusInput({ scope }) {
        raf(() => {
          getInputEl2(scope)?.focus();
        });
      },
      clearInputValue({ context }) {
        raf(() => {
          context.set("inputValue", "");
        });
      },
      syncInputValue({ context, scope }) {
        const inputEl = getInputEl2(scope);
        if (!inputEl) return;
        setElementValue(inputEl, context.get("inputValue"));
      },
      syncEditedTagInputValue({ context, event, scope }) {
        const id = context.get("editedTagId") || context.get("highlightedTagId") || event.id;
        if (id == null) return;
        const editTagInputEl = getEditInputEl(scope, id);
        if (!editTagInputEl) return;
        setElementValue(editTagInputEl, context.get("editedTagValue"));
      },
      addTag({ context, event, computed, prop, refs }) {
        const inputValue = event.value ?? computed("trimmedInputValue");
        const value = context.get("value");
        const guard = prop("validate")?.({ inputValue, value: Array.from(value) });
        if (guard) {
          const nextValue = uniq(value.concat(inputValue));
          context.set("value", nextValue);
          const prevLog = refs.get("log");
          refs.set("log", {
            prev: prevLog.current,
            current: { type: "add", value: inputValue }
          });
        } else {
          prop("onValueInvalid")?.({ reason: "invalidTag" });
        }
      },
      addTagFromPaste({ context, computed, prop, refs }) {
        raf(() => {
          const inputValue = computed("trimmedInputValue");
          const value = context.get("value");
          const guard = prop("validate")?.({
            inputValue,
            value: Array.from(value)
          });
          if (guard) {
            const delimiter = prop("delimiter");
            const trimmedValue = delimiter ? inputValue.split(delimiter).map((v) => v.trim()) : [inputValue];
            const nextValue = uniq(value.concat(...trimmedValue));
            context.set("value", nextValue);
            const prevLog = refs.get("log");
            refs.set("log", {
              prev: prevLog.current,
              current: { type: "paste", values: trimmedValue }
            });
          } else {
            prop("onValueInvalid")?.({ reason: "invalidTag" });
          }
          context.set("inputValue", "");
        });
      },
      clearTags({ context, refs }) {
        context.set("value", []);
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "clear" }
        });
      },
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      invokeOnInvalid({ prop, computed }) {
        if (computed("isOverflowing")) {
          prop("onValueInvalid")?.({ reason: "rangeOverflow" });
        }
      },
      clearLog({ refs }) {
        const log = refs.get("log");
        log.prev = log.current = null;
      },
      logHighlightedTag({ refs, context, scope }) {
        const highlightedTagId = context.get("highlightedTagId");
        const log = refs.get("log");
        if (highlightedTagId == null || !log.current) return;
        const index = getIndexOfId(scope, highlightedTagId);
        const value = context.get("value")[index];
        const prevLog = refs.get("log");
        refs.set("log", {
          prev: prevLog.current,
          current: { type: "select", value }
        });
      },
      // queue logs with screen reader and get it announced
      announceLog({ refs, prop }) {
        const liveRegion = refs.get("liveRegion");
        const translations = prop("translations");
        const log = refs.get("log");
        if (!log.current || liveRegion == null) return;
        const region = liveRegion;
        const { current, prev: prev2 } = log;
        let msg;
        switch (current.type) {
          case "add":
            msg = translations.tagAdded(current.value);
            break;
          case "delete":
            msg = translations.tagDeleted(current.value);
            break;
          case "update":
            msg = translations.tagUpdated(current.value);
            break;
          case "paste":
            msg = translations.tagsPasted(current.values);
            break;
          case "select":
            msg = translations.tagSelected(current.value);
            if (prev2?.type === "delete") {
              msg = `${translations.tagDeleted(prev2.value)}. ${msg}`;
            } else if (prev2?.type === "update") {
              msg = `${translations.tagUpdated(prev2.value)}. ${msg}`;
            }
            break;
        }
        if (msg) region.announce(msg);
      }
    }
  }
});
var props21 = createProps()([
  "addOnPaste",
  "allowOverflow",
  "autoFocus",
  "blurBehavior",
  "delimiter",
  "dir",
  "disabled",
  "editable",
  "form",
  "getRootNode",
  "id",
  "ids",
  "inputValue",
  "invalid",
  "max",
  "maxLength",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInputValueChange",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueInvalid",
  "required",
  "readOnly",
  "translations",
  "validate",
  "value",
  "defaultValue",
  "defaultInputValue"
]);
var splitProps22 = createSplitProps(props21);
var itemProps10 = createProps()(["index", "disabled", "value"]);
var splitItemProps10 = createSplitProps(itemProps10);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item.svelte
Item11[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/item.svelte";
var root_2206 = add_locations(from_html(`<span><!></span>`), Item11[FILENAME], [[30, 1]]);
function Item11($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item11);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const $$d = user_derived(() => splitItemProps10(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getItemProps(get(itemProps13)), get(rest))), "attributes");
  ItemContext8.provide(() => get(itemProps13));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item11, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2206();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item11, 31, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item11,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item11 = hmr(Item11);
  import.meta.hot.accept((module) => {
    Item11[HMR].update(module.default);
  });
}
var item_default11 = Item11;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/label.svelte
Label11[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/label.svelte";
var root_2207 = add_locations(from_html(`<label><!></label>`), Label11[FILENAME], [[24, 1]]);
function Label11($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label11);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getLabelProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label11, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_2207();
      attribute_effect(label, () => ({ ...get(attributes) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Label11, 25, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label11,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label11 = hmr(Label11);
  import.meta.hot.accept((module) => {
    Label11[HMR].update(module.default);
  });
}
var label_default11 = Label11;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/root-context.svelte
Root_context21[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/root-context.svelte";
function Root_context21($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context21);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tagsInput = RootContext22.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => tagsInput), "render", Root_context21, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context21 = hmr(Root_context21);
  import.meta.hot.accept((module) => {
    Root_context21[HMR].update(module.default);
  });
}
var root_context_default21 = Root_context21;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/root-provider.svelte
Root_provider21[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/root-provider.svelte";
var root_2208 = add_locations(from_html(`<div><!></div>`), Root_provider21[FILENAME], [[26, 1]]);
function Root_provider21($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider21);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), tagsInput = tag(user_derived(() => $$props.value), "tagsInput"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(tagsInput)().getRootProps(), get(rest))), "attributes");
  RootContext22.provide(() => get(tagsInput)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider21, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2208();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider21, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider21,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider21 = hmr(Root_provider21);
  import.meta.hot.accept((module) => {
    Root_provider21[HMR].update(module.default);
  });
}
var root_provider_default21 = Root_provider21;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/modules/provider.svelte.js
function useTagsInput(props25) {
  const service = useMachine(machine21, props25);
  const tagsInput = tag(user_derived(() => connect21(service, normalizeProps)), "tagsInput");
  return () => get(tagsInput);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/root.svelte
Root24[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/anatomy/root.svelte";
var root_2209 = add_locations(from_html(`<div><!></div>`), Root24[FILENAME], [[33, 1]]);
function Root24($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root24);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps22(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), tagsInputProps = tag(user_derived(() => get($$array)[0]), "tagsInputProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const tagsInput = useTagsInput(() => ({ ...get(tagsInputProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(tagsInput().getRootProps(), get(rest))), "attributes");
  RootContext22.provide(() => tagsInput());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root24, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2209();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root24, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root24,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root24 = hmr(Root24);
  import.meta.hot.accept((module) => {
    Root24[HMR].update(module.default);
  });
}
var root_default24 = Root24;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tags-input/modules/anatomy.js
var TagsInput = Object.assign(root_default24, {
  Provider: root_provider_default21,
  Context: root_context_default21,
  Label: label_default11,
  Control: control_default9,
  Item: item_default11,
  ItemPreview: item_preview_default,
  ItemText: item_text_default5,
  ItemDeleteTrigger: item_delete_trigger_default2,
  ItemInput: item_input_default,
  Input: input_default4,
  ClearTrigger: clear_trigger_default3,
  HiddenInput: hidden_input_default5
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/modules/root-context.js
var RootContext23 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/action-trigger.svelte
Action_trigger[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/action-trigger.svelte";
var root_2210 = add_locations(from_html(`<button><!></button>`), Action_trigger[FILENAME], [[24, 1]]);
function Action_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Action_trigger);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const toast = RootContext23.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(toast().getActionTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Action_trigger, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2210();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Action_trigger, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Action_trigger,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Action_trigger = hmr(Action_trigger);
  import.meta.hot.accept((module) => {
    Action_trigger[HMR].update(module.default);
  });
}
var action_trigger_default = Action_trigger;

// node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/x.svelte
X[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/internal/components/x.svelte";
var root9 = add_locations(from_svg(`<svg><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg>`), X[FILENAME], [[31, 0, [[32, 1], [33, 1]]]]);
function X($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, X);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const rest = tag(user_derived(() => exclude_from_object(props25, [])), "rest");
  const attributes = tag(
    user_derived(() => mergeProps2(
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      get(rest)
    )),
    "attributes"
  );
  var $$exports = { ...legacy_api() };
  var svg = root9();
  attribute_effect(svg, () => ({ ...get(attributes) }));
  append($$anchor, svg);
  return pop($$exports);
}
if (import.meta.hot) {
  X = hmr(X);
  import.meta.hot.accept((module) => {
    X[HMR].update(module.default);
  });
}
var x_default = X;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/close-trigger.svelte
Close_trigger4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/close-trigger.svelte";
var x = wrap_snippet(Close_trigger4, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => x_default(node, {}), "component", Close_trigger4, 23, 1, { componentTag: "X" });
  append($$anchor, fragment);
});
var root_312 = add_locations(from_html(`<button><!></button>`), Close_trigger4[FILENAME], [[29, 1]]);
function Close_trigger4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Close_trigger4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const toast = RootContext23.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, x)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(toast().getCloseTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node_1 = first_child(fragment_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_2, () => get(element2), () => get(attributes)), "render", Close_trigger4, 27, 1);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var button = root_312();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_3 = child(button);
      add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Close_trigger4, 30, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Close_trigger4,
      26,
      0
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  Close_trigger4 = hmr(Close_trigger4);
  import.meta.hot.accept((module) => {
    Close_trigger4[HMR].update(module.default);
  });
}
var close_trigger_default4 = Close_trigger4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/description.svelte
Description3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/description.svelte";
var root_2211 = add_locations(from_html(`<div><!></div>`), Description3[FILENAME], [[24, 1]]);
function Description3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Description3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const toast = RootContext23.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(toast().getDescriptionProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Description3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2211();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Description3, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Description3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Description3 = hmr(Description3);
  import.meta.hot.accept((module) => {
    Description3[HMR].update(module.default);
  });
}
var description_default3 = Description3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/modules/group-context.js
var GroupContext = createContext();

// node_modules/@zag-js/toast/dist/index.mjs
var anatomy22 = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts22 = anatomy22.build();
var getRegionId = (placement) => `toast-group:${placement}`;
var getRegionEl = (ctx, placement) => ctx.getById(`toast-group:${placement}`);
var getRootId18 = (ctx) => `toast:${ctx.id}`;
var getRootEl8 = (ctx) => ctx.getById(getRootId18(ctx));
var getTitleId4 = (ctx) => `toast:${ctx.id}:title`;
var getDescriptionId3 = (ctx) => `toast:${ctx.id}:description`;
var getCloseTriggerId3 = (ctx) => `toast${ctx.id}:close`;
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;
}
var getOffsets = (offsets) => typeof offsets === "string" ? { left: offsets, right: offsets, bottom: offsets, top: offsets } : offsets;
function getGroupPlacementStyle(service, placement) {
  const { prop, computed, context } = service;
  const { offsets, gap } = prop("store").attrs;
  const heights = context.get("heights");
  const computedOffset = getOffsets(offsets);
  const rtl = prop("dir") === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles = {
    position: "fixed",
    pointerEvents: computed("count") > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${gap}px`,
    "--first-height": `${heights[0]?.height || 0}px`,
    "--viewport-offset-left": computedOffset.left,
    "--viewport-offset-right": computedOffset.right,
    "--viewport-offset-top": computedOffset.top,
    "--viewport-offset-bottom": computedOffset.bottom,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  styles.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset2 = computedOffset.top;
    styles.top = `max(env(safe-area-inset-top, 0px), ${offset2})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset2 = computedOffset.bottom;
    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset2})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset2 = computedOffset.right;
    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset2})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset2 = computedOffset.left;
    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset2})`;
  }
  return styles;
}
function getPlacementStyle(service, visible) {
  const { prop, context, computed } = service;
  const parent = prop("parent");
  const placement = parent.computed("placement");
  const { gap } = parent.prop("store").attrs;
  const [side] = placement.split("-");
  const mounted = context.get("mounted");
  const remainingTime = context.get("remainingTime");
  const height = computed("height");
  const frontmost = computed("frontmost");
  const sibling2 = !frontmost;
  const overlap = !prop("stacked");
  const stacked = prop("stacked");
  const type = prop("type");
  const duration = type === "loading" ? Number.MAX_SAFE_INTEGER : remainingTime;
  const offset2 = computed("heightIndex") * gap + computed("heightBefore");
  const styles = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${prop("removeDelay")}ms`,
    "--duration": `${duration}ms`,
    "--initial-height": `${height}px`,
    "--offset": `${offset2}px`,
    "--index": prop("index"),
    "--z-index": computed("zIndex"),
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign = (overrides) => Object.assign(styles, overrides);
  if (side === "top") {
    assign({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (mounted) {
    assign({
      "--y": "0",
      "--opacity": "1"
    });
    if (stacked) {
      assign({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling2 && overlap) {
    assign({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling2 && stacked && !visible) {
    assign({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (frontmost && !visible) {
    assign({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles;
}
function getGhostBeforeStyle(service, visible) {
  const { computed } = service;
  const styles = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign = (overrides) => Object.assign(styles, overrides);
  if (computed("frontmost") && !visible) {
    assign({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles;
}
function getGhostAfterStyle() {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(service, normalize2) {
  const { context, prop, send, refs, computed } = service;
  return {
    getCount() {
      return context.get("toasts").length;
    },
    getToasts() {
      return context.get("toasts");
    },
    getGroupProps(options = {}) {
      const { label = "Notifications" } = options;
      const { hotkey } = prop("store").attrs;
      const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const placement = computed("placement");
      const [side, align = "center"] = placement.split("-");
      return normalize2.element({
        ...parts22.group.attrs,
        dir: prop("dir"),
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(service, placement),
        onMouseEnter() {
          if (refs.get("ignoreMouseTimer").isActive()) return;
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseMove() {
          if (refs.get("ignoreMouseTimer").isActive()) return;
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          if (refs.get("ignoreMouseTimer").isActive()) return;
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (refs.get("isFocusWithin") && !contains(event.currentTarget, event.relatedTarget)) {
            queueMicrotask(() => send({ type: "REGION.BLUR" }));
          }
        }
      });
    },
    subscribe(fn) {
      const store2 = prop("store");
      return store2.subscribe(() => fn(context.get("toasts")));
    }
  };
}
var { guards: guards3, createMachine: createMachine5 } = setup();
var { and: and7 } = guards3;
var groupMachine = createMachine5({
  props({ props: props25 }) {
    return {
      dir: "ltr",
      id: uuid(),
      ...props25,
      store: props25.store
    };
  },
  initialState({ prop }) {
    return prop("store").attrs.overlap ? "overlap" : "stack";
  },
  refs() {
    return {
      lastFocusedEl: null,
      isFocusWithin: false,
      isPointerWithin: false,
      ignoreMouseTimer: AnimationFrame.create(),
      dismissableCleanup: void 0
    };
  },
  context({ bindable: bindable2 }) {
    return {
      toasts: bindable2(() => ({
        defaultValue: [],
        sync: true,
        hash: (toasts) => toasts.map((t) => t.id).join(",")
      })),
      heights: bindable2(() => ({
        defaultValue: [],
        sync: true
      }))
    };
  },
  computed: {
    count: ({ context }) => context.get("toasts").length,
    overlap: ({ prop }) => prop("store").attrs.overlap,
    placement: ({ prop }) => prop("store").attrs.placement
  },
  effects: ["subscribeToStore", "trackDocumentVisibility", "trackHotKeyPress"],
  watch({ track: track2, context, action }) {
    track2([() => context.hash("toasts")], () => {
      queueMicrotask(() => {
        action(["collapsedIfEmpty", "setDismissableBranch"]);
      });
    });
  },
  exit: ["clearDismissableBranch", "clearLastFocusedEl", "clearMouseEventTimer"],
  on: {
    "DOC.HOTKEY": {
      actions: ["focusRegionEl"]
    },
    "REGION.BLUR": [
      {
        guard: and7("isOverlapping", "isPointerOut"),
        target: "overlap",
        actions: ["collapseToasts", "resumeToasts", "restoreFocusIfPointerOut"]
      },
      {
        guard: "isPointerOut",
        target: "stack",
        actions: ["resumeToasts", "restoreFocusIfPointerOut"]
      },
      {
        actions: ["clearFocusWithin"]
      }
    ],
    "TOAST.REMOVE": {
      actions: ["removeToast", "removeHeight", "ignoreMouseEventsTemporarily"]
    },
    "TOAST.PAUSE": {
      actions: ["pauseToasts"]
    }
  },
  states: {
    stack: {
      on: {
        "REGION.POINTER_LEAVE": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["clearPointerWithin", "resumeToasts", "collapseToasts"]
          },
          {
            actions: ["clearPointerWithin", "resumeToasts"]
          }
        ],
        "REGION.OVERLAP": {
          target: "overlap",
          actions: ["collapseToasts"]
        },
        "REGION.FOCUS": {
          actions: ["setLastFocusedEl", "pauseToasts"]
        },
        "REGION.POINTER_ENTER": {
          actions: ["setPointerWithin", "pauseToasts"]
        }
      }
    },
    overlap: {
      on: {
        "REGION.STACK": {
          target: "stack",
          actions: ["expandToasts"]
        },
        "REGION.POINTER_ENTER": {
          target: "stack",
          actions: ["setPointerWithin", "pauseToasts", "expandToasts"]
        },
        "REGION.FOCUS": {
          target: "stack",
          actions: ["setLastFocusedEl", "pauseToasts", "expandToasts"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOverlapping: ({ computed }) => computed("overlap"),
      isPointerOut: ({ refs }) => !refs.get("isPointerWithin")
    },
    effects: {
      subscribeToStore({ context, prop }) {
        return prop("store").subscribe((toast) => {
          if (toast.dismiss) {
            context.set("toasts", (prev2) => prev2.filter((t) => t.id !== toast.id));
            return;
          }
          context.set("toasts", (prev2) => {
            const index = prev2.findIndex((t) => t.id === toast.id);
            if (index !== -1) {
              return [...prev2.slice(0, index), { ...prev2[index], ...toast }, ...prev2.slice(index + 1)];
            }
            return [toast, ...prev2];
          });
        });
      },
      trackHotKeyPress({ prop, send }) {
        const handleKeyDown = (event) => {
          const { hotkey } = prop("store").attrs;
          const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
          if (!isHotkeyPressed) return;
          send({ type: "DOC.HOTKEY" });
        };
        return addDomEvent(document, "keydown", handleKeyDown, { capture: true });
      },
      trackDocumentVisibility({ prop, send, scope }) {
        const { pauseOnPageIdle } = prop("store").attrs;
        if (!pauseOnPageIdle) return;
        const doc = scope.getDoc();
        return addDomEvent(doc, "visibilitychange", () => {
          const isHidden = doc.visibilityState === "hidden";
          send({ type: isHidden ? "PAUSE_ALL" : "RESUME_ALL" });
        });
      }
    },
    actions: {
      setDismissableBranch({ refs, context, computed, scope }) {
        const toasts = context.get("toasts");
        const placement = computed("placement");
        const hasToasts = toasts.length > 0;
        if (!hasToasts) {
          refs.get("dismissableCleanup")?.();
          return;
        }
        if (hasToasts && refs.get("dismissableCleanup")) {
          return;
        }
        const groupEl = () => getRegionEl(scope, placement);
        const cleanup = trackDismissableBranch(groupEl, { defer: true });
        refs.set("dismissableCleanup", cleanup);
      },
      clearDismissableBranch({ refs }) {
        refs.get("dismissableCleanup")?.();
      },
      focusRegionEl({ scope, computed }) {
        queueMicrotask(() => {
          getRegionEl(scope, computed("placement"))?.focus();
        });
      },
      pauseToasts({ prop }) {
        prop("store").pause();
      },
      resumeToasts({ prop }) {
        prop("store").resume();
      },
      expandToasts({ prop }) {
        prop("store").expand();
      },
      collapseToasts({ prop }) {
        prop("store").collapse();
      },
      removeToast({ prop, event }) {
        prop("store").remove(event.id);
      },
      removeHeight({ event, context }) {
        if (event?.id == null) return;
        queueMicrotask(() => {
          context.set("heights", (heights) => heights.filter((height) => height.id !== event.id));
        });
      },
      collapsedIfEmpty({ send, computed }) {
        if (!computed("overlap") || computed("count") > 1) return;
        send({ type: "REGION.OVERLAP" });
      },
      setLastFocusedEl({ refs, event }) {
        if (refs.get("isFocusWithin") || !event.target) return;
        refs.set("isFocusWithin", true);
        refs.set("lastFocusedEl", event.target);
      },
      restoreFocusIfPointerOut({ refs }) {
        if (!refs.get("lastFocusedEl") || refs.get("isPointerWithin")) return;
        refs.get("lastFocusedEl")?.focus({ preventScroll: true });
        refs.set("lastFocusedEl", null);
        refs.set("isFocusWithin", false);
      },
      setPointerWithin({ refs }) {
        refs.set("isPointerWithin", true);
      },
      clearPointerWithin({ refs }) {
        refs.set("isPointerWithin", false);
        if (refs.get("lastFocusedEl") && !refs.get("isFocusWithin")) {
          refs.get("lastFocusedEl")?.focus({ preventScroll: true });
          refs.set("lastFocusedEl", null);
        }
      },
      clearFocusWithin({ refs }) {
        refs.set("isFocusWithin", false);
      },
      clearLastFocusedEl({ refs }) {
        if (!refs.get("lastFocusedEl")) return;
        refs.get("lastFocusedEl")?.focus({ preventScroll: true });
        refs.set("lastFocusedEl", null);
        refs.set("isFocusWithin", false);
      },
      ignoreMouseEventsTemporarily({ refs }) {
        refs.get("ignoreMouseTimer").request();
      },
      clearMouseEventTimer({ refs }) {
        refs.get("ignoreMouseTimer").cancel();
      }
    }
  }
});
function connect22(service, normalize2) {
  const { state: state3, send, prop, scope, context, computed } = service;
  const visible = state3.hasTag("visible");
  const paused = state3.hasTag("paused");
  const mounted = context.get("mounted");
  const frontmost = computed("frontmost");
  const placement = prop("parent").computed("placement");
  const type = prop("type");
  const stacked = prop("stacked");
  const title = prop("title");
  const description = prop("description");
  const action = prop("action");
  const [side, align = "center"] = placement.split("-");
  return {
    type,
    title,
    description,
    placement,
    visible,
    paused,
    closable: !!prop("closable"),
    pause() {
      send({ type: "PAUSE" });
    },
    resume() {
      send({ type: "RESUME" });
    },
    dismiss() {
      send({ type: "DISMISS", src: "programmatic" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts22.root.attrs,
        dir: prop("dir"),
        id: getRootId18(scope),
        "data-state": visible ? "open" : "closed",
        "data-type": type,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr(mounted),
        "data-paused": dataAttr(paused),
        "data-first": dataAttr(frontmost),
        "data-sibling": dataAttr(!frontmost),
        "data-stack": dataAttr(stacked),
        "data-overlap": dataAttr(!stacked),
        role: "status",
        "aria-atomic": "true",
        "aria-describedby": description ? getDescriptionId3(scope) : void 0,
        "aria-labelledby": title ? getTitleId4(scope) : void 0,
        tabIndex: 0,
        style: getPlacementStyle(service, visible),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key == "Escape") {
            send({ type: "DISMISS", src: "keyboard" });
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize2.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(service, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize2.element({
        "data-ghost": "after",
        style: getGhostAfterStyle()
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts22.title.attrs,
        id: getTitleId4(scope)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts22.description.attrs,
        id: getDescriptionId3(scope)
      });
    },
    getActionTriggerProps() {
      return normalize2.button({
        ...parts22.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          action?.onClick?.();
          send({ type: "DISMISS", src: "user" });
        }
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        id: getCloseTriggerId3(scope),
        ...parts22.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "DISMISS", src: "user" });
        }
      });
    }
  };
}
var { not: not8 } = createGuards();
var machine22 = createMachine({
  props({ props: props25 }) {
    ensureProps(props25, ["id", "type", "parent", "removeDelay"], "toast");
    return {
      closable: true,
      ...props25,
      duration: getToastDuration(props25.duration, props25.type)
    };
  },
  initialState({ prop }) {
    const persist = prop("type") === "loading" || prop("duration") === Infinity;
    return persist ? "visible:persist" : "visible";
  },
  context({ prop, bindable: bindable2 }) {
    return {
      remainingTime: bindable2(() => ({
        defaultValue: getToastDuration(prop("duration"), prop("type"))
      })),
      createdAt: bindable2(() => ({
        defaultValue: Date.now()
      })),
      mounted: bindable2(() => ({
        defaultValue: false
      })),
      initialHeight: bindable2(() => ({
        defaultValue: 0
      }))
    };
  },
  refs() {
    return {
      closeTimerStartTime: Date.now(),
      lastCloseStartTimerStartTime: 0
    };
  },
  computed: {
    zIndex: ({ prop }) => {
      const toasts = prop("parent").context.get("toasts");
      const index = toasts.findIndex((toast) => toast.id === prop("id"));
      return toasts.length - index;
    },
    height: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      const height = heights.find((height2) => height2.id === prop("id"));
      return height?.height ?? 0;
    },
    heightIndex: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      return heights.findIndex((height) => height.id === prop("id"));
    },
    frontmost: ({ prop }) => prop("index") === 0,
    heightBefore: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      const heightIndex = heights.findIndex((height) => height.id === prop("id"));
      return heights.reduce((prev2, curr, reducerIndex) => {
        if (reducerIndex >= heightIndex) return prev2;
        return prev2 + curr.height;
      }, 0);
    },
    shouldPersist: ({ prop }) => prop("type") === "loading" || prop("duration") === Infinity
  },
  watch({ track: track2, prop, send }) {
    track2([() => prop("message")], () => {
      const message = prop("message");
      if (message) send({ type: message, src: "programmatic" });
    });
    track2([() => prop("type"), () => prop("duration")], () => {
      send({ type: "UPDATE" });
    });
  },
  on: {
    UPDATE: [
      {
        guard: "shouldPersist",
        target: "visible:persist",
        actions: ["resetCloseTimer"]
      },
      {
        target: "visible:updating",
        actions: ["resetCloseTimer"]
      }
    ],
    MEASURE: {
      actions: ["measureHeight"]
    }
  },
  entry: ["setMounted", "measureHeight", "invokeOnVisible"],
  effects: ["trackHeight"],
  states: {
    "visible:updating": {
      tags: ["visible", "updating"],
      effects: ["waitForNextTick"],
      on: {
        SHOW: {
          target: "visible"
        }
      }
    },
    "visible:persist": {
      tags: ["visible", "paused"],
      on: {
        RESUME: {
          guard: not8("isLoadingType"),
          target: "visible",
          actions: ["setCloseTimer"]
        },
        DISMISS: {
          target: "dismissing"
        }
      }
    },
    visible: {
      tags: ["visible"],
      effects: ["waitForDuration"],
      on: {
        DISMISS: {
          target: "dismissing"
        },
        PAUSE: {
          target: "visible:persist",
          actions: ["syncRemainingTime"]
        }
      }
    },
    dismissing: {
      entry: ["invokeOnDismiss"],
      effects: ["waitForRemoveDelay"],
      on: {
        REMOVE: {
          target: "unmounted",
          actions: ["notifyParentToRemove"]
        }
      }
    },
    unmounted: {
      entry: ["invokeOnUnmount"]
    }
  },
  implementations: {
    effects: {
      waitForRemoveDelay({ prop, send }) {
        return setRafTimeout(() => {
          send({ type: "REMOVE", src: "timer" });
        }, prop("removeDelay"));
      },
      waitForDuration({ send, context, computed }) {
        if (computed("shouldPersist")) return;
        return setRafTimeout(() => {
          send({ type: "DISMISS", src: "timer" });
        }, context.get("remainingTime"));
      },
      waitForNextTick({ send }) {
        return setRafTimeout(() => {
          send({ type: "SHOW", src: "timer" });
        }, 0);
      },
      trackHeight({ scope, prop }) {
        let cleanup;
        raf(() => {
          const rootEl = getRootEl8(scope);
          if (!rootEl) return;
          const syncHeight = () => {
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const height = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            const item = { id: prop("id"), height };
            setHeight(prop("parent"), item);
          };
          const win = scope.getWin();
          const observer = new win.MutationObserver(syncHeight);
          observer.observe(rootEl, {
            childList: true,
            subtree: true,
            characterData: true
          });
          cleanup = () => observer.disconnect();
        });
        return () => cleanup?.();
      }
    },
    guards: {
      isLoadingType: ({ prop }) => prop("type") === "loading",
      shouldPersist: ({ computed }) => computed("shouldPersist")
    },
    actions: {
      setMounted({ context }) {
        raf(() => {
          context.set("mounted", true);
        });
      },
      measureHeight({ scope, prop, context }) {
        queueMicrotask(() => {
          const rootEl = getRootEl8(scope);
          if (!rootEl) return;
          const originalHeight = rootEl.style.height;
          rootEl.style.height = "auto";
          const height = rootEl.getBoundingClientRect().height;
          rootEl.style.height = originalHeight;
          context.set("initialHeight", height);
          const item = { id: prop("id"), height };
          setHeight(prop("parent"), item);
        });
      },
      setCloseTimer({ refs }) {
        refs.set("closeTimerStartTime", Date.now());
      },
      resetCloseTimer({ context, refs, prop }) {
        refs.set("closeTimerStartTime", Date.now());
        context.set("remainingTime", getToastDuration(prop("duration"), prop("type")));
      },
      syncRemainingTime({ context, refs }) {
        context.set("remainingTime", (prev2) => {
          const closeTimerStartTime = refs.get("closeTimerStartTime");
          const elapsedTime = Date.now() - closeTimerStartTime;
          refs.set("lastCloseStartTimerStartTime", Date.now());
          return prev2 - elapsedTime;
        });
      },
      notifyParentToRemove({ prop }) {
        const parent = prop("parent");
        parent.send({ type: "TOAST.REMOVE", id: prop("id") });
      },
      invokeOnDismiss({ prop, event }) {
        prop("onStatusChange")?.({ status: "dismissing", src: event.src });
      },
      invokeOnUnmount({ prop }) {
        prop("onStatusChange")?.({ status: "unmounted" });
      },
      invokeOnVisible({ prop }) {
        prop("onStatusChange")?.({ status: "visible" });
      }
    }
  }
});
function setHeight(parent, item) {
  const { id, height } = item;
  parent.context.set("heights", (prev2) => {
    const alreadyExists = prev2.find((i) => i.id === id);
    if (!alreadyExists) {
      return [{ id, height }, ...prev2];
    } else {
      return prev2.map((i) => i.id === id ? { ...i, height } : i);
    }
  });
}
var withDefaults = (options, defaults) => {
  return { ...defaults, ...compact(options) };
};
function createToastStore(props25 = {}) {
  const attrs = withDefaults(props25, {
    placement: "bottom",
    overlap: false,
    max: 24,
    gap: 16,
    offsets: "1rem",
    hotkey: ["altKey", "KeyT"],
    removeDelay: 200,
    pauseOnPageIdle: true
  });
  let subscribers = [];
  let toasts = [];
  let dismissedToasts = /* @__PURE__ */ new Set();
  let toastQueue = [];
  const subscribe2 = (subscriber) => {
    subscribers.push(subscriber);
    return () => {
      const index = subscribers.indexOf(subscriber);
      subscribers.splice(index, 1);
    };
  };
  const publish = (data) => {
    subscribers.forEach((subscriber) => subscriber(data));
    return data;
  };
  const addToast = (data) => {
    if (toasts.length >= attrs.max) {
      toastQueue.push(data);
      return;
    }
    publish(data);
    toasts.unshift(data);
  };
  const processQueue = () => {
    while (toastQueue.length > 0 && toasts.length < attrs.max) {
      const nextToast = toastQueue.shift();
      if (nextToast) {
        publish(nextToast);
        toasts.unshift(nextToast);
      }
    }
  };
  const create = (data) => {
    const id = data.id ?? `toast:${uuid()}`;
    const exists = toasts.find((toast) => toast.id === id);
    if (dismissedToasts.has(id)) dismissedToasts.delete(id);
    if (exists) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) {
          return publish({ ...toast, ...data, id });
        }
        return toast;
      });
    } else {
      addToast({
        id,
        duration: attrs.duration,
        removeDelay: attrs.removeDelay,
        type: "info",
        ...data,
        stacked: !attrs.overlap,
        gap: attrs.gap
      });
    }
    return id;
  };
  const remove3 = (id) => {
    dismissedToasts.add(id);
    if (!id) {
      toasts.forEach((toast) => {
        subscribers.forEach((subscriber) => subscriber({ id: toast.id, dismiss: true }));
      });
      toasts = [];
      toastQueue = [];
    } else {
      subscribers.forEach((subscriber) => subscriber({ id, dismiss: true }));
      toasts = toasts.filter((toast) => toast.id !== id);
      processQueue();
    }
    return id;
  };
  const error = (data) => {
    return create({ ...data, type: "error" });
  };
  const success = (data) => {
    return create({ ...data, type: "success" });
  };
  const info = (data) => {
    return create({ ...data, type: "info" });
  };
  const warning = (data) => {
    return create({ ...data, type: "warning" });
  };
  const loading = (data) => {
    return create({ ...data, type: "loading" });
  };
  const getVisibleToasts = () => {
    return toasts.filter((toast) => !dismissedToasts.has(toast.id));
  };
  const getCount = () => {
    return toasts.length;
  };
  const promise = (promise2, options, shared = {}) => {
    if (!options || !options.loading) {
      warn("[zag-js > toast] toaster.promise() requires at least a 'loading' option to be specified");
      return;
    }
    const id = create({
      ...shared,
      ...options.loading,
      promise: promise2,
      type: "loading"
    });
    let removable = true;
    let result;
    const prom = runIfFn(promise2).then(async (response) => {
      result = ["resolve", response];
      if (isHttpResponse(response) && !response.ok) {
        removable = false;
        const errorOptions = runIfFn(options.error, `HTTP Error! status: ${response.status}`);
        create({ ...shared, ...errorOptions, id, type: "error" });
      } else if (options.success !== void 0) {
        removable = false;
        const successOptions = runIfFn(options.success, response);
        create({ ...shared, ...successOptions, id, type: "success" });
      }
    }).catch(async (error2) => {
      result = ["reject", error2];
      if (options.error !== void 0) {
        removable = false;
        const errorOptions = runIfFn(options.error, error2);
        create({ ...shared, ...errorOptions, id, type: "error" });
      }
    }).finally(() => {
      if (removable) {
        remove3(id);
      }
      options.finally?.();
    });
    const unwrap = () => new Promise(
      (resolve, reject) => prom.then(() => result[0] === "reject" ? reject(result[1]) : resolve(result[1])).catch(reject)
    );
    return { id, unwrap };
  };
  const update = (id, data) => {
    return create({ id, ...data });
  };
  const pause = (id) => {
    if (id != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) return publish({ ...toast, message: "PAUSE" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish({ ...toast, message: "PAUSE" }));
    }
  };
  const resume = (id) => {
    if (id != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) return publish({ ...toast, message: "RESUME" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish({ ...toast, message: "RESUME" }));
    }
  };
  const dismiss = (id) => {
    if (id != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) return publish({ ...toast, message: "DISMISS" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish({ ...toast, message: "DISMISS" }));
    }
  };
  const isVisible = (id) => {
    return !dismissedToasts.has(id) && !!toasts.find((toast) => toast.id === id);
  };
  const isDismissed = (id) => {
    return dismissedToasts.has(id);
  };
  const expand = () => {
    toasts = toasts.map((toast) => publish({ ...toast, stacked: true }));
  };
  const collapse = () => {
    toasts = toasts.map((toast) => publish({ ...toast, stacked: false }));
  };
  return {
    attrs,
    subscribe: subscribe2,
    create,
    update,
    remove: remove3,
    dismiss,
    error,
    success,
    info,
    warning,
    loading,
    getVisibleToasts,
    getCount,
    promise,
    pause,
    resume,
    isVisible,
    isDismissed,
    expand,
    collapse
  };
}
var isHttpResponse = (data) => {
  return data && typeof data === "object" && "ok" in data && typeof data.ok === "boolean" && "status" in data && typeof data.status === "number";
};
var group = {
  connect: groupConnect,
  machine: groupMachine
};

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/group.svelte
Group2[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/group.svelte";
var root_2212 = add_locations(from_html(`<div></div>`), Group2[FILENAME], [[37, 1]]);
function Group2($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Group2);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), toaster = tag(user_derived(() => $$props.toaster), "toaster"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "toaster"])), "rest");
  const service = useMachine(group.machine, () => ({ id, store: get(toaster) }));
  const api = tag(user_derived(() => group.connect(service, normalizeProps)), "api");
  const attributes = tag(user_derived(() => mergeProps2(get(api).getGroupProps(), get(rest))), "attributes");
  GroupContext.provide(() => service);
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Group2, 35, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2212();
      attribute_effect(div, () => ({ ...get(attributes) }));
      validate_each_keys(() => get(api).getToasts(), (toast) => toast.id);
      add_svelte_meta(
        () => each(div, 21, () => get(api).getToasts(), (toast) => toast.id, ($$anchor3, toast) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop, () => get(toast)), "render", Group2, 39, 3);
          append($$anchor3, fragment_2);
        }),
        "each",
        Group2,
        38,
        2
      );
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Group2,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Group2 = hmr(Group2);
  import.meta.hot.accept((module) => {
    Group2[HMR].update(module.default);
  });
}
var group_default2 = Group2;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/message.svelte
Message[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/message.svelte";
var root_2213 = add_locations(from_html(`<div><!></div>`), Message[FILENAME], [[29, 1]]);
function Message($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Message);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2({ "data-scope": "toast", "data-part": "message" }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Message, 27, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2213();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Message, 30, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Message,
      26,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Message = hmr(Message);
  import.meta.hot.accept((module) => {
    Message[HMR].update(module.default);
  });
}
var message_default = Message;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/root-context.svelte
Root_context22[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/root-context.svelte";
function Root_context22($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context22);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const toast = RootContext23.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => toast), "render", Root_context22, 21, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context22 = hmr(Root_context22);
  import.meta.hot.accept((module) => {
    Root_context22[HMR].update(module.default);
  });
}
var root_context_default22 = Root_context22;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/root.svelte
Root25[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/root.svelte";
var root_2214 = add_locations(from_html(`<div><div></div> <!> <div></div></div>`), Root25[FILENAME], [[37, 1, [[38, 2], [40, 2]]]]);
function Root25($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root25);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const group2 = GroupContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), toastProps = tag(user_derived(() => $$props.toast), "toastProps"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "toast"])), "rest");
  const service = useMachine(machine22, () => ({ ...get(toastProps), parent: group2() }));
  const toast = tag(user_derived(() => connect22(service, normalizeProps)), "toast");
  const attributes = tag(user_derived(() => mergeProps2(get(toast).getRootProps(), get(rest))), "attributes");
  RootContext23.provide(() => get(toast));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root25, 35, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2214();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var div_1 = child(div);
      attribute_effect(div_1, ($0) => ({ ...$0 }), [() => get(toast).getGhostBeforeProps()]);
      var node_2 = sibling(div_1, 2);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root25, 39, 2);
      var div_2 = sibling(node_2, 2);
      attribute_effect(div_2, ($0) => ({ ...$0 }), [() => get(toast).getGhostAfterProps()]);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root25,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root25 = hmr(Root25);
  import.meta.hot.accept((module) => {
    Root25[HMR].update(module.default);
  });
}
var root_default25 = Root25;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/title.svelte
Title4[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/anatomy/title.svelte";
var root_2215 = add_locations(from_html(`<div><!></div>`), Title4[FILENAME], [[24, 1]]);
function Title4($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Title4);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const toast = RootContext23.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(toast().getTitleProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Title4, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2215();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Title4, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Title4,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Title4 = hmr(Title4);
  import.meta.hot.accept((module) => {
    Title4[HMR].update(module.default);
  });
}
var title_default4 = Title4;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toast/modules/anatomy.js
var Toast = Object.assign(root_default25, {
  Context: root_context_default22,
  Group: group_default2,
  Message: message_default,
  Title: title_default4,
  Description: description_default3,
  ActionTrigger: action_trigger_default,
  CloseTrigger: close_trigger_default4
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/modules/root-context.js
var RootContext24 = createContext();

// node_modules/@zag-js/toggle-group/dist/index.mjs
var anatomy23 = createAnatomy("toggle-group").parts("root", "item");
var parts23 = anatomy23.build();
var getRootId19 = (ctx) => ctx.ids?.root ?? `toggle-group:${ctx.id}`;
var getItemId11 = (ctx, value) => ctx.ids?.item?.(value) ?? `toggle-group:${ctx.id}:${value}`;
var getRootEl9 = (ctx) => ctx.getById(getRootId19(ctx));
var getElements3 = (ctx) => {
  const ownerId = CSS.escape(getRootId19(ctx));
  const selector = `[data-ownedby='${ownerId}']:not([data-disabled])`;
  return queryAll(getRootEl9(ctx), selector);
};
var getFirstEl3 = (ctx) => first(getElements3(ctx));
var getLastEl3 = (ctx) => last(getElements3(ctx));
var getNextEl3 = (ctx, id, loopFocus) => nextById(getElements3(ctx), id, loopFocus);
var getPrevEl3 = (ctx, id, loopFocus) => prevById(getElements3(ctx), id, loopFocus);
function connect23(service, normalize2) {
  const { context, send, prop, scope } = service;
  const value = context.get("value");
  const disabled = prop("disabled");
  const isSingle = !prop("multiple");
  const rovingFocus = prop("rovingFocus");
  const isHorizontal = prop("orientation") === "horizontal";
  function getItemState(props25) {
    const id = getItemId11(scope, props25.value);
    return {
      id,
      disabled: Boolean(props25.disabled || disabled),
      pressed: !!value.includes(props25.value),
      focused: context.get("focusedId") === id
    };
  }
  return {
    value,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    getRootProps() {
      return normalize2.element({
        ...parts23.root.attrs,
        id: getRootId19(scope),
        dir: prop("dir"),
        role: isSingle ? "radiogroup" : "group",
        tabIndex: context.get("isTabbingBackward") ? -1 : 0,
        "data-disabled": dataAttr(disabled),
        "data-orientation": prop("orientation"),
        "data-focus": dataAttr(context.get("focusedId") != null),
        style: { outline: "none" },
        onMouseDown() {
          if (disabled) return;
          send({ type: "ROOT.MOUSE_DOWN" });
        },
        onFocus(event) {
          if (disabled) return;
          if (event.currentTarget !== getEventTarget(event)) return;
          if (context.get("isClickFocus")) return;
          if (context.get("isTabbingBackward")) return;
          send({ type: "ROOT.FOCUS" });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if (contains(event.currentTarget, target)) return;
          if (disabled) return;
          send({ type: "ROOT.BLUR" });
        }
      });
    },
    getItemState,
    getItemProps(props25) {
      const itemState = getItemState(props25);
      const rovingTabIndex = itemState.focused ? 0 : -1;
      return normalize2.button({
        ...parts23.item.attrs,
        id: itemState.id,
        type: "button",
        "data-ownedby": getRootId19(scope),
        "data-focus": dataAttr(itemState.focused),
        disabled: itemState.disabled,
        tabIndex: rovingFocus ? rovingTabIndex : void 0,
        // radio
        role: isSingle ? "radio" : void 0,
        "aria-checked": isSingle ? itemState.pressed : void 0,
        "aria-pressed": isSingle ? void 0 : itemState.pressed,
        //
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": prop("orientation"),
        dir: prop("dir"),
        "data-state": itemState.pressed ? "on" : "off",
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TOGGLE.FOCUS", id: itemState.id });
        },
        onClick(event) {
          if (itemState.disabled) return;
          send({ type: "TOGGLE.CLICK", id: itemState.id, value: props25.value });
          if (isSafari()) {
            event.currentTarget.focus({ preventScroll: true });
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!contains(event.currentTarget, getEventTarget(event))) return;
          if (itemState.disabled) return;
          const keyMap2 = {
            Tab(event2) {
              const isShiftTab = event2.shiftKey;
              send({ type: "TOGGLE.SHIFT_TAB", isShiftTab });
            },
            ArrowLeft() {
              if (!rovingFocus || !isHorizontal) return;
              send({ type: "TOGGLE.FOCUS_PREV" });
            },
            ArrowRight() {
              if (!rovingFocus || !isHorizontal) return;
              send({ type: "TOGGLE.FOCUS_NEXT" });
            },
            ArrowUp() {
              if (!rovingFocus || isHorizontal) return;
              send({ type: "TOGGLE.FOCUS_PREV" });
            },
            ArrowDown() {
              if (!rovingFocus || isHorizontal) return;
              send({ type: "TOGGLE.FOCUS_NEXT" });
            },
            Home() {
              if (!rovingFocus) return;
              send({ type: "TOGGLE.FOCUS_FIRST" });
            },
            End() {
              if (!rovingFocus) return;
              send({ type: "TOGGLE.FOCUS_LAST" });
            }
          };
          const exec = keyMap2[getEventKey(event)];
          if (exec) {
            exec(event);
            if (event.key !== "Tab") event.preventDefault();
          }
        }
      });
    }
  };
}
var { not: not9, and: and8 } = createGuards();
var machine23 = createMachine({
  props({ props: props25 }) {
    return {
      defaultValue: [],
      orientation: "horizontal",
      rovingFocus: true,
      loopFocus: true,
      deselectable: true,
      ...props25
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable: bindable2 }) {
    return {
      value: bindable2(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      focusedId: bindable2(() => ({
        defaultValue: null
      })),
      isTabbingBackward: bindable2(() => ({
        defaultValue: false
      })),
      isClickFocus: bindable2(() => ({
        defaultValue: false
      })),
      isWithinToolbar: bindable2(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    currentLoopFocus: ({ context, prop }) => prop("loopFocus") && !context.get("isWithinToolbar")
  },
  entry: ["checkIfWithinToolbar"],
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    },
    "TOGGLE.CLICK": {
      actions: ["setValue"]
    },
    "ROOT.MOUSE_DOWN": {
      actions: ["setClickFocus"]
    }
  },
  states: {
    idle: {
      on: {
        "ROOT.FOCUS": {
          target: "focused",
          guard: not9(and8("isClickFocus", "isTabbingBackward")),
          actions: ["focusFirstToggle", "clearClickFocus"]
        },
        "TOGGLE.FOCUS": {
          target: "focused",
          actions: ["setFocusedId"]
        }
      }
    },
    focused: {
      on: {
        "ROOT.BLUR": {
          target: "idle",
          actions: ["clearIsTabbingBackward", "clearFocusedId", "clearClickFocus"]
        },
        "TOGGLE.FOCUS": {
          actions: ["setFocusedId"]
        },
        "TOGGLE.FOCUS_NEXT": {
          actions: ["focusNextToggle"]
        },
        "TOGGLE.FOCUS_PREV": {
          actions: ["focusPrevToggle"]
        },
        "TOGGLE.FOCUS_FIRST": {
          actions: ["focusFirstToggle"]
        },
        "TOGGLE.FOCUS_LAST": {
          actions: ["focusLastToggle"]
        },
        "TOGGLE.SHIFT_TAB": [
          {
            guard: not9("isFirstToggleFocused"),
            target: "idle",
            actions: ["setIsTabbingBackward"]
          },
          {
            actions: ["setIsTabbingBackward"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isClickFocus: ({ context }) => context.get("isClickFocus"),
      isTabbingBackward: ({ context }) => context.get("isTabbingBackward"),
      isFirstToggleFocused: ({ context, scope }) => context.get("focusedId") === getFirstEl3(scope)?.id
    },
    actions: {
      setIsTabbingBackward({ context }) {
        context.set("isTabbingBackward", true);
      },
      clearIsTabbingBackward({ context }) {
        context.set("isTabbingBackward", false);
      },
      setClickFocus({ context }) {
        context.set("isClickFocus", true);
      },
      clearClickFocus({ context }) {
        context.set("isClickFocus", false);
      },
      checkIfWithinToolbar({ context, scope }) {
        const closestToolbar = getRootEl9(scope)?.closest("[role=toolbar]");
        context.set("isWithinToolbar", !!closestToolbar);
      },
      setFocusedId({ context, event }) {
        context.set("focusedId", event.id);
      },
      clearFocusedId({ context }) {
        context.set("focusedId", null);
      },
      setValue({ context, event, prop }) {
        ensureProps(event, ["value"]);
        let next3 = context.get("value");
        if (isArray(event.value)) {
          next3 = event.value;
        } else if (prop("multiple")) {
          next3 = addOrRemove(next3, event.value);
        } else {
          const isSelected = isEqual(next3, [event.value]);
          next3 = isSelected && prop("deselectable") ? [] : [event.value];
        }
        context.set("value", next3);
      },
      focusNextToggle({ context, scope, prop }) {
        raf(() => {
          const focusedId = context.get("focusedId");
          if (!focusedId) return;
          getNextEl3(scope, focusedId, prop("loopFocus"))?.focus({ preventScroll: true });
        });
      },
      focusPrevToggle({ context, scope, prop }) {
        raf(() => {
          const focusedId = context.get("focusedId");
          if (!focusedId) return;
          getPrevEl3(scope, focusedId, prop("loopFocus"))?.focus({ preventScroll: true });
        });
      },
      focusFirstToggle({ scope }) {
        raf(() => {
          getFirstEl3(scope)?.focus({ preventScroll: true });
        });
      },
      focusLastToggle({ scope }) {
        raf(() => {
          getLastEl3(scope)?.focus({ preventScroll: true });
        });
      }
    }
  }
});
var props22 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "multiple",
  "onValueChange",
  "orientation",
  "rovingFocus",
  "value",
  "defaultValue",
  "deselectable"
]);
var splitProps23 = createSplitProps(props22);
var itemProps11 = createProps()(["value", "disabled"]);
var splitItemProps11 = createSplitProps(itemProps11);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/anatomy/item.svelte
Item12[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/anatomy/item.svelte";
var root_2216 = add_locations(from_html(`<button><!></button>`), Item12[FILENAME], [[27, 1]]);
function Item12($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item12);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const toggleGroup = RootContext24.consume();
  const $$d = user_derived(() => splitItemProps11(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), itemProps13 = tag(user_derived(() => get($$array)[0]), "itemProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(toggleGroup().getItemProps(get(itemProps13)), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item12, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2216();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item12, 28, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item12,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item12 = hmr(Item12);
  import.meta.hot.accept((module) => {
    Item12[HMR].update(module.default);
  });
}
var item_default12 = Item12;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/anatomy/root-context.svelte
Root_context23[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/anatomy/root-context.svelte";
function Root_context23($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context23);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const toggleGroup = RootContext24.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => toggleGroup), "render", Root_context23, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context23 = hmr(Root_context23);
  import.meta.hot.accept((module) => {
    Root_context23[HMR].update(module.default);
  });
}
var root_context_default23 = Root_context23;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/anatomy/root-provider.svelte
Root_provider22[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/anatomy/root-provider.svelte";
var root_2217 = add_locations(from_html(`<div><!></div>`), Root_provider22[FILENAME], [[27, 1]]);
function Root_provider22($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider22);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), toggleGroup = tag(user_derived(() => $$props.value), "toggleGroup"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(toggleGroup)().getRootProps(), get(rest))), "attributes");
  RootContext24.provide(() => get(toggleGroup)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider22, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2217();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider22, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider22,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider22 = hmr(Root_provider22);
  import.meta.hot.accept((module) => {
    Root_provider22[HMR].update(module.default);
  });
}
var root_provider_default22 = Root_provider22;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/modules/provider.svelte.js
function useToggleGroup(props25) {
  const service = useMachine(machine23, props25);
  const toggleGroup = tag(user_derived(() => connect23(service, normalizeProps)), "toggleGroup");
  return () => get(toggleGroup);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/anatomy/root.svelte
Root26[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/anatomy/root.svelte";
var root_2218 = add_locations(from_html(`<div><!></div>`), Root26[FILENAME], [[34, 1]]);
function Root26($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root26);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps23(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), toggleGroupProps = tag(user_derived(() => get($$array)[0]), "toggleGroupProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const toggleGroup = useToggleGroup(() => ({ ...get(toggleGroupProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(toggleGroup().getRootProps(), get(rest))), "attributes");
  RootContext24.provide(() => toggleGroup());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root26, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2218();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root26, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root26,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root26 = hmr(Root26);
  import.meta.hot.accept((module) => {
    Root26[HMR].update(module.default);
  });
}
var root_default26 = Root26;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/toggle-group/modules/anatomy.js
var ToggleGroup = Object.assign(root_default26, {
  Provider: root_provider_default22,
  Context: root_context_default23,
  Item: item_default12
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/modules/root-context.js
var RootContext25 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/arrow-tip.svelte
Arrow_tip3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/arrow-tip.svelte";
var root_2219 = add_locations(from_html(`<div><!></div>`), Arrow_tip3[FILENAME], [[24, 1]]);
function Arrow_tip3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow_tip3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tooltip = RootContext25.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tooltip().getArrowTipProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Arrow_tip3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2219();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Arrow_tip3, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Arrow_tip3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Arrow_tip3 = hmr(Arrow_tip3);
  import.meta.hot.accept((module) => {
    Arrow_tip3[HMR].update(module.default);
  });
}
var arrow_tip_default3 = Arrow_tip3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/arrow.svelte
Arrow3[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/arrow.svelte";
var root_2220 = add_locations(from_html(`<div><!></div>`), Arrow3[FILENAME], [[24, 1]]);
function Arrow3($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow3);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tooltip = RootContext25.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tooltip().getArrowProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Arrow3, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2220();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Arrow3, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Arrow3,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Arrow3 = hmr(Arrow3);
  import.meta.hot.accept((module) => {
    Arrow3[HMR].update(module.default);
  });
}
var arrow_default3 = Arrow3;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/content.svelte
Content12[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/content.svelte";
var root_2221 = add_locations(from_html(`<div><!></div>`), Content12[FILENAME], [[24, 1]]);
function Content12($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content12);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tooltip = RootContext25.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tooltip().getContentProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Content12, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2221();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Content12, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Content12,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Content12 = hmr(Content12);
  import.meta.hot.accept((module) => {
    Content12[HMR].update(module.default);
  });
}
var content_default12 = Content12;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/positioner.svelte
Positioner7[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/positioner.svelte";
var root_2222 = add_locations(from_html(`<div><!></div>`), Positioner7[FILENAME], [[33, 1]]);
function Positioner7($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Positioner7);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tooltip = RootContext25.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tooltip().getPositionerProps(), { [createAttachmentKey()]: fromAction(portal, () => void 0) }, get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Positioner7, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2222();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Positioner7, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Positioner7,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Positioner7 = hmr(Positioner7);
  import.meta.hot.accept((module) => {
    Positioner7[HMR].update(module.default);
  });
}
var positioner_default7 = Positioner7;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/root-context.svelte
Root_context24[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/root-context.svelte";
function Root_context24($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context24);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tooltip = RootContext25.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => tooltip), "render", Root_context24, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context24 = hmr(Root_context24);
  import.meta.hot.accept((module) => {
    Root_context24[HMR].update(module.default);
  });
}
var root_context_default24 = Root_context24;

// node_modules/@zag-js/tooltip/dist/index.mjs
var anatomy24 = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts24 = anatomy24.build();
var getTriggerId11 = (scope) => scope.ids?.trigger ?? `tooltip:${scope.id}:trigger`;
var getContentId11 = (scope) => scope.ids?.content ?? `tooltip:${scope.id}:content`;
var getArrowId3 = (scope) => scope.ids?.arrow ?? `tooltip:${scope.id}:arrow`;
var getPositionerId7 = (scope) => scope.ids?.positioner ?? `tooltip:${scope.id}:popper`;
var getTriggerEl8 = (scope) => scope.getById(getTriggerId11(scope));
var getPositionerEl7 = (scope) => scope.getById(getPositionerId7(scope));
var store = createStore({ id: null });
function connect24(service, normalize2) {
  const { state: state3, context, send, scope, prop, event: _event } = service;
  const id = prop("id");
  const hasAriaLabel = !!prop("aria-label");
  const open = state3.matches("open", "closing");
  const triggerId = getTriggerId11(scope);
  const contentId = getContentId11(scope);
  const disabled = prop("disabled");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: context.get("currentPlacement")
  });
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state3.matches("open", "closing");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "open" : "close" });
    },
    reposition(options = {}) {
      send({ type: "positioning.set", options });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts24.trigger.attrs,
        id: triggerId,
        dir: prop("dir"),
        "data-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!prop("closeOnClick")) return;
          send({ type: "close", src: "trigger.click" });
        },
        onFocus(event) {
          queueMicrotask(() => {
            if (event.defaultPrevented) return;
            if (disabled) return;
            if (_event.src === "trigger.pointerdown") return;
            if (!isFocusVisible()) return;
            send({ type: "open", src: "trigger.focus" });
          });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id === store.get("id")) {
            send({ type: "close", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!isLeftClick(event)) return;
          if (!prop("closeOnPointerDown")) return;
          if (id === store.get("id")) {
            send({ type: "close", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send({ type: "pointer.move" });
        },
        onPointerOver(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send({ type: "pointer.move" });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "pointer.leave" });
        },
        onPointerCancel() {
          if (disabled) return;
          send({ type: "pointer.leave" });
        }
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: getArrowId3(scope),
        ...parts24.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts24.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: getPositionerId7(scope),
        ...parts24.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts24.content.attrs,
        dir: prop("dir"),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": context.get("currentPlacement"),
        onPointerEnter() {
          send({ type: "content.pointer.move" });
        },
        onPointerLeave() {
          send({ type: "content.pointer.leave" });
        },
        style: {
          pointerEvents: prop("interactive") ? "auto" : "none"
        }
      });
    }
  };
}
var { and: and9, not: not10 } = createGuards();
var machine24 = createMachine({
  initialState: ({ prop }) => {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  props({ props: props25 }) {
    const closeOnClick = props25.closeOnClick ?? true;
    const closeOnPointerDown = props25.closeOnPointerDown ?? closeOnClick;
    return {
      id: "x",
      openDelay: 400,
      closeDelay: 150,
      closeOnEscape: true,
      interactive: false,
      closeOnScroll: true,
      disabled: false,
      ...props25,
      closeOnPointerDown,
      closeOnClick,
      positioning: {
        placement: "bottom",
        ...props25.positioning
      }
    };
  },
  effects: ["trackFocusVisible", "trackStore"],
  context: ({ bindable: bindable2 }) => ({
    currentPlacement: bindable2(() => ({ defaultValue: void 0 })),
    hasPointerMoveOpened: bindable2(() => ({ defaultValue: false }))
  }),
  watch({ track: track2, action, prop }) {
    track2([() => prop("disabled")], () => {
      action(["closeIfDisabled"]);
    });
    track2([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    closed: {
      entry: ["clearGlobalId"],
      on: {
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "pointer.leave": {
          actions: ["clearPointerMoveOpened"]
        },
        "pointer.move": [
          {
            guard: and9("noVisibleTooltip", not10("hasPointerMoveOpened")),
            target: "opening"
          },
          {
            guard: not10("hasPointerMoveOpened"),
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ]
      }
    },
    opening: {
      effects: ["trackScroll", "trackPointerlockChange", "waitForOpenDelay"],
      on: {
        "after.openDelay": [
          {
            guard: "isOpenControlled",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ],
        "controlled.open": {
          target: "open"
        },
        "controlled.close": {
          target: "closed"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "pointer.leave": [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["clearPointerMoveOpened", "invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          }
        ],
        close: [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    open: {
      effects: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
      entry: ["setGlobalId"],
      on: {
        "controlled.close": {
          target: "closed"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "pointer.leave": [
          {
            guard: "isVisible",
            target: "closing",
            actions: ["clearPointerMoveOpened"]
          },
          // == group ==
          {
            guard: "isOpenControlled",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          }
        ],
        "content.pointer.leave": {
          guard: "isInteractive",
          target: "closing"
        },
        "positioning.set": {
          actions: ["reposition"]
        }
      }
    },
    closing: {
      effects: ["trackPositioning", "waitForCloseDelay"],
      on: {
        "after.closeDelay": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "controlled.close": {
          target: "closed"
        },
        "controlled.open": {
          target: "open"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "pointer.move": [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["setPointerMoveOpened", "invokeOnOpen", "toggleVisibility"]
          },
          {
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ],
        "content.pointer.move": {
          guard: "isInteractive",
          target: "open"
        },
        "positioning.set": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      noVisibleTooltip: () => store.get("id") === null,
      isVisible: ({ prop }) => prop("id") === store.get("id"),
      isInteractive: ({ prop }) => !!prop("interactive"),
      hasPointerMoveOpened: ({ context }) => context.get("hasPointerMoveOpened"),
      isOpenControlled: ({ prop }) => prop("open") !== void 0
    },
    actions: {
      setGlobalId: ({ prop }) => {
        store.set("id", prop("id"));
      },
      clearGlobalId: ({ prop }) => {
        if (prop("id") === store.get("id")) {
          store.set("id", null);
        }
      },
      invokeOnOpen: ({ prop }) => {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose: ({ prop }) => {
        prop("onOpenChange")?.({ open: false });
      },
      closeIfDisabled: ({ prop, send }) => {
        if (!prop("disabled")) return;
        send({ type: "close", src: "disabled.change" });
      },
      reposition: ({ context, event, prop, scope }) => {
        if (event.type !== "positioning.set") return;
        const getPositionerEl22 = () => getPositionerEl7(scope);
        return getPlacement(getTriggerEl8(scope), getPositionerEl22, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility: ({ prop, event, send }) => {
        queueMicrotask(() => {
          send({
            type: prop("open") ? "controlled.open" : "controlled.close",
            previousEvent: event
          });
        });
      },
      setPointerMoveOpened: ({ context }) => {
        context.set("hasPointerMoveOpened", true);
      },
      clearPointerMoveOpened: ({ context }) => {
        context.set("hasPointerMoveOpened", false);
      }
    },
    effects: {
      trackFocusVisible: ({ scope }) => {
        return trackFocusVisible({ root: scope.getRootNode?.() });
      },
      trackPositioning: ({ context, prop, scope }) => {
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", prop("positioning").placement);
        }
        const getPositionerEl22 = () => getPositionerEl7(scope);
        return getPlacement(getTriggerEl8(scope), getPositionerEl22, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackPointerlockChange: ({ send, scope }) => {
        const doc = scope.getDoc();
        const onChange = () => send({ type: "close", src: "pointerlock:change" });
        return addDomEvent(doc, "pointerlockchange", onChange, false);
      },
      trackScroll: ({ send, prop, scope }) => {
        if (!prop("closeOnScroll")) return;
        const triggerEl = getTriggerEl8(scope);
        if (!triggerEl) return;
        const overflowParents = getOverflowAncestors(triggerEl);
        const cleanups = overflowParents.map((overflowParent) => {
          const onScroll = () => {
            send({ type: "close", src: "scroll" });
          };
          return addDomEvent(overflowParent, "scroll", onScroll, {
            passive: true,
            capture: true
          });
        });
        return () => {
          cleanups.forEach((fn) => fn?.());
        };
      },
      trackStore: ({ prop, send }) => {
        let cleanup;
        queueMicrotask(() => {
          cleanup = store.subscribe(() => {
            if (store.get("id") !== prop("id")) {
              send({ type: "close", src: "id.change" });
            }
          });
        });
        return () => cleanup?.();
      },
      trackEscapeKey: ({ send, prop }) => {
        if (!prop("closeOnEscape")) return;
        const onKeyDown = (event) => {
          if (isComposingEvent(event)) return;
          if (event.key !== "Escape") return;
          event.stopPropagation();
          send({ type: "close", src: "keydown.escape" });
        };
        return addDomEvent(document, "keydown", onKeyDown, true);
      },
      waitForOpenDelay: ({ send, prop }) => {
        const id = setTimeout(() => {
          send({ type: "after.openDelay" });
        }, prop("openDelay"));
        return () => clearTimeout(id);
      },
      waitForCloseDelay: ({ send, prop }) => {
        const id = setTimeout(() => {
          send({ type: "after.closeDelay" });
        }, prop("closeDelay"));
        return () => clearTimeout(id);
      }
    }
  }
});
var props23 = createProps()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "defaultOpen",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps24 = createSplitProps(props23);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/modules/provider.svelte.js
function useTooltip(props25) {
  const service = useMachine(machine24, props25);
  const tooltip = tag(user_derived(() => connect24(service, normalizeProps)), "tooltip");
  return () => get(tooltip);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/root-provider.svelte
Root_provider23[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/root-provider.svelte";
function Root_provider23($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider23);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const children = tag(user_derived(() => $$props.children), "children"), tooltip = tag(user_derived(() => $$props.value), "tooltip");
  RootContext25.provide(() => get(tooltip)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root_provider23, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider23 = hmr(Root_provider23);
  import.meta.hot.accept((module) => {
    Root_provider23[HMR].update(module.default);
  });
}
var root_provider_default23 = Root_provider23;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/root.svelte
Root27[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/root.svelte";
function Root27($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root27);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps24(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), tooltipProps = tag(user_derived(() => get($$array)[0]), "tooltipProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const children = tag(user_derived(() => get(componentProps).children), "children");
  const tooltip = useTooltip(() => ({ ...get(tooltipProps), id }));
  RootContext25.provide(() => tooltip());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Root27, 27, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root27 = hmr(Root27);
  import.meta.hot.accept((module) => {
    Root27[HMR].update(module.default);
  });
}
var root_default27 = Root27;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/trigger.svelte
Trigger12[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/anatomy/trigger.svelte";
var root_2223 = add_locations(from_html(`<button><!></button>`), Trigger12[FILENAME], [[24, 1]]);
function Trigger12($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trigger12);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const tooltip = RootContext25.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(tooltip().getTriggerProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Trigger12, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2223();
      attribute_effect(button, () => ({ ...get(attributes) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Trigger12, 25, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Trigger12,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trigger12 = hmr(Trigger12);
  import.meta.hot.accept((module) => {
    Trigger12[HMR].update(module.default);
  });
}
var trigger_default12 = Trigger12;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tooltip/modules/anatomy.js
var Tooltip = Object.assign(root_default27, {
  Provider: root_provider_default23,
  Context: root_context_default24,
  Trigger: trigger_default12,
  Positioner: positioner_default7,
  Content: content_default12,
  Arrow: arrow_default3,
  ArrowTip: arrow_tip_default3
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/modules/node-context.js
var NodeContext = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/modules/root-context.js
var RootContext26 = createContext();

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-content.svelte
Branch_content[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-content.svelte";
var root_2224 = add_locations(from_html(`<div><!></div>`), Branch_content[FILENAME], [[26, 1]]);
function Branch_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Branch_content);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const nodeProps = NodeContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(treeView().getBranchContentProps(nodeProps()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Branch_content, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2224();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Branch_content, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Branch_content,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Branch_content = hmr(Branch_content);
  import.meta.hot.accept((module) => {
    Branch_content[HMR].update(module.default);
  });
}
var branch_content_default = Branch_content;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-control.svelte
Branch_control[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-control.svelte";
var root_2225 = add_locations(from_html(`<div><!></div>`), Branch_control[FILENAME], [[26, 1]]);
function Branch_control($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Branch_control);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const nodeProps = NodeContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(treeView().getBranchControlProps(nodeProps()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Branch_control, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2225();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Branch_control, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Branch_control,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Branch_control = hmr(Branch_control);
  import.meta.hot.accept((module) => {
    Branch_control[HMR].update(module.default);
  });
}
var branch_control_default = Branch_control;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-indent-guide.svelte
Branch_indent_guide[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-indent-guide.svelte";
var root_2226 = add_locations(from_html(`<div><!></div>`), Branch_indent_guide[FILENAME], [[26, 1]]);
function Branch_indent_guide($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Branch_indent_guide);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const nodeProps = NodeContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(treeView().getBranchIndentGuideProps(nodeProps()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Branch_indent_guide, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2226();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Branch_indent_guide, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Branch_indent_guide,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Branch_indent_guide = hmr(Branch_indent_guide);
  import.meta.hot.accept((module) => {
    Branch_indent_guide[HMR].update(module.default);
  });
}
var branch_indent_guide_default = Branch_indent_guide;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-indicator.svelte
Branch_indicator[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-indicator.svelte";
var chevronRight2 = wrap_snippet(Branch_indicator, function($$anchor) {
  validate_snippet_args(...arguments);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => chevron_right_default(node, { class: "size-4" }), "component", Branch_indicator, 25, 1, { componentTag: "ChevronRight" });
  append($$anchor, fragment);
});
var root_313 = add_locations(from_html(`<span><!></span>`), Branch_indicator[FILENAME], [[31, 1]]);
function Branch_indicator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Branch_indicator);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const nodeProps = NodeContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => fallback($$props.children, chevronRight2)), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(treeView().getBranchIndicatorProps(nodeProps()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment_1 = comment();
  var node_1 = first_child(fragment_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_2, () => get(element2), () => get(attributes)), "render", Branch_indicator, 29, 1);
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var span = root_313();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_3 = child(span);
      add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Branch_indicator, 32, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Branch_indicator,
      28,
      0
    );
  }
  append($$anchor, fragment_1);
  return pop($$exports);
}
if (import.meta.hot) {
  Branch_indicator = hmr(Branch_indicator);
  import.meta.hot.accept((module) => {
    Branch_indicator[HMR].update(module.default);
  });
}
var branch_indicator_default = Branch_indicator;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-text.svelte
Branch_text[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch-text.svelte";
var root_2227 = add_locations(from_html(`<span><!></span>`), Branch_text[FILENAME], [[26, 1]]);
function Branch_text($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Branch_text);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const nodeProps = NodeContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(treeView().getBranchTextProps(nodeProps()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Branch_text, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2227();
      attribute_effect(span, () => ({ ...get(attributes) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Branch_text, 27, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Branch_text,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Branch_text = hmr(Branch_text);
  import.meta.hot.accept((module) => {
    Branch_text[HMR].update(module.default);
  });
}
var branch_text_default = Branch_text;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch.svelte
Branch[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/branch.svelte";
var root_2228 = add_locations(from_html(`<div><!></div>`), Branch[FILENAME], [[26, 1]]);
function Branch($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Branch);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const nodeProps = NodeContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(treeView().getBranchProps(nodeProps()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Branch, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2228();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Branch, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Branch,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Branch = hmr(Branch);
  import.meta.hot.accept((module) => {
    Branch[HMR].update(module.default);
  });
}
var branch_default = Branch;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/item.svelte
Item13[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/item.svelte";
var root_2229 = add_locations(from_html(`<div><!></div>`), Item13[FILENAME], [[26, 1]]);
function Item13($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item13);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const nodeProps = NodeContext.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(treeView().getItemProps(nodeProps()), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Item13, 24, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2229();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Item13, 27, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Item13,
      23,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Item13 = hmr(Item13);
  import.meta.hot.accept((module) => {
    Item13[HMR].update(module.default);
  });
}
var item_default13 = Item13;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/label.svelte
Label12[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/label.svelte";
function Label12($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label12);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const level = tag(user_derived(() => fallback($$props.level, 3)), "level"), element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["level", "element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(treeView().getLabelProps(), get(rest))), "attributes");
  const tag2 = tag(user_derived(() => `h${get(level)}`), "tag");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Label12, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        validate_dynamic_element_tag(() => get(tag2));
        validate_void_dynamic_element(() => get(tag2));
        element(
          node_2,
          () => get(tag2),
          false,
          ($$element, $$anchor3) => {
            attribute_effect($$element, () => ({ ...get(attributes) }));
            var fragment_3 = comment();
            var node_3 = first_child(fragment_3);
            add_svelte_meta(() => snippet(node_3, () => get(children) ?? noop), "render", Label12, 34, 2);
            append($$anchor3, fragment_3);
          },
          void 0,
          [33, 1]
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label12,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Label12 = hmr(Label12);
  import.meta.hot.accept((module) => {
    Label12[HMR].update(module.default);
  });
}
var label_default12 = Label12;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/node-context.svelte
Node_context[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/node-context.svelte";
function Node_context($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Node_context);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const nodeProps = NodeContext.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => nodeProps), "render", Node_context, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Node_context = hmr(Node_context);
  import.meta.hot.accept((module) => {
    Node_context[HMR].update(module.default);
  });
}
var node_context_default = Node_context;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/node-provider.svelte
Node_provider[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/node-provider.svelte";
function Node_provider($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Node_provider);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const children = tag(user_derived(() => $$props.children), "children"), nodeProps = tag(user_derived(() => $$props.value), "nodeProps");
  NodeContext.provide(() => get(nodeProps));
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children) ?? noop), "render", Node_provider, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Node_provider = hmr(Node_provider);
  import.meta.hot.accept((module) => {
    Node_provider[HMR].update(module.default);
  });
}
var node_provider_default = Node_provider;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/root-context.svelte
Root_context25[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/root-context.svelte";
function Root_context25($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_context25);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const children = tag(user_derived(() => $$props.children), "children");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => get(children), () => treeView), "render", Root_context25, 20, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_context25 = hmr(Root_context25);
  import.meta.hot.accept((module) => {
    Root_context25[HMR].update(module.default);
  });
}
var root_context_default25 = Root_context25;

// node_modules/@zag-js/tree-view/dist/index.mjs
var anatomy25 = createAnatomy("tree-view").parts(
  "branch",
  "branchContent",
  "branchControl",
  "branchIndentGuide",
  "branchIndicator",
  "branchText",
  "branchTrigger",
  "item",
  "itemIndicator",
  "itemText",
  "label",
  "nodeCheckbox",
  "nodeRenameInput",
  "root",
  "tree"
);
var parts25 = anatomy25.build();
var collection3 = (options) => {
  return new TreeCollection(options);
};
collection3.empty = () => {
  return new TreeCollection({ rootNode: { children: [] } });
};
var getRootId20 = (ctx) => ctx.ids?.root ?? `tree:${ctx.id}:root`;
var getLabelId11 = (ctx) => ctx.ids?.label ?? `tree:${ctx.id}:label`;
var getNodeId = (ctx, value) => ctx.ids?.node?.(value) ?? `tree:${ctx.id}:node:${value}`;
var getTreeId = (ctx) => ctx.ids?.tree ?? `tree:${ctx.id}:tree`;
var focusNode = (ctx, value) => {
  if (value == null) return;
  ctx.getById(getNodeId(ctx, value))?.focus();
};
var getRenameInputId = (ctx, value) => `tree:${ctx.id}:rename-input:${value}`;
var getRenameInputEl = (ctx, value) => {
  return ctx.getById(getRenameInputId(ctx, value));
};
function getCheckedState(collection22, node, checkedValue) {
  const value = collection22.getNodeValue(node);
  if (!collection22.isBranchNode(node)) {
    return checkedValue.includes(value);
  }
  const childValues = collection22.getDescendantValues(value);
  const allChecked = childValues.every((v) => checkedValue.includes(v));
  const someChecked = childValues.some((v) => checkedValue.includes(v));
  return allChecked ? true : someChecked ? "indeterminate" : false;
}
function toggleBranchChecked(collection22, value, checkedValue) {
  const childValues = collection22.getDescendantValues(value);
  const allChecked = childValues.every((child2) => checkedValue.includes(child2));
  return uniq(allChecked ? remove(checkedValue, ...childValues) : add(checkedValue, ...childValues));
}
function getCheckedValueMap(collection22, checkedValue) {
  const map2 = /* @__PURE__ */ new Map();
  collection22.visit({
    onEnter: (node) => {
      const value = collection22.getNodeValue(node);
      const isBranch = collection22.isBranchNode(node);
      const checked = getCheckedState(collection22, node, checkedValue);
      map2.set(value, {
        type: isBranch ? "branch" : "leaf",
        checked
      });
    }
  });
  return map2;
}
function connect25(service, normalize2) {
  const { context, scope, computed, prop, send } = service;
  const collection22 = prop("collection");
  const expandedValue = Array.from(context.get("expandedValue"));
  const selectedValue = Array.from(context.get("selectedValue"));
  const checkedValue = Array.from(context.get("checkedValue"));
  const isTypingAhead = computed("isTypingAhead");
  const focusedValue = context.get("focusedValue");
  const loadingStatus = context.get("loadingStatus");
  const renamingValue = context.get("renamingValue");
  function getNodeState(props25) {
    const { node, indexPath } = props25;
    const value = collection22.getNodeValue(node);
    const firstNode = collection22.getFirstNode();
    const firstNodeValue = firstNode ? collection22.getNodeValue(firstNode) : null;
    return {
      id: getNodeId(scope, value),
      value,
      indexPath,
      valuePath: collection22.getValuePath(indexPath),
      disabled: Boolean(node.disabled),
      focused: focusedValue == null ? firstNodeValue == value : focusedValue === value,
      selected: selectedValue.includes(value),
      expanded: expandedValue.includes(value),
      loading: loadingStatus[value] === "loading",
      depth: indexPath.length,
      isBranch: collection22.isBranchNode(node),
      renaming: renamingValue === value,
      get checked() {
        return getCheckedState(collection22, node, checkedValue);
      }
    };
  }
  return {
    collection: collection22,
    expandedValue,
    selectedValue,
    checkedValue,
    toggleChecked(value, isBranch) {
      send({ type: "CHECKED.TOGGLE", value, isBranch });
    },
    setChecked(value) {
      send({ type: "CHECKED.SET", value });
    },
    clearChecked() {
      send({ type: "CHECKED.CLEAR" });
    },
    getCheckedMap() {
      return getCheckedValueMap(collection22, checkedValue);
    },
    expand(value) {
      send({ type: value ? "BRANCH.EXPAND" : "EXPANDED.ALL", value });
    },
    collapse(value) {
      send({ type: value ? "BRANCH.COLLAPSE" : "EXPANDED.CLEAR", value });
    },
    deselect(value) {
      send({ type: value ? "NODE.DESELECT" : "SELECTED.CLEAR", value });
    },
    select(value) {
      send({ type: value ? "NODE.SELECT" : "SELECTED.ALL", value, isTrusted: false });
    },
    getVisibleNodes() {
      return computed("visibleNodes");
    },
    focus(value) {
      focusNode(scope, value);
    },
    selectParent(value) {
      const parentNode = collection22.getParentNode(value);
      if (!parentNode) return;
      const _selectedValue = add(selectedValue, collection22.getNodeValue(parentNode));
      send({ type: "SELECTED.SET", value: _selectedValue, src: "select.parent" });
    },
    expandParent(value) {
      const parentNode = collection22.getParentNode(value);
      if (!parentNode) return;
      const _expandedValue = add(expandedValue, collection22.getNodeValue(parentNode));
      send({ type: "EXPANDED.SET", value: _expandedValue, src: "expand.parent" });
    },
    setExpandedValue(value) {
      const _expandedValue = uniq(value);
      send({ type: "EXPANDED.SET", value: _expandedValue });
    },
    setSelectedValue(value) {
      const _selectedValue = uniq(value);
      send({ type: "SELECTED.SET", value: _selectedValue });
    },
    startRenaming(value) {
      send({ type: "NODE.RENAME", value });
    },
    submitRenaming(value, label) {
      send({ type: "RENAME.SUBMIT", value, label });
    },
    cancelRenaming() {
      send({ type: "RENAME.CANCEL" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts25.root.attrs,
        id: getRootId20(scope),
        dir: prop("dir")
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts25.label.attrs,
        id: getLabelId11(scope),
        dir: prop("dir")
      });
    },
    getTreeProps() {
      return normalize2.element({
        ...parts25.tree.attrs,
        id: getTreeId(scope),
        dir: prop("dir"),
        role: "tree",
        "aria-label": "Tree View",
        "aria-labelledby": getLabelId11(scope),
        "aria-multiselectable": prop("selectionMode") === "multiple" || void 0,
        tabIndex: -1,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const target = getEventTarget(event);
          if (isEditableElement(target)) return;
          const node = target?.closest("[data-part=branch-control], [data-part=item]");
          if (!node) return;
          const nodeId = node.dataset.value;
          if (nodeId == null) {
            console.warn(`[zag-js/tree-view] Node id not found for node`, node);
            return;
          }
          const isBranchNode = node.matches("[data-part=branch-control]");
          const keyMap2 = {
            ArrowDown(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.ARROW_DOWN", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowUp(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.ARROW_UP", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowLeft(event2) {
              if (isModifierKey(event2) || node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: isBranchNode ? "BRANCH_NODE.ARROW_LEFT" : "NODE.ARROW_LEFT", id: nodeId });
            },
            ArrowRight(event2) {
              if (!isBranchNode || node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "BRANCH_NODE.ARROW_RIGHT", id: nodeId });
            },
            Home(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.HOME", id: nodeId, shiftKey: event2.shiftKey });
            },
            End(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.END", id: nodeId, shiftKey: event2.shiftKey });
            },
            Space(event2) {
              if (node.dataset.disabled) return;
              if (isTypingAhead) {
                send({ type: "TREE.TYPEAHEAD", key: event2.key });
              } else {
                keyMap2.Enter?.(event2);
              }
            },
            Enter(event2) {
              if (node.dataset.disabled) return;
              if (isAnchorElement(target) && isModifierKey(event2)) return;
              send({ type: isBranchNode ? "BRANCH_NODE.CLICK" : "NODE.CLICK", id: nodeId, src: "keyboard" });
              if (!isAnchorElement(target)) {
                event2.preventDefault();
              }
            },
            "*"(event2) {
              if (node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "SIBLINGS.EXPAND", id: nodeId });
            },
            a(event2) {
              if (!event2.metaKey || node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "SELECTED.ALL", moveFocus: true });
            },
            F2(event2) {
              if (node.dataset.disabled) return;
              const canRenameFn = prop("canRename");
              if (!canRenameFn) return;
              const indexPath = collection22.getIndexPath(nodeId);
              if (indexPath) {
                const node2 = collection22.at(indexPath);
                if (node2 && !canRenameFn(node2, indexPath)) {
                  return;
                }
              }
              event2.preventDefault();
              send({ type: "NODE.RENAME", value: nodeId });
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            return;
          }
          if (!getByTypeahead.isValidEvent(event)) return;
          send({ type: "TREE.TYPEAHEAD", key: event.key, id: nodeId });
          event.preventDefault();
        }
      });
    },
    getNodeState,
    getItemProps(props25) {
      const nodeState = getNodeState(props25);
      return normalize2.element({
        ...parts25.item.attrs,
        id: nodeState.id,
        dir: prop("dir"),
        "data-ownedby": getTreeId(scope),
        "data-path": props25.indexPath.join("/"),
        "data-value": nodeState.value,
        tabIndex: nodeState.focused ? 0 : -1,
        "data-focus": dataAttr(nodeState.focused),
        role: "treeitem",
        "aria-current": nodeState.selected ? "true" : void 0,
        "aria-selected": nodeState.disabled ? void 0 : nodeState.selected,
        "data-selected": dataAttr(nodeState.selected),
        "aria-disabled": ariaAttr(nodeState.disabled),
        "data-disabled": dataAttr(nodeState.disabled),
        "data-renaming": dataAttr(nodeState.renaming),
        "aria-level": nodeState.depth,
        "data-depth": nodeState.depth,
        style: {
          "--depth": nodeState.depth
        },
        onFocus(event) {
          event.stopPropagation();
          send({ type: "NODE.FOCUS", id: nodeState.value });
        },
        onClick(event) {
          if (nodeState.disabled) return;
          if (!isLeftClick(event)) return;
          if (isAnchorElement(event.currentTarget) && isModifierKey(event)) return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "NODE.CLICK", id: nodeState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
          if (!isAnchorElement(event.currentTarget)) {
            event.preventDefault();
          }
        }
      });
    },
    getItemTextProps(props25) {
      const itemState = getNodeState(props25);
      return normalize2.element({
        ...parts25.itemText.attrs,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused)
      });
    },
    getItemIndicatorProps(props25) {
      const itemState = getNodeState(props25);
      return normalize2.element({
        ...parts25.itemIndicator.attrs,
        "aria-hidden": true,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused),
        hidden: !itemState.selected
      });
    },
    getBranchProps(props25) {
      const nodeState = getNodeState(props25);
      return normalize2.element({
        ...parts25.branch.attrs,
        "data-depth": nodeState.depth,
        dir: prop("dir"),
        "data-branch": nodeState.value,
        role: "treeitem",
        "data-ownedby": getTreeId(scope),
        "data-value": nodeState.value,
        "aria-level": nodeState.depth,
        "aria-selected": nodeState.disabled ? void 0 : nodeState.selected,
        "data-path": props25.indexPath.join("/"),
        "data-selected": dataAttr(nodeState.selected),
        "aria-expanded": nodeState.expanded,
        "data-state": nodeState.expanded ? "open" : "closed",
        "aria-disabled": ariaAttr(nodeState.disabled),
        "data-disabled": dataAttr(nodeState.disabled),
        "data-loading": dataAttr(nodeState.loading),
        "aria-busy": ariaAttr(nodeState.loading),
        style: {
          "--depth": nodeState.depth
        }
      });
    },
    getBranchIndicatorProps(props25) {
      const nodeState = getNodeState(props25);
      return normalize2.element({
        ...parts25.branchIndicator.attrs,
        "aria-hidden": true,
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(nodeState.disabled),
        "data-selected": dataAttr(nodeState.selected),
        "data-focus": dataAttr(nodeState.focused),
        "data-loading": dataAttr(nodeState.loading)
      });
    },
    getBranchTriggerProps(props25) {
      const nodeState = getNodeState(props25);
      return normalize2.element({
        ...parts25.branchTrigger.attrs,
        role: "button",
        dir: prop("dir"),
        "data-disabled": dataAttr(nodeState.disabled),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-value": nodeState.value,
        "data-loading": dataAttr(nodeState.loading),
        disabled: nodeState.loading,
        onClick(event) {
          if (nodeState.disabled || nodeState.loading) return;
          send({ type: "BRANCH_TOGGLE.CLICK", id: nodeState.value });
          event.stopPropagation();
        }
      });
    },
    getBranchControlProps(props25) {
      const nodeState = getNodeState(props25);
      return normalize2.element({
        ...parts25.branchControl.attrs,
        role: "button",
        id: nodeState.id,
        dir: prop("dir"),
        tabIndex: nodeState.focused ? 0 : -1,
        "data-path": props25.indexPath.join("/"),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(nodeState.disabled),
        "data-selected": dataAttr(nodeState.selected),
        "data-focus": dataAttr(nodeState.focused),
        "data-renaming": dataAttr(nodeState.renaming),
        "data-value": nodeState.value,
        "data-depth": nodeState.depth,
        "data-loading": dataAttr(nodeState.loading),
        "aria-busy": ariaAttr(nodeState.loading),
        onFocus(event) {
          send({ type: "NODE.FOCUS", id: nodeState.value });
          event.stopPropagation();
        },
        onClick(event) {
          if (nodeState.disabled) return;
          if (nodeState.loading) return;
          if (!isLeftClick(event)) return;
          if (isAnchorElement(event.currentTarget) && isModifierKey(event)) return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "BRANCH_NODE.CLICK", id: nodeState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
        }
      });
    },
    getBranchTextProps(props25) {
      const nodeState = getNodeState(props25);
      return normalize2.element({
        ...parts25.branchText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(nodeState.disabled),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-loading": dataAttr(nodeState.loading)
      });
    },
    getBranchContentProps(props25) {
      const nodeState = getNodeState(props25);
      return normalize2.element({
        ...parts25.branchContent.attrs,
        role: "group",
        dir: prop("dir"),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-depth": nodeState.depth,
        "data-path": props25.indexPath.join("/"),
        "data-value": nodeState.value,
        hidden: !nodeState.expanded
      });
    },
    getBranchIndentGuideProps(props25) {
      const nodeState = getNodeState(props25);
      return normalize2.element({
        ...parts25.branchIndentGuide.attrs,
        "data-depth": nodeState.depth
      });
    },
    getNodeCheckboxProps(props25) {
      const nodeState = getNodeState(props25);
      const checkedState = nodeState.checked;
      return normalize2.element({
        ...parts25.nodeCheckbox.attrs,
        tabIndex: -1,
        role: "checkbox",
        "data-state": checkedState === true ? "checked" : checkedState === false ? "unchecked" : "indeterminate",
        "aria-checked": checkedState === true ? "true" : checkedState === false ? "false" : "mixed",
        "data-disabled": dataAttr(nodeState.disabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (nodeState.disabled) return;
          if (!isLeftClick(event)) return;
          send({ type: "CHECKED.TOGGLE", value: nodeState.value, isBranch: nodeState.isBranch });
          event.stopPropagation();
          const node = event.currentTarget.closest("[role=treeitem]");
          node?.focus({ preventScroll: true });
        }
      });
    },
    getNodeRenameInputProps(props25) {
      const nodeState = getNodeState(props25);
      return normalize2.input({
        ...parts25.nodeRenameInput.attrs,
        id: getRenameInputId(scope, nodeState.value),
        type: "text",
        "aria-label": "Rename tree item",
        hidden: !nodeState.renaming,
        onKeyDown(event) {
          if (isComposingEvent(event)) return;
          if (event.key === "Escape") {
            send({ type: "RENAME.CANCEL" });
            event.preventDefault();
          }
          if (event.key === "Enter") {
            send({ type: "RENAME.SUBMIT", label: event.currentTarget.value });
            event.preventDefault();
          }
          event.stopPropagation();
        },
        onBlur(event) {
          send({ type: "RENAME.SUBMIT", label: event.currentTarget.value });
        }
      });
    }
  };
}
function expandBranches(params, values) {
  const { context, prop, refs } = params;
  if (!prop("loadChildren")) {
    context.set("expandedValue", (prev2) => uniq(add(prev2, ...values)));
    return;
  }
  const loadingStatus = context.get("loadingStatus");
  const [loadedValues, loadingValues] = partition(values, (value) => loadingStatus[value] === "loaded");
  if (loadedValues.length > 0) {
    context.set("expandedValue", (prev2) => uniq(add(prev2, ...loadedValues)));
  }
  if (loadingValues.length === 0) return;
  const collection22 = prop("collection");
  const [nodeWithChildren, nodeWithoutChildren] = partition(loadingValues, (id) => {
    const node = collection22.findNode(id);
    return collection22.getNodeChildren(node).length > 0;
  });
  if (nodeWithChildren.length > 0) {
    context.set("expandedValue", (prev2) => uniq(add(prev2, ...nodeWithChildren)));
  }
  if (nodeWithoutChildren.length === 0) return;
  context.set("loadingStatus", (prev2) => ({
    ...prev2,
    ...nodeWithoutChildren.reduce((acc, id) => ({ ...acc, [id]: "loading" }), {})
  }));
  const nodesToLoad = nodeWithoutChildren.map((id) => {
    const indexPath = collection22.getIndexPath(id);
    const valuePath = collection22.getValuePath(indexPath);
    const node = collection22.findNode(id);
    return { id, indexPath, valuePath, node };
  });
  const pendingAborts = refs.get("pendingAborts");
  const loadChildren = prop("loadChildren");
  ensure(loadChildren, () => "[zag-js/tree-view] `loadChildren` is required for async expansion");
  const proms = nodesToLoad.map(({ id, indexPath, valuePath, node }) => {
    const existingAbort = pendingAborts.get(id);
    if (existingAbort) {
      existingAbort.abort();
      pendingAborts.delete(id);
    }
    const abortController = new AbortController();
    pendingAborts.set(id, abortController);
    return loadChildren({
      valuePath,
      indexPath,
      node,
      signal: abortController.signal
    });
  });
  Promise.allSettled(proms).then((results) => {
    const loadedValues2 = [];
    const nodeWithErrors = [];
    const nextLoadingStatus = context.get("loadingStatus");
    let collection32 = prop("collection");
    results.forEach((result, index) => {
      const { id, indexPath, node, valuePath } = nodesToLoad[index];
      if (result.status === "fulfilled") {
        nextLoadingStatus[id] = "loaded";
        loadedValues2.push(id);
        collection32 = collection32.replace(indexPath, { ...node, children: result.value });
      } else {
        pendingAborts.delete(id);
        Reflect.deleteProperty(nextLoadingStatus, id);
        nodeWithErrors.push({ node, error: result.reason, indexPath, valuePath });
      }
    });
    context.set("loadingStatus", nextLoadingStatus);
    if (loadedValues2.length) {
      context.set("expandedValue", (prev2) => uniq(add(prev2, ...loadedValues2)));
      prop("onLoadChildrenComplete")?.({ collection: collection32 });
    }
    if (nodeWithErrors.length) {
      prop("onLoadChildrenError")?.({ nodes: nodeWithErrors });
    }
  });
}
function skipFn(params) {
  const { prop, context } = params;
  return function skip({ indexPath }) {
    const paths = prop("collection").getValuePath(indexPath).slice(0, -1);
    return paths.some((value) => !context.get("expandedValue").includes(value));
  };
}
var { and: and10 } = createGuards();
var machine25 = createMachine({
  props({ props: props25 }) {
    return {
      selectionMode: "single",
      collection: collection3.empty(),
      typeahead: true,
      expandOnClick: true,
      defaultExpandedValue: [],
      defaultSelectedValue: [],
      ...props25
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable: bindable2, getContext: getContext2 }) {
    return {
      expandedValue: bindable2(() => ({
        defaultValue: prop("defaultExpandedValue"),
        value: prop("expandedValue"),
        isEqual,
        onChange(expandedValue) {
          const ctx = getContext2();
          const focusedValue = ctx.get("focusedValue");
          prop("onExpandedChange")?.({
            expandedValue,
            focusedValue,
            get expandedNodes() {
              return prop("collection").findNodes(expandedValue);
            }
          });
        }
      })),
      selectedValue: bindable2(() => ({
        defaultValue: prop("defaultSelectedValue"),
        value: prop("selectedValue"),
        isEqual,
        onChange(selectedValue) {
          const ctx = getContext2();
          const focusedValue = ctx.get("focusedValue");
          prop("onSelectionChange")?.({
            selectedValue,
            focusedValue,
            get selectedNodes() {
              return prop("collection").findNodes(selectedValue);
            }
          });
        }
      })),
      focusedValue: bindable2(() => ({
        defaultValue: prop("defaultFocusedValue") || null,
        value: prop("focusedValue"),
        onChange(focusedValue) {
          prop("onFocusChange")?.({
            focusedValue,
            get focusedNode() {
              return focusedValue ? prop("collection").findNode(focusedValue) : null;
            }
          });
        }
      })),
      loadingStatus: bindable2(() => ({
        defaultValue: {}
      })),
      checkedValue: bindable2(() => ({
        defaultValue: prop("defaultCheckedValue") || [],
        value: prop("checkedValue"),
        isEqual,
        onChange(value) {
          prop("onCheckedChange")?.({ checkedValue: value });
        }
      })),
      renamingValue: bindable2(() => ({
        sync: true,
        defaultValue: null
      }))
    };
  },
  refs() {
    return {
      typeaheadState: { ...getByTypeahead.defaultOptions },
      pendingAborts: /* @__PURE__ */ new Map()
    };
  },
  computed: {
    isMultipleSelection: ({ prop }) => prop("selectionMode") === "multiple",
    isTypingAhead: ({ refs }) => refs.get("typeaheadState").keysSoFar.length > 0,
    visibleNodes: ({ prop, context }) => {
      const nodes = [];
      prop("collection").visit({
        skip: skipFn({ prop, context }),
        onEnter: (node, indexPath) => {
          nodes.push({ node, indexPath });
        }
      });
      return nodes;
    }
  },
  on: {
    "EXPANDED.SET": {
      actions: ["setExpanded"]
    },
    "EXPANDED.CLEAR": {
      actions: ["clearExpanded"]
    },
    "EXPANDED.ALL": {
      actions: ["expandAllBranches"]
    },
    "BRANCH.EXPAND": {
      actions: ["expandBranches"]
    },
    "BRANCH.COLLAPSE": {
      actions: ["collapseBranches"]
    },
    "SELECTED.SET": {
      actions: ["setSelected"]
    },
    "SELECTED.ALL": [
      {
        guard: and10("isMultipleSelection", "moveFocus"),
        actions: ["selectAllNodes", "focusTreeLastNode"]
      },
      {
        guard: "isMultipleSelection",
        actions: ["selectAllNodes"]
      }
    ],
    "SELECTED.CLEAR": {
      actions: ["clearSelected"]
    },
    "NODE.SELECT": {
      actions: ["selectNode"]
    },
    "NODE.DESELECT": {
      actions: ["deselectNode"]
    },
    "CHECKED.TOGGLE": {
      actions: ["toggleChecked"]
    },
    "CHECKED.SET": {
      actions: ["setChecked"]
    },
    "CHECKED.CLEAR": {
      actions: ["clearChecked"]
    },
    "NODE.FOCUS": {
      actions: ["setFocusedNode"]
    },
    "NODE.ARROW_DOWN": [
      {
        guard: and10("isShiftKey", "isMultipleSelection"),
        actions: ["focusTreeNextNode", "extendSelectionToNextNode"]
      },
      {
        actions: ["focusTreeNextNode"]
      }
    ],
    "NODE.ARROW_UP": [
      {
        guard: and10("isShiftKey", "isMultipleSelection"),
        actions: ["focusTreePrevNode", "extendSelectionToPrevNode"]
      },
      {
        actions: ["focusTreePrevNode"]
      }
    ],
    "NODE.ARROW_LEFT": {
      actions: ["focusBranchNode"]
    },
    "BRANCH_NODE.ARROW_LEFT": [
      {
        guard: "isBranchExpanded",
        actions: ["collapseBranch"]
      },
      {
        actions: ["focusBranchNode"]
      }
    ],
    "BRANCH_NODE.ARROW_RIGHT": [
      {
        guard: and10("isBranchFocused", "isBranchExpanded"),
        actions: ["focusBranchFirstNode"]
      },
      {
        actions: ["expandBranch"]
      }
    ],
    "SIBLINGS.EXPAND": {
      actions: ["expandSiblingBranches"]
    },
    "NODE.HOME": [
      {
        guard: and10("isShiftKey", "isMultipleSelection"),
        actions: ["extendSelectionToFirstNode", "focusTreeFirstNode"]
      },
      {
        actions: ["focusTreeFirstNode"]
      }
    ],
    "NODE.END": [
      {
        guard: and10("isShiftKey", "isMultipleSelection"),
        actions: ["extendSelectionToLastNode", "focusTreeLastNode"]
      },
      {
        actions: ["focusTreeLastNode"]
      }
    ],
    "NODE.CLICK": [
      {
        guard: and10("isCtrlKey", "isMultipleSelection"),
        actions: ["toggleNodeSelection"]
      },
      {
        guard: and10("isShiftKey", "isMultipleSelection"),
        actions: ["extendSelectionToNode"]
      },
      {
        actions: ["selectNode"]
      }
    ],
    "BRANCH_NODE.CLICK": [
      {
        guard: and10("isCtrlKey", "isMultipleSelection"),
        actions: ["toggleNodeSelection"]
      },
      {
        guard: and10("isShiftKey", "isMultipleSelection"),
        actions: ["extendSelectionToNode"]
      },
      {
        guard: "expandOnClick",
        actions: ["selectNode", "toggleBranchNode"]
      },
      {
        actions: ["selectNode"]
      }
    ],
    "BRANCH_TOGGLE.CLICK": {
      actions: ["toggleBranchNode"]
    },
    "TREE.TYPEAHEAD": {
      actions: ["focusMatchedNode"]
    }
  },
  exit: ["clearPendingAborts"],
  states: {
    idle: {
      on: {
        "NODE.RENAME": {
          target: "renaming",
          actions: ["setRenamingValue"]
        }
      }
    },
    renaming: {
      entry: ["syncRenameInput", "focusRenameInput"],
      on: {
        "RENAME.SUBMIT": {
          guard: "isRenameLabelValid",
          target: "idle",
          actions: ["submitRenaming"]
        },
        "RENAME.CANCEL": {
          target: "idle",
          actions: ["cancelRenaming"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isBranchFocused: ({ context, event }) => context.get("focusedValue") === event.id,
      isBranchExpanded: ({ context, event }) => context.get("expandedValue").includes(event.id),
      isShiftKey: ({ event }) => event.shiftKey,
      isCtrlKey: ({ event }) => event.ctrlKey,
      hasSelectedItems: ({ context }) => context.get("selectedValue").length > 0,
      isMultipleSelection: ({ prop }) => prop("selectionMode") === "multiple",
      moveFocus: ({ event }) => !!event.moveFocus,
      expandOnClick: ({ prop }) => !!prop("expandOnClick"),
      isRenameLabelValid: ({ event }) => event.label.trim() !== ""
    },
    actions: {
      selectNode({ context, event }) {
        const value = event.id || event.value;
        context.set("selectedValue", (prev2) => {
          if (value == null) return prev2;
          if (!event.isTrusted && isArray(value)) return prev2.concat(...value);
          return [isArray(value) ? last(value) : value].filter(Boolean);
        });
      },
      deselectNode({ context, event }) {
        const value = toArray(event.id || event.value);
        context.set("selectedValue", (prev2) => remove(prev2, ...value));
      },
      setFocusedNode({ context, event }) {
        context.set("focusedValue", event.id);
      },
      clearFocusedNode({ context }) {
        context.set("focusedValue", null);
      },
      clearSelectedItem({ context }) {
        context.set("selectedValue", []);
      },
      toggleBranchNode({ context, event, action }) {
        const isExpanded = context.get("expandedValue").includes(event.id);
        action(isExpanded ? ["collapseBranch"] : ["expandBranch"]);
      },
      expandBranch(params) {
        const { event } = params;
        expandBranches(params, [event.id]);
      },
      expandBranches(params) {
        const { context, event } = params;
        const valuesToExpand = toArray(event.value);
        expandBranches(params, diff(valuesToExpand, context.get("expandedValue")));
      },
      collapseBranch({ context, event }) {
        context.set("expandedValue", (prev2) => remove(prev2, event.id));
      },
      collapseBranches(params) {
        const { context, event } = params;
        const value = toArray(event.value);
        context.set("expandedValue", (prev2) => remove(prev2, ...value));
      },
      setExpanded({ context, event }) {
        if (!isArray(event.value)) return;
        context.set("expandedValue", event.value);
      },
      clearExpanded({ context }) {
        context.set("expandedValue", []);
      },
      setSelected({ context, event }) {
        if (!isArray(event.value)) return;
        context.set("selectedValue", event.value);
      },
      clearSelected({ context }) {
        context.set("selectedValue", []);
      },
      focusTreeFirstNode(params) {
        const { prop, scope } = params;
        const collection22 = prop("collection");
        const firstNode = collection22.getFirstNode();
        const firstValue = collection22.getNodeValue(firstNode);
        const scrolled = scrollToNode(params, firstValue);
        if (scrolled) raf(() => focusNode(scope, firstValue));
        else focusNode(scope, firstValue);
      },
      focusTreeLastNode(params) {
        const { prop, scope } = params;
        const collection22 = prop("collection");
        const lastNode = collection22.getLastNode(void 0, { skip: skipFn(params) });
        const lastValue = collection22.getNodeValue(lastNode);
        const scrolled = scrollToNode(params, lastValue);
        if (scrolled) raf(() => focusNode(scope, lastValue));
        else focusNode(scope, lastValue);
      },
      focusBranchFirstNode(params) {
        const { event, prop, scope } = params;
        const collection22 = prop("collection");
        const branchNode = collection22.findNode(event.id);
        const firstNode = collection22.getFirstNode(branchNode);
        const firstValue = collection22.getNodeValue(firstNode);
        const scrolled = scrollToNode(params, firstValue);
        if (scrolled) raf(() => focusNode(scope, firstValue));
        else focusNode(scope, firstValue);
      },
      focusTreeNextNode(params) {
        const { event, prop, scope } = params;
        const collection22 = prop("collection");
        const nextNode = collection22.getNextNode(event.id, { skip: skipFn(params) });
        if (!nextNode) return;
        const nextValue = collection22.getNodeValue(nextNode);
        const scrolled = scrollToNode(params, nextValue);
        if (scrolled) raf(() => focusNode(scope, nextValue));
        else focusNode(scope, nextValue);
      },
      focusTreePrevNode(params) {
        const { event, prop, scope } = params;
        const collection22 = prop("collection");
        const prevNode = collection22.getPreviousNode(event.id, { skip: skipFn(params) });
        if (!prevNode) return;
        const prevValue = collection22.getNodeValue(prevNode);
        const scrolled = scrollToNode(params, prevValue);
        if (scrolled) raf(() => focusNode(scope, prevValue));
        else focusNode(scope, prevValue);
      },
      focusBranchNode(params) {
        const { event, prop, scope } = params;
        const collection22 = prop("collection");
        const parentNode = collection22.getParentNode(event.id);
        const parentValue = parentNode ? collection22.getNodeValue(parentNode) : void 0;
        if (!parentValue) return;
        const scrolled = scrollToNode(params, parentValue);
        if (scrolled) raf(() => focusNode(scope, parentValue));
        else focusNode(scope, parentValue);
      },
      selectAllNodes({ context, prop }) {
        context.set("selectedValue", prop("collection").getValues());
      },
      focusMatchedNode(params) {
        const { context, prop, refs, event, scope, computed } = params;
        const nodes = computed("visibleNodes");
        const elements = nodes.map(({ node: node2 }) => ({
          textContent: prop("collection").stringifyNode(node2),
          id: prop("collection").getNodeValue(node2)
        }));
        const node = getByTypeahead(elements, {
          state: refs.get("typeaheadState"),
          activeId: context.get("focusedValue"),
          key: event.key
        });
        if (!node?.id) return;
        const scrolled = scrollToNode(params, node.id);
        if (scrolled) raf(() => focusNode(scope, node.id));
        else focusNode(scope, node.id);
      },
      toggleNodeSelection({ context, event }) {
        const selectedValue = addOrRemove(context.get("selectedValue"), event.id);
        context.set("selectedValue", selectedValue);
      },
      expandAllBranches(params) {
        const { context, prop } = params;
        const branchValues = prop("collection").getBranchValues();
        const valuesToExpand = diff(branchValues, context.get("expandedValue"));
        expandBranches(params, valuesToExpand);
      },
      expandSiblingBranches(params) {
        const { context, event, prop } = params;
        const collection22 = prop("collection");
        const indexPath = collection22.getIndexPath(event.id);
        if (!indexPath) return;
        const nodes = collection22.getSiblingNodes(indexPath);
        const values = nodes.map((node) => collection22.getNodeValue(node));
        const valuesToExpand = diff(values, context.get("expandedValue"));
        expandBranches(params, valuesToExpand);
      },
      extendSelectionToNode(params) {
        const { context, event, prop, computed } = params;
        const collection22 = prop("collection");
        const anchorValue = first(context.get("selectedValue")) || collection22.getNodeValue(collection22.getFirstNode());
        const targetValue = event.id;
        let values = [anchorValue, targetValue];
        let hits = 0;
        const visibleNodes = computed("visibleNodes");
        visibleNodes.forEach(({ node }) => {
          const nodeValue = collection22.getNodeValue(node);
          if (hits === 1) values.push(nodeValue);
          if (nodeValue === anchorValue || nodeValue === targetValue) hits++;
        });
        context.set("selectedValue", uniq(values));
      },
      extendSelectionToNextNode(params) {
        const { context, event, prop } = params;
        const collection22 = prop("collection");
        const nextNode = collection22.getNextNode(event.id, { skip: skipFn(params) });
        if (!nextNode) return;
        const values = new Set(context.get("selectedValue"));
        const nextValue = collection22.getNodeValue(nextNode);
        if (nextValue == null) return;
        if (values.has(event.id) && values.has(nextValue)) {
          values.delete(event.id);
        } else if (!values.has(nextValue)) {
          values.add(nextValue);
        }
        context.set("selectedValue", Array.from(values));
      },
      extendSelectionToPrevNode(params) {
        const { context, event, prop } = params;
        const collection22 = prop("collection");
        const prevNode = collection22.getPreviousNode(event.id, { skip: skipFn(params) });
        if (!prevNode) return;
        const values = new Set(context.get("selectedValue"));
        const prevValue = collection22.getNodeValue(prevNode);
        if (prevValue == null) return;
        if (values.has(event.id) && values.has(prevValue)) {
          values.delete(event.id);
        } else if (!values.has(prevValue)) {
          values.add(prevValue);
        }
        context.set("selectedValue", Array.from(values));
      },
      extendSelectionToFirstNode(params) {
        const { context, prop } = params;
        const collection22 = prop("collection");
        const currentSelection = first(context.get("selectedValue"));
        const values = [];
        collection22.visit({
          skip: skipFn(params),
          onEnter: (node) => {
            const nodeValue = collection22.getNodeValue(node);
            values.push(nodeValue);
            if (nodeValue === currentSelection) {
              return "stop";
            }
          }
        });
        context.set("selectedValue", values);
      },
      extendSelectionToLastNode(params) {
        const { context, prop } = params;
        const collection22 = prop("collection");
        const currentSelection = first(context.get("selectedValue"));
        const values = [];
        let current = false;
        collection22.visit({
          skip: skipFn(params),
          onEnter: (node) => {
            const nodeValue = collection22.getNodeValue(node);
            if (nodeValue === currentSelection) current = true;
            if (current) values.push(nodeValue);
          }
        });
        context.set("selectedValue", values);
      },
      clearPendingAborts({ refs }) {
        const aborts = refs.get("pendingAborts");
        aborts.forEach((abort) => abort.abort());
        aborts.clear();
      },
      toggleChecked({ context, event, prop }) {
        const collection22 = prop("collection");
        context.set(
          "checkedValue",
          (prev2) => event.isBranch ? toggleBranchChecked(collection22, event.value, prev2) : addOrRemove(prev2, event.value)
        );
      },
      setChecked({ context, event }) {
        context.set("checkedValue", event.value);
      },
      clearChecked({ context }) {
        context.set("checkedValue", []);
      },
      setRenamingValue({ context, event, prop }) {
        context.set("renamingValue", event.value);
        const onRenameStartFn = prop("onRenameStart");
        if (onRenameStartFn) {
          const collection22 = prop("collection");
          const indexPath = collection22.getIndexPath(event.value);
          if (indexPath) {
            const node = collection22.at(indexPath);
            if (node) {
              onRenameStartFn({
                value: event.value,
                node,
                indexPath
              });
            }
          }
        }
      },
      submitRenaming({ context, event, prop, scope }) {
        const renamingValue = context.get("renamingValue");
        if (!renamingValue) return;
        const collection22 = prop("collection");
        const indexPath = collection22.getIndexPath(renamingValue);
        if (!indexPath) return;
        const trimmedLabel = event.label.trim();
        const onBeforeRenameFn = prop("onBeforeRename");
        if (onBeforeRenameFn) {
          const details = {
            value: renamingValue,
            label: trimmedLabel,
            indexPath
          };
          const shouldRename = onBeforeRenameFn(details);
          if (!shouldRename) {
            context.set("renamingValue", null);
            focusNode(scope, renamingValue);
            return;
          }
        }
        prop("onRenameComplete")?.({
          value: renamingValue,
          label: trimmedLabel,
          indexPath
        });
        context.set("renamingValue", null);
        focusNode(scope, renamingValue);
      },
      cancelRenaming({ context, scope }) {
        const renamingValue = context.get("renamingValue");
        context.set("renamingValue", null);
        if (renamingValue) {
          focusNode(scope, renamingValue);
        }
      },
      syncRenameInput({ context, scope, prop }) {
        const renamingValue = context.get("renamingValue");
        if (!renamingValue) return;
        const collection22 = prop("collection");
        const node = collection22.findNode(renamingValue);
        if (!node) return;
        const label = collection22.stringifyNode(node);
        const inputEl = getRenameInputEl(scope, renamingValue);
        setElementValue(inputEl, label);
      },
      focusRenameInput({ context, scope }) {
        const renamingValue = context.get("renamingValue");
        if (!renamingValue) return;
        const inputEl = getRenameInputEl(scope, renamingValue);
        if (!inputEl) return;
        inputEl.focus();
        inputEl.select();
      }
    }
  }
});
function scrollToNode(params, value) {
  const { prop, scope, computed } = params;
  const scrollToIndexFn = prop("scrollToIndexFn");
  if (!scrollToIndexFn) return false;
  const collection22 = prop("collection");
  const visibleNodes = computed("visibleNodes");
  for (let i = 0; i < visibleNodes.length; i++) {
    const { node, indexPath } = visibleNodes[i];
    if (collection22.getNodeValue(node) !== value) continue;
    scrollToIndexFn({
      index: i,
      node,
      indexPath,
      getElement: () => scope.getById(getNodeId(scope, value))
    });
    return true;
  }
  return false;
}
var props24 = createProps()([
  "ids",
  "collection",
  "dir",
  "expandedValue",
  "expandOnClick",
  "defaultFocusedValue",
  "focusedValue",
  "getRootNode",
  "id",
  "onExpandedChange",
  "onFocusChange",
  "onSelectionChange",
  "checkedValue",
  "selectedValue",
  "selectionMode",
  "typeahead",
  "defaultExpandedValue",
  "defaultSelectedValue",
  "defaultCheckedValue",
  "onCheckedChange",
  "onLoadChildrenComplete",
  "onLoadChildrenError",
  "loadChildren",
  "canRename",
  "onRenameStart",
  "onBeforeRename",
  "onRenameComplete",
  "scrollToIndexFn"
]);
var splitProps25 = createSplitProps(props24);
var itemProps12 = createProps()(["node", "indexPath"]);
var splitItemProps12 = createSplitProps(itemProps12);

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/modules/provider.svelte.js
function useTreeView(props25) {
  const service = useMachine(machine25, props25);
  const treeView = tag(user_derived(() => connect25(service, normalizeProps)), "treeView");
  return () => get(treeView);
}

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/root-provider.svelte
Root_provider24[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/root-provider.svelte";
var root_2230 = add_locations(from_html(`<div><!></div>`), Root_provider24[FILENAME], [[27, 1]]);
function Root_provider24($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Root_provider24);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), treeView = tag(user_derived(() => $$props.value), "treeView"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children", "value"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(get(treeView)().getRootProps(), get(rest))), "attributes");
  RootContext26.provide(() => get(treeView)());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root_provider24, 25, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2230();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root_provider24, 28, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root_provider24,
      24,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root_provider24 = hmr(Root_provider24);
  import.meta.hot.accept((module) => {
    Root_provider24[HMR].update(module.default);
  });
}
var root_provider_default24 = Root_provider24;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/root.svelte
Root28[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/root.svelte";
var root_2231 = add_locations(from_html(`<div><!></div>`), Root28[FILENAME], [[34, 1]]);
function Root28($$anchor, $$props) {
  const id = props_id();
  check_target(new.target);
  push($$props, true, Root28);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const $$d = user_derived(() => splitProps25(props25)), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), treeViewProps = tag(user_derived(() => get($$array)[0]), "treeViewProps"), componentProps = tag(user_derived(() => get($$array)[1]), "componentProps");
  const element2 = tag(user_derived(() => get(componentProps).element), "element"), children = tag(user_derived(() => get(componentProps).children), "children"), rest = tag(user_derived(() => exclude_from_object(get(componentProps), ["element", "children"])), "rest");
  const treeView = useTreeView(() => ({ ...get(treeViewProps), id }));
  const attributes = tag(user_derived(() => mergeProps2(treeView().getRootProps(), get(rest))), "attributes");
  RootContext26.provide(() => treeView());
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Root28, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2231();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Root28, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Root28,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Root28 = hmr(Root28);
  import.meta.hot.accept((module) => {
    Root28[HMR].update(module.default);
  });
}
var root_default28 = Root28;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/tree.svelte
Tree[FILENAME] = "node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/anatomy/tree.svelte";
var root_2232 = add_locations(from_html(`<div><!></div>`), Tree[FILENAME], [[24, 1]]);
function Tree($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tree);
  const props25 = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
  const treeView = RootContext26.consume();
  const element2 = tag(user_derived(() => $$props.element), "element"), children = tag(user_derived(() => $$props.children), "children"), rest = tag(user_derived(() => exclude_from_object(props25, ["element", "children"])), "rest");
  const attributes = tag(user_derived(() => mergeProps2(treeView().getTreeProps(), get(rest))), "attributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => get(element2), () => get(attributes)), "render", Tree, 22, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2232();
      attribute_effect(div, () => ({ ...get(attributes) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => get(children) ?? noop), "render", Tree, 25, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(element2)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Tree,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Tree = hmr(Tree);
  import.meta.hot.accept((module) => {
    Tree[HMR].update(module.default);
  });
}
var tree_default = Tree;

// node_modules/@skeletonlabs/skeleton-svelte/dist/components/tree-view/modules/anatomy.js
var TreeView = Object.assign(root_default28, {
  Provider: root_provider_default24,
  Context: root_context_default25,
  Tree: tree_default,
  Label: label_default12,
  NodeProvider: node_provider_default,
  NodeContext: node_context_default,
  Branch: branch_default,
  BranchControl: branch_control_default,
  BranchText: branch_text_default,
  BranchIndicator: branch_indicator_default,
  BranchContent: branch_content_default,
  BranchIndentGuide: branch_indent_guide_default,
  Item: item_default13
});

// node_modules/@skeletonlabs/skeleton-svelte/dist/hooks/use-list-collection.js
function useListCollection(options) {
  return new ListCollection(options);
}
export {
  Accordion,
  AppBar,
  Avatar,
  Carousel,
  Collapsible,
  Combobox,
  DatePicker,
  Dialog,
  FileUpload,
  FloatingPanel,
  Listbox,
  Menu,
  Navigation,
  Pagination,
  Popover,
  Portal,
  Progress,
  RatingGroup,
  SegmentedControl,
  Slider,
  Steps,
  Switch,
  Tabs,
  TagsInput,
  Toast,
  ToggleGroup,
  Tooltip,
  TreeView,
  createToastStore as createToaster,
  collection3 as createTreeViewCollection,
  parse as parseDate,
  useAccordion,
  useAvatar,
  useCarousel,
  useCollapsible,
  useCombobox,
  useDatePicker,
  useDialog,
  useFileUpload,
  useFloatingPanel,
  useListCollection,
  useListbox,
  useMenu,
  usePagination,
  usePopover,
  useProgress,
  useRatingGroup,
  useSegmentedControl,
  useSlider,
  useSteps,
  useSwitch,
  useTabs,
  useTagsInput,
  useToggleGroup,
  useTooltip,
  useTreeView
};
//# sourceMappingURL=@skeletonlabs_skeleton-svelte.js.map
